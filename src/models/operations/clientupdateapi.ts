/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const ClientUpdateApiServerList = [
  /**
   * ðŸ‡ºðŸ‡¸ US Cluster
   */
  "https://us.authlete.com",
  /**
   * ðŸ‡¯ðŸ‡µ Japan Cluster
   */
  "https://jp.authlete.com",
  /**
   * ðŸ‡ªðŸ‡º Europe Cluster
   */
  "https://eu.authlete.com",
  /**
   * ðŸ‡§ðŸ‡· Brazil Cluster
   */
  "https://br.authlete.com",
] as const;

export type ClientUpdateApiClientNameRequest = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ClientUpdateApiDescriptionRequest = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * The client type, either `CONFIDENTIAL` or `PUBLIC`. See [RFC 6749, 2.1. Client Types](https://datatracker.ietf.org/doc/html/rfc6749#section-2.1)
 *
 * @remarks
 * for details.
 */
export const ClientUpdateApiClientTypeRequest = {
  Public: "PUBLIC",
  Confidential: "CONFIDENTIAL",
} as const;
/**
 * The client type, either `CONFIDENTIAL` or `PUBLIC`. See [RFC 6749, 2.1. Client Types](https://datatracker.ietf.org/doc/html/rfc6749#section-2.1)
 *
 * @remarks
 * for details.
 */
export type ClientUpdateApiClientTypeRequest = ClosedEnum<
  typeof ClientUpdateApiClientTypeRequest
>;

/**
 * The application type. The value of this property affects the validation steps for a redirect URI.
 *
 * @remarks
 * See the description about `redirectUris` property for more details.
 */
export const ClientUpdateApiApplicationTypeRequest = {
  Web: "WEB",
  Native: "NATIVE",
} as const;
/**
 * The application type. The value of this property affects the validation steps for a redirect URI.
 *
 * @remarks
 * See the description about `redirectUris` property for more details.
 */
export type ClientUpdateApiApplicationTypeRequest = ClosedEnum<
  typeof ClientUpdateApiApplicationTypeRequest
>;

export type ClientUpdateApiLogoUrisRequest = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export const ClientUpdateApiGrantTypeRequest = {
  AuthorizationCode: "AUTHORIZATION_CODE",
  Implicit: "IMPLICIT",
  Password: "PASSWORD",
  ClientCredentials: "CLIENT_CREDENTIALS",
  RefreshToken: "REFRESH_TOKEN",
  Ciba: "CIBA",
  DeviceCode: "DEVICE_CODE",
  TokenExchange: "TOKEN_EXCHANGE",
  JwtBearer: "JWT_BEARER",
} as const;
/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export type ClientUpdateApiGrantTypeRequest = ClosedEnum<
  typeof ClientUpdateApiGrantTypeRequest
>;

export const ClientUpdateApiResponseTypeRequest = {
  None: "NONE",
  Code: "CODE",
  Token: "TOKEN",
  IdToken: "ID_TOKEN",
  CodeToken: "CODE_TOKEN",
  CodeIdToken: "CODE_ID_TOKEN",
  IdTokenToken: "ID_TOKEN_TOKEN",
  CodeIdTokenToken: "CODE_ID_TOKEN_TOKEN",
} as const;
export type ClientUpdateApiResponseTypeRequest = ClosedEnum<
  typeof ClientUpdateApiResponseTypeRequest
>;

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiAuthorizationSignAlgRequest = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiAuthorizationSignAlgRequest = ClosedEnum<
  typeof ClientUpdateApiAuthorizationSignAlgRequest
>;

/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export const ClientUpdateApiAuthorizationEncryptionAlgRequest = {
  Rsa15: "RSA1_5",
  RsaOaep: "RSA_OAEP",
  RsaOaep256: "RSA_OAEP_256",
  A128Kw: "A128KW",
  A192Kw: "A192KW",
  A256Kw: "A256KW",
  Dir: "DIR",
  EcdhEs: "ECDH_ES",
  EcdhEsA128Kw: "ECDH_ES_A128KW",
  EcdhEsA192Kw: "ECDH_ES_A192KW",
  EcdhEsA256Kw: "ECDH_ES_A256KW",
  A128Gcmkw: "A128GCMKW",
  A192Gcmkw: "A192GCMKW",
  A256Gcmkw: "A256GCMKW",
  Pbes2Hs256A128Kw: "PBES2_HS256_A128KW",
  Pbes2Hs384A192Kw: "PBES2_HS384_A192KW",
  Pbes2Hs512A256Kw: "PBES2_HS512_A256KW",
} as const;
/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export type ClientUpdateApiAuthorizationEncryptionAlgRequest = ClosedEnum<
  typeof ClientUpdateApiAuthorizationEncryptionAlgRequest
>;

/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export const ClientUpdateApiAuthorizationEncryptionEncRequest = {
  A128CbcHs256: "A128CBC_HS256",
  A192CbcHs384: "A192CBC_HS384",
  A256CbcHs512: "A256CBC_HS512",
  A128Gcm: "A128GCM",
  A192Gcm: "A192GCM",
  A256Gcm: "A256GCM",
} as const;
/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export type ClientUpdateApiAuthorizationEncryptionEncRequest = ClosedEnum<
  typeof ClientUpdateApiAuthorizationEncryptionEncRequest
>;

/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export const ClientUpdateApiTokenAuthMethodRequest = {
  None: "NONE",
  ClientSecretBasic: "CLIENT_SECRET_BASIC",
  ClientSecretPost: "CLIENT_SECRET_POST",
  ClientSecretJwt: "CLIENT_SECRET_JWT",
  PrivateKeyJwt: "PRIVATE_KEY_JWT",
  TlsClientAuth: "TLS_CLIENT_AUTH",
  SelfSignedTlsClientAuth: "SELF_SIGNED_TLS_CLIENT_AUTH",
} as const;
/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export type ClientUpdateApiTokenAuthMethodRequest = ClosedEnum<
  typeof ClientUpdateApiTokenAuthMethodRequest
>;

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiTokenAuthSignAlgRequest = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiTokenAuthSignAlgRequest = ClosedEnum<
  typeof ClientUpdateApiTokenAuthSignAlgRequest
>;

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiRequestSignAlgRequest = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiRequestSignAlgRequest = ClosedEnum<
  typeof ClientUpdateApiRequestSignAlgRequest
>;

/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export const ClientUpdateApiRequestEncryptionAlgRequest = {
  Rsa15: "RSA1_5",
  RsaOaep: "RSA_OAEP",
  RsaOaep256: "RSA_OAEP_256",
  A128Kw: "A128KW",
  A192Kw: "A192KW",
  A256Kw: "A256KW",
  Dir: "DIR",
  EcdhEs: "ECDH_ES",
  EcdhEsA128Kw: "ECDH_ES_A128KW",
  EcdhEsA192Kw: "ECDH_ES_A192KW",
  EcdhEsA256Kw: "ECDH_ES_A256KW",
  A128Gcmkw: "A128GCMKW",
  A192Gcmkw: "A192GCMKW",
  A256Gcmkw: "A256GCMKW",
  Pbes2Hs256A128Kw: "PBES2_HS256_A128KW",
  Pbes2Hs384A192Kw: "PBES2_HS384_A192KW",
  Pbes2Hs512A256Kw: "PBES2_HS512_A256KW",
} as const;
/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export type ClientUpdateApiRequestEncryptionAlgRequest = ClosedEnum<
  typeof ClientUpdateApiRequestEncryptionAlgRequest
>;

/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export const ClientUpdateApiRequestEncryptionEncRequest = {
  A128CbcHs256: "A128CBC_HS256",
  A192CbcHs384: "A192CBC_HS384",
  A256CbcHs512: "A256CBC_HS512",
  A128Gcm: "A128GCM",
  A192Gcm: "A192GCM",
  A256Gcm: "A256GCM",
} as const;
/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export type ClientUpdateApiRequestEncryptionEncRequest = ClosedEnum<
  typeof ClientUpdateApiRequestEncryptionEncRequest
>;

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiIdTokenSignAlgRequest = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiIdTokenSignAlgRequest = ClosedEnum<
  typeof ClientUpdateApiIdTokenSignAlgRequest
>;

/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export const ClientUpdateApiIdTokenEncryptionAlgRequest = {
  Rsa15: "RSA1_5",
  RsaOaep: "RSA_OAEP",
  RsaOaep256: "RSA_OAEP_256",
  A128Kw: "A128KW",
  A192Kw: "A192KW",
  A256Kw: "A256KW",
  Dir: "DIR",
  EcdhEs: "ECDH_ES",
  EcdhEsA128Kw: "ECDH_ES_A128KW",
  EcdhEsA192Kw: "ECDH_ES_A192KW",
  EcdhEsA256Kw: "ECDH_ES_A256KW",
  A128Gcmkw: "A128GCMKW",
  A192Gcmkw: "A192GCMKW",
  A256Gcmkw: "A256GCMKW",
  Pbes2Hs256A128Kw: "PBES2_HS256_A128KW",
  Pbes2Hs384A192Kw: "PBES2_HS384_A192KW",
  Pbes2Hs512A256Kw: "PBES2_HS512_A256KW",
} as const;
/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export type ClientUpdateApiIdTokenEncryptionAlgRequest = ClosedEnum<
  typeof ClientUpdateApiIdTokenEncryptionAlgRequest
>;

/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export const ClientUpdateApiIdTokenEncryptionEncRequest = {
  A128CbcHs256: "A128CBC_HS256",
  A192CbcHs384: "A192CBC_HS384",
  A256CbcHs512: "A256CBC_HS512",
  A128Gcm: "A128GCM",
  A192Gcm: "A192GCM",
  A256Gcm: "A256GCM",
} as const;
/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export type ClientUpdateApiIdTokenEncryptionEncRequest = ClosedEnum<
  typeof ClientUpdateApiIdTokenEncryptionEncRequest
>;

/**
 * The subject type that the client application requests. Details about the subject type are described in
 *
 * @remarks
 * [OpenID Connect Core 1.0, 8. Subjct Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes).
 *
 * This property corresponds to `subject_type` in
 * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export const ClientUpdateApiSubjectTypeRequest = {
  Public: "PUBLIC",
  Pairwise: "PAIRWISE",
} as const;
/**
 * The subject type that the client application requests. Details about the subject type are described in
 *
 * @remarks
 * [OpenID Connect Core 1.0, 8. Subjct Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes).
 *
 * This property corresponds to `subject_type` in
 * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export type ClientUpdateApiSubjectTypeRequest = ClosedEnum<
  typeof ClientUpdateApiSubjectTypeRequest
>;

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiUserInfoSignAlgRequest = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiUserInfoSignAlgRequest = ClosedEnum<
  typeof ClientUpdateApiUserInfoSignAlgRequest
>;

/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export const ClientUpdateApiUserInfoEncryptionAlgRequest = {
  Rsa15: "RSA1_5",
  RsaOaep: "RSA_OAEP",
  RsaOaep256: "RSA_OAEP_256",
  A128Kw: "A128KW",
  A192Kw: "A192KW",
  A256Kw: "A256KW",
  Dir: "DIR",
  EcdhEs: "ECDH_ES",
  EcdhEsA128Kw: "ECDH_ES_A128KW",
  EcdhEsA192Kw: "ECDH_ES_A192KW",
  EcdhEsA256Kw: "ECDH_ES_A256KW",
  A128Gcmkw: "A128GCMKW",
  A192Gcmkw: "A192GCMKW",
  A256Gcmkw: "A256GCMKW",
  Pbes2Hs256A128Kw: "PBES2_HS256_A128KW",
  Pbes2Hs384A192Kw: "PBES2_HS384_A192KW",
  Pbes2Hs512A256Kw: "PBES2_HS512_A256KW",
} as const;
/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export type ClientUpdateApiUserInfoEncryptionAlgRequest = ClosedEnum<
  typeof ClientUpdateApiUserInfoEncryptionAlgRequest
>;

/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export const ClientUpdateApiUserInfoEncryptionEncRequest = {
  A128CbcHs256: "A128CBC_HS256",
  A192CbcHs384: "A192CBC_HS384",
  A256CbcHs512: "A256CBC_HS512",
  A128Gcm: "A128GCM",
  A192Gcm: "A192GCM",
  A256Gcm: "A256GCM",
} as const;
/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export type ClientUpdateApiUserInfoEncryptionEncRequest = ClosedEnum<
  typeof ClientUpdateApiUserInfoEncryptionEncRequest
>;

export type ClientUpdateApiTosUrisRequest = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ClientUpdateApiPolicyUrisRequest = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ClientUpdateApiClientUrisRequest = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiBcRequestSignAlgRequest = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiBcRequestSignAlgRequest = ClosedEnum<
  typeof ClientUpdateApiBcRequestSignAlgRequest
>;

export type ClientUpdateApiAttributeRequest = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ClientUpdateApiExtensionRequest = {
  /**
   * The set of scopes that the client application is allowed to request. This paramter will be one
   *
   * @remarks
   * of the following.
   *
   *   - `null`
   *   - an empty set
   *   - a set with at least one element
   *
   * When the value of this parameter is `null`, it means that the set of scopes that the client
   * application is allowed to request is the set of the scopes that the service supports. When the
   * value of this parameter is an empty set, it means that the client application is not allowed to
   * request any scopes. When the value of this parameter is a set with at least one element, it means
   * that the set is the set of scopes that the client application is allowed to request.
   */
  requestableScopes?: Array<string> | undefined;
  /**
   * The flag to indicate whether "Requestable Scopes per Client" is enabled or not. If `true`, you
   *
   * @remarks
   * can define the set of scopes which this client application can request. If `false`, this client
   * application can request any scope which is supported by the authorization server.
   */
  requestableScopesEnabled?: boolean | undefined;
  /**
   * The value of the duration of access tokens per client in seconds. In normal cases, the value of
   *
   * @remarks
   * the service's `accessTokenDuration` property is used as the duration of access tokens issued by
   * the service. However, if this `accessTokenDuration` property holds a non-zero positive number
   * and its value is less than the duration configured by the service, the value is used as the duration
   * of access tokens issued to the client application.
   *
   * Note that the duration of access tokens can be controlled by the scope attribute `access_token.duration`,
   * too. Authlete chooses the minimum value among the candidates.
   */
  accessTokenDuration?: number | undefined;
  /**
   * The value of the duration of refresh tokens per client in seconds. In normal cases, the value
   *
   * @remarks
   * of the service's `refreshTokenDuration` property is used as the duration of refresh tokens issued
   * by the service. However, if this `refreshTokenDuration` property holds a non-zero positive number
   * and its value is less than the duration configured by the service, the value is used as the duration
   * of refresh tokens issued to the client application.
   *
   * Note that the duration of refresh tokens can be controlled by the scope attribute `refresh_token.duration`,
   * too. Authlete chooses the minimum value among the candidates.
   */
  refreshTokenDuration?: number | undefined;
  /**
   * The value of the duration of ID tokens per client in seconds. In normal cases, the value
   *
   * @remarks
   * of the service's `idTokenDuration` property is used as the duration of ID tokens issued
   * by the service. However, if this `idTokenDuration` property holds a non-zero positive number
   * and its value is less than the duration configured by the service, the value is used as the duration
   * of ID tokens issued to the client application.
   *
   * Note that the duration of refresh tokens can be controlled by the scope attribute `id_token.duration`,
   * too. Authlete chooses the minimum value among the candidates.
   */
  idTokenDuration?: number | undefined;
  /**
   * Get the flag indicating whether the client is explicitly given a
   *
   * @remarks
   * permission to make token exchange requests ([RFC 8693][https://www.rfc-editor.org/rfc/rfc8693.html])
   */
  tokenExchangePermitted?: boolean | undefined;
};

/**
 * Values for the `client_registration_types` RP metadata and the
 *
 * @remarks
 *  `client_registration_types_supported` OP metadata that are defined in
 *  [OpenID Connect Federation 1.0](https://openid.net/specs/openid-connect-federation-1_0.html).
 */
export const ClientUpdateApiClientRegistrationTypeRequest = {
  Automatic: "AUTOMATIC",
  Explicit: "EXPLICIT",
} as const;
/**
 * Values for the `client_registration_types` RP metadata and the
 *
 * @remarks
 *  `client_registration_types_supported` OP metadata that are defined in
 *  [OpenID Connect Federation 1.0](https://openid.net/specs/openid-connect-federation-1_0.html).
 */
export type ClientUpdateApiClientRegistrationTypeRequest = ClosedEnum<
  typeof ClientUpdateApiClientRegistrationTypeRequest
>;

export const ClientUpdateApiFapiModeRequest = {
  Fapi1Advanced: "FAPI1_ADVANCED",
  Fapi1Baseline: "FAPI1_BASELINE",
  Fapi2MessageSigningAuthReq: "FAPI2_MESSAGE_SIGNING_AUTH_REQ",
  Fapi2MessageSigningAuthRes: "FAPI2_MESSAGE_SIGNING_AUTH_RES",
  Fapi2MessageSigningIntrospectionRes:
    "FAPI2_MESSAGE_SIGNING_INTROSPECTION_RES",
  Fapi2Security: "FAPI2_SECURITY",
} as const;
export type ClientUpdateApiFapiModeRequest = ClosedEnum<
  typeof ClientUpdateApiFapiModeRequest
>;

export const ClientUpdateApiResponseModeRequest = {
  Query: "QUERY",
  Fragment: "FRAGMENT",
  FormPost: "FORM_POST",
  Jwt: "JWT",
  QueryJwt: "QUERY_JWT",
  FragmentJwt: "FRAGMENT_JWT",
  FormPostJwt: "FORM_POST_JWT",
} as const;
export type ClientUpdateApiResponseModeRequest = ClosedEnum<
  typeof ClientUpdateApiResponseModeRequest
>;

export type ClientUpdateApiRequestBody = {
  /**
   * The name of the client application. This property corresponds to `client_name` in
   *
   * @remarks
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  clientName?: string | undefined;
  /**
   * Client names with language tags. If the client application has different names for different
   *
   * @remarks
   * languages, this property can be used to register the names.
   */
  clientNames?: Array<ClientUpdateApiClientNameRequest> | undefined;
  /**
   * The description about the client application.
   */
  description?: string | undefined;
  /**
   * Descriptions about the client application with language tags. If the client application has different
   *
   * @remarks
   * descriptions for different languages, this property can be used to register the descriptions.
   */
  descriptions?: Array<ClientUpdateApiDescriptionRequest> | undefined;
  /**
   * The value of the client's `client_id` property used in OAuth and OpenID Connect calls. By
   *
   * @remarks
   * default, this is a string version of the `clientId` property.
   */
  clientIdAlias?: string | undefined;
  /**
   * Deprecated. Always set to `true`.
   */
  clientIdAliasEnabled?: boolean | undefined;
  /**
   * The client type, either `CONFIDENTIAL` or `PUBLIC`. See [RFC 6749, 2.1. Client Types](https://datatracker.ietf.org/doc/html/rfc6749#section-2.1)
   *
   * @remarks
   * for details.
   */
  clientType?: ClientUpdateApiClientTypeRequest | undefined;
  /**
   * The application type. The value of this property affects the validation steps for a redirect URI.
   *
   * @remarks
   * See the description about `redirectUris` property for more details.
   */
  applicationType?: ClientUpdateApiApplicationTypeRequest | undefined;
  /**
   * The URL pointing to the logo image of the client application.
   *
   * @remarks
   *
   * This property corresponds to `logo_uri` in [OpenID Connect Dynamic Client Registration 1.0, 2.
   * Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  logoUri?: string | undefined;
  /**
   * Logo image URLs with language tags. If the client application has different logo images for
   *
   * @remarks
   * different languages, this property can be used to register URLs of the images.
   */
  logoUris?: Array<ClientUpdateApiLogoUrisRequest> | undefined;
  /**
   * An array of email addresses of people responsible for the client application.
   *
   * @remarks
   *
   * This property corresponds to contacts in [OpenID Connect Dynamic Client Registration 1.0, 2. Client
   * Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  contacts?: Array<string> | undefined;
  /**
   * The flag to indicate whether this client use TLS client certificate bound access tokens.
   *
   * @remarks
   */
  tlsClientCertificateBoundAccessTokens?: boolean | undefined;
  /**
   * The unique identifier string assigned by the client developer or software publisher used by
   *
   * @remarks
   * registration endpoints to identify the client software to be dynamically registered.
   *
   * This property corresponds to the `software_id metadata` defined in [2. Client Metadata](https://datatracker.ietf.org/doc/html/rfc7591#section-2)
   * of [RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591).
   */
  softwareId?: string | undefined;
  /**
   * The version identifier string for the client software identified by the software ID.
   *
   * @remarks
   *
   * This property corresponds to the software_version metadata defined in [2. Client Metadata](https://datatracker.ietf.org/doc/html/rfc7591#section-2)
   * of [RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591).
   */
  softwareVersion?: string | undefined;
  /**
   * The hash of the registration access token for this client.
   *
   * @remarks
   */
  registrationAccessTokenHash?: string | undefined;
  /**
   * A string array of grant types which the client application declares that it will restrict itself to using.
   *
   * @remarks
   * This property corresponds to `grant_types` in [OpenID Connect Dynamic Client Registration 1.0,
   * 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  grantTypes?: Array<ClientUpdateApiGrantTypeRequest> | undefined;
  /**
   * A string array of response types which the client application declares that it will restrict itself to using.
   *
   * @remarks
   * This property corresponds to `response_types` in [OpenID Connect Dynamic Client Registration 1.0,
   * 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  responseTypes?: Array<ClientUpdateApiResponseTypeRequest> | undefined;
  /**
   * Redirect URIs that the client application uses to receive a response from the authorization endpoint.
   *
   * @remarks
   * Requirements for a redirect URI are as follows.
   *
   * **Requirements by RFC 6749** (From [RFC 6749, 3.1.2. Redirection Endpoint](https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2))
   *
   * - Must be an absolute URI.
   * - Must not have a fragment component.
   *
   * **Requirements by OpenID Connect** (From "[OpenID Connect Dynamic Client Registration 1.0, 2.
   * Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata),
   * application_type")
   *
   * - The scheme of the redirect URI used for Implicit Grant by a client application whose application
   * is `web` must be `https`. This is checked at runtime by Authlete.
   * - The hostname of the redirect URI used for Implicit Grant by a client application whose application
   * type is `web` must not be `localhost`. This is checked at runtime by Authlete.
   * - The scheme of the redirect URI used by a client application whose application type is `native`
   * must be either (1) a custom scheme or (2) `http`, which is allowed only when the hostname part
   * is `localhost`. This is checked at runtime by Authlete.
   *
   * **Requirements by Authlete**
   *
   * - Must consist of printable ASCII letters only.
   * - Must not exceed 200 letters.
   *
   * Note that Authlete allows the application type to be `null`. In other words, a client application
   * does not have to choose `web` or `native` as its application type.
   * If the application type is `null`, the requirements by OpenID Connect are not checked at runtime.
   *
   * An authorization request from a client application which has not registered any redirect URI
   * fails unless at least all the following conditions are satisfied.
   *
   * - The client type of the client application is `confidential`.
   * - The value of `response_type` request parameter is `code`.
   * - The authorization request has the `redirect_uri` request parameter.
   * - The value of `scope` request parameter does not contain `openid`.
   *
   * RFC 6749 allows partial match of redirect URI under some conditions (see [RFC 6749, 3.1.2.2.
   * Registration Requirements](https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2.2) for
   * details), but OpenID Connect requires exact match.
   */
  redirectUris?: Array<string> | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  authorizationSignAlg?: ClientUpdateApiAuthorizationSignAlgRequest | undefined;
  /**
   * this is the 'alg' header value for encrypted JWT tokens.
   *
   * @remarks
   * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
   * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
   * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
   * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
   *
   * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
   */
  authorizationEncryptionAlg?:
    | ClientUpdateApiAuthorizationEncryptionAlgRequest
    | undefined;
  /**
   * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
   *
   * @remarks
   * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
   *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
   *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
   *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
   */
  authorizationEncryptionEnc?:
    | ClientUpdateApiAuthorizationEncryptionEncRequest
    | undefined;
  /**
   * The client authentication method that the client application declares that it uses at the token
   *
   * @remarks
   * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
   * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  tokenAuthMethod?: ClientUpdateApiTokenAuthMethodRequest | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  tokenAuthSignAlg?: ClientUpdateApiTokenAuthSignAlgRequest | undefined;
  /**
   * The key ID of a JWK containing a self-signed certificate of this client.
   *
   * @remarks
   */
  selfSignedCertificateKeyId?: string | undefined;
  /**
   * The string representation of the expected subject distinguished name of the certificate this
   *
   * @remarks
   * client will use in mutual TLS authentication.
   *
   * See `tls_client_auth_subject_dn` in "Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client
   * Registration" for details.
   */
  tlsClientAuthSubjectDn?: string | undefined;
  /**
   * The string representation of the expected DNS subject alternative name of the certificate this
   *
   * @remarks
   * client will use in mutual TLS authentication.
   *
   * See `tls_client_auth_san_dns` in "Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client
   * Registration" for details.
   */
  tlsClientAuthSanDns?: string | undefined;
  /**
   * The string representation of the expected URI subject alternative name of the certificate this
   *
   * @remarks
   * client will use in mutual TLS authentication.
   *
   * See `tls_client_auth_san_uri` in "Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client
   * Registration" for details.
   */
  tlsClientAuthSanUri?: string | undefined;
  /**
   * The string representation of the expected IP address subject alternative name of the certificate
   *
   * @remarks
   * this client will use in mutual TLS authentication.
   *
   * See `tls_client_auth_san_ip` in "Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client
   * Registration" for details.
   */
  tlsClientAuthSanIp?: string | undefined;
  /**
   * The string representation of the expected email address subject alternative name of the certificate
   *
   * @remarks
   * this client will use in mutual TLS authentication.
   *
   * See `tls_client_auth_san_email` in "Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client
   * Registration" for details.
   */
  tlsClientAuthSanEmail?: string | undefined;
  /**
   * The flag to indicate whether this client is required to use the pushed authorization request endpoint.
   *
   * @remarks
   * This property corresponds to the `require_pushed_authorization_requests` client metadata defined
   * in "OAuth 2.0 Pushed Authorization Requests".
   */
  parRequired?: boolean | undefined;
  /**
   * The flag to indicate whether authorization requests from this client are always required to
   *
   * @remarks
   * utilize a request object by using either `request` or `request_uri` request parameter.
   *
   * If this flag is set to `true` and the service's `traditionalRequestObjectProcessingApplied` is
   * set to `false`, authorization requests from this client are processed as if `require_signed_request_object`
   * client metadata of this client is `true`. The metadata is defined in "JAR (JWT Secured Authorization Request)".
   */
  requestObjectRequired?: boolean | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  requestSignAlg?: ClientUpdateApiRequestSignAlgRequest | undefined;
  /**
   * this is the 'alg' header value for encrypted JWT tokens.
   *
   * @remarks
   * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
   * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
   * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
   * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
   *
   * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
   */
  requestEncryptionAlg?: ClientUpdateApiRequestEncryptionAlgRequest | undefined;
  /**
   * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
   *
   * @remarks
   * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
   *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
   *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
   *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
   */
  requestEncryptionEnc?: ClientUpdateApiRequestEncryptionEncRequest | undefined;
  /**
   * An array of URLs each of which points to a request object.
   *
   * @remarks
   *
   * Authlete requires that URLs used as values for `request_uri` request parameter be pre-registered.
   * This property is used for the pre-registration.
   * See [OpenID Connect Core 1.0, 6.2. Passing a Request Object by Reference](https://openid.net/specs/openid-connect-core-1_0.html#RequestUriParameter) for details.
   */
  requestUris?: Array<string> | undefined;
  /**
   * The default maximum authentication age in seconds. This value is used when an authorization request from the client application does not have `max_age` request parameter.
   *
   * @remarks
   *
   * This property corresponds to `default_max_age` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  defaultMaxAge?: number | undefined;
  /**
   * The default ACRs (Authentication Context Class References). This value is used when an authorization
   *
   * @remarks
   * request from the client application has neither `acr_values` request parameter nor `acr` claim
   * in claims request parameter.
   */
  defaultAcrs?: Array<string> | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  idTokenSignAlg?: ClientUpdateApiIdTokenSignAlgRequest | undefined;
  /**
   * this is the 'alg' header value for encrypted JWT tokens.
   *
   * @remarks
   * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
   * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
   * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
   * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
   *
   * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
   */
  idTokenEncryptionAlg?: ClientUpdateApiIdTokenEncryptionAlgRequest | undefined;
  /**
   * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
   *
   * @remarks
   * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
   *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
   *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
   *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
   */
  idTokenEncryptionEnc?: ClientUpdateApiIdTokenEncryptionEncRequest | undefined;
  /**
   * The flag to indicate whether this client requires `auth_time` claim to be embedded in the ID token.
   *
   * @remarks
   *
   * This property corresponds to `require_auth_time` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  authTimeRequired?: boolean | undefined;
  /**
   * The subject type that the client application requests. Details about the subject type are described in
   *
   * @remarks
   * [OpenID Connect Core 1.0, 8. Subjct Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes).
   *
   * This property corresponds to `subject_type` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  subjectType?: ClientUpdateApiSubjectTypeRequest | undefined;
  /**
   * The value of the sector identifier URI.
   *
   * @remarks
   * This represents the `sector_identifier_uri` client metadata which is defined in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata)
   */
  sectorIdentifierUri?: string | undefined;
  /**
   * The URL pointing to the JWK Set of the client application.
   *
   * @remarks
   * The content pointed to by the URL is JSON which complies with the format described in
   * [JSON Web Key (JWK), 5. JWK Set Format](https://datatracker.ietf.org/doc/html/rfc7517#section-5).
   * The JWK Set must not include private keys of the client application.
   *
   * If the client application requests encryption for ID tokens (from the authorization/token/userinfo endpoints)
   * and/or signs request objects, it must make available its JWK Set containing public keys for the
   * encryption and/or the signature at the URL of `jwksUri`. The service (Authlete) fetches the JWK
   * Set from the URL as necessary.
   *
   * [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
   * says that `jwks` must not be used when the client can use `jwks_uri`, but Authlete allows both
   * properties to be registered at the same time. However, Authlete does not use the content of `jwks`
   * when `jwksUri` is registered.
   *
   * This property corresponds to `jwks_uri` in [OpenID Connect Dynamic Client Registration 1.0, 2.
   * Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  jwksUri?: string | undefined;
  /**
   * The content of the JWK Set of the client application.
   *
   * @remarks
   * The format is described in
   * [JSON Web Key (JWK), 5. JWK Set Format](https://datatracker.ietf.org/doc/html/rfc7517#section-5).
   * The JWK Set must not include private keys of the client application.
   *
   * [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
   * says that `jwks` must not be used when the client can use `jwks_uri`, but Authlete allows both
   * properties to be registered at the same time. However, Authlete does not use the content of `jwks`
   * when `jwksUri` is registered.
   *
   * This property corresponds to `jwks_uri` in [OpenID Connect Dynamic Client Registration 1.0, 2.
   * Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  jwks?: string | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  userInfoSignAlg?: ClientUpdateApiUserInfoSignAlgRequest | undefined;
  /**
   * this is the 'alg' header value for encrypted JWT tokens.
   *
   * @remarks
   * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
   * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
   * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
   * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
   *
   * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
   */
  userInfoEncryptionAlg?:
    | ClientUpdateApiUserInfoEncryptionAlgRequest
    | undefined;
  /**
   * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
   *
   * @remarks
   * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
   *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
   *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
   *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
   */
  userInfoEncryptionEnc?:
    | ClientUpdateApiUserInfoEncryptionEncRequest
    | undefined;
  /**
   * The URL which a third party can use to initiate a login by the client application.
   *
   * @remarks
   *
   * This property corresponds to `initiate_login_uri` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  loginUri?: string | undefined;
  /**
   * The URL pointing to the "Terms Of Service" page.
   *
   * @remarks
   *
   * This property corresponds to `tos_uri` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  tosUri?: string | undefined;
  /**
   * URLs of "Terms Of Service" pages with language tags.
   *
   * @remarks
   *
   * If the client application has different "Terms Of Service" pages for different languages,
   * this property can be used to register the URLs.
   */
  tosUris?: Array<ClientUpdateApiTosUrisRequest> | undefined;
  /**
   * The URL pointing to the page which describes the policy as to how end-user's profile data is used.
   *
   * @remarks
   *
   * This property corresponds to `policy_uri` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  policyUri?: string | undefined;
  /**
   * URLs of policy pages with language tags.
   *
   * @remarks
   * If the client application has different policy pages for different languages, this property can be used to register the URLs.
   */
  policyUris?: Array<ClientUpdateApiPolicyUrisRequest> | undefined;
  /**
   * The URL pointing to the home page of the client application.
   *
   * @remarks
   *
   * This property corresponds to `client_uri` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  clientUri?: string | undefined;
  /**
   * Home page URLs with language tags.
   *
   * @remarks
   * If the client application has different home pages for different languages, this property can
   * be used to register the URLs.
   */
  clientUris?: Array<ClientUpdateApiClientUrisRequest> | undefined;
  /**
   * The backchannel token delivery mode.
   *
   * @remarks
   *
   * This property corresponds to the `backchannel_token_delivery_mode` metadata.
   * The backchannel token delivery mode is defined in the specification of "CIBA (Client Initiated
   * Backchannel Authentication)".
   */
  bcDeliveryMode?: string | undefined;
  /**
   * The backchannel client notification endpoint.
   *
   * @remarks
   *
   * This property corresponds to the `backchannel_client_notification_endpoint` metadata.
   * The backchannel token delivery mode is defined in the specification of "CIBA (Client Initiated
   * Backchannel Authentication)".
   */
  bcNotificationEndpoint?: string | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  bcRequestSignAlg?: ClientUpdateApiBcRequestSignAlgRequest | undefined;
  /**
   * The boolean flag to indicate whether a user code is required when this client makes a backchannel
   *
   * @remarks
   * authentication request.
   *
   * This property corresponds to the `backchannel_user_code_parameter` metadata.
   */
  bcUserCodeRequired?: boolean | undefined;
  /**
   * The attributes of this client.
   *
   * @remarks
   */
  attributes?: Array<ClientUpdateApiAttributeRequest> | undefined;
  extension?: ClientUpdateApiExtensionRequest | undefined;
  /**
   * The authorization details types that this client may use as values of the `type` field in
   *
   * @remarks
   * `authorization_details`.
   *
   * This property corresponds to the `authorization_details_types` metadata. See [OAuth 2.0 Rich
   * Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/) for details.
   *
   * Note that the property name was renamed from authorizationDataTypes to authorizationDetailsTypes
   * to align with the change made by the 5th draft of the RAR specification.
   */
  authorizationDetailsTypes?: Array<string> | undefined;
  /**
   * The custom client metadata in JSON format.
   *
   * @remarks
   *
   * Standard specifications define client metadata as necessary. The following are such examples.
   *
   * * [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
   * * [RFC 7591 OAuth 2.0 Dynamic Client Registration Protocol](https://www.rfc-editor.org/rfc/rfc7591.html)
   * * [RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens](https://www.rfc-editor.org/rfc/rfc8705.html)
   * * [OpenID Connect Client-Initiated Backchannel Authentication Flow - Core 1.0](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html)
   * * [The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-jwsreq/)
   * * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
   * * [OAuth 2.0 Pushed Authorization Requests (PAR)](https://datatracker.ietf.org/doc/rfc9126/)
   * * [OAuth 2.0 Rich Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/)
   *
   * Standard client metadata included in Client Registration Request and Client Update Request (cf.
   * [OIDC DynReg](https://openid.net/specs/openid-connect-registration-1_0.html), [RFC 7591](https://www.rfc-editor.org/rfc/rfc7591.html)
   * and [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)) are, if supported by Authlete, set
   * to corresponding properties of the client application. For example, the value of the `client_name`
   * client metadata in Client Registration/Update Request is set to the clientName property. On the
   * other hand, unrecognized client metadata are discarded.
   *
   * By listing up custom client metadata in advance by using the `supportedCustomClientMetadata` property
   * of Service, Authlete can recognize them and stores their values into the database. The stored
   * custom client metadata values can be referenced by this property.
   */
  customMetadata?: string | undefined;
  /**
   * The flag indicating whether encryption of request object is required when the request object
   *
   * @remarks
   * is passed through the front channel.
   *
   * This flag does not affect the processing of request objects at the Pushed Authorization Request
   * Endpoint, which is defined in [OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/).
   * Unecrypted request objects are accepted at the endpoint even if this flag is `true`.
   *
   * This flag does not indicate whether a request object is always required. There is a different
   * flag, `requestObjectRequired`, for the purpose.
   *
   * Even if this flag is `false`, encryption of request object is required if the `frontChannelRequestObjectEncryptionRequired`
   * flag of the service is `true`.
   */
  frontChannelRequestObjectEncryptionRequired?: boolean | undefined;
  /**
   * The flag indicating whether the JWE alg of encrypted request object must match the `request_object_encryption_alg`
   *
   * @remarks
   * client metadata.
   *
   * The `request_object_encryption_alg` client metadata itself is defined in [OpenID Connect Dynamic
   * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
   *
   * > request_object_encryption_alg
   * >
   * > OPTIONAL. JWE [JWE] alg algorithm [JWA] the RP is declaring that it may use for encrypting Request
   *   Objects sent to the OP. This parameter SHOULD be included when symmetric encryption will be used,
   *   since this signals to the OP that a client_secret value needs to be returned from which the
   *   symmetric key will be derived, that might not otherwise be returned. The RP MAY still use other
   *   supported encryption algorithms or send unencrypted Request Objects, even when this parameter
   *   is present. If both signing and encryption are requested, the Request Object will be signed
   *   then encrypted, with the result being a Nested JWT, as defined in [JWT]. The default, if omitted,
   *   is that the RP is not declaring whether it might encrypt any Request Objects.
   *
   * The point here is "The RP MAY still use other supported encryption algorithms or send unencrypted
   * Request Objects, even when this parameter is present."
   *
   * The property that represents the client metadata is `requestEncryptionAlg`. See the description
   * of `requestEncryptionAlg` for details.
   *
   * Even if this flag is `false`, the match is required if the `requestObjectEncryptionAlgMatchRequired`
   * flag of the service is `true`.
   */
  requestObjectEncryptionAlgMatchRequired?: boolean | undefined;
  /**
   * The flag indicating whether the JWE enc of encrypted request object must match the `request_object_encryption_enc`
   *
   * @remarks
   * client metadata.
   *
   * The `request_object_encryption_enc` client metadata itself is defined in [OpenID Connect Dynamic
   * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
   *
   * > request_object_encryption_enc
   * >
   * > OPTIONAL. JWE enc algorithm [JWA] the RP is declaring that it may use for encrypting Request
   *   Objects sent to the OP. If request_object_encryption_alg is specified, the default for this
   *   value is A128CBC-HS256. When request_object_encryption_enc is included, request_object_encryption_alg
   *   MUST also be provided.
   *
   * The property that represents the client metadata is `requestEncryptionEnc`. See the description
   * of `requestEncryptionEnc`  for details.
   *
   * Even if this flag is `false`, the match is required if the `requestObjectEncryptionEncMatchRequired`
   * flag of the service is `true`.
   */
  requestObjectEncryptionEncMatchRequired?: boolean | undefined;
  /**
   * The digest algorithm that this client requests the server to use
   *
   * @remarks
   * when it computes digest values of <a href=
   * "https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#name-external-attachments"
   * >external attachments</a>, which may be referenced from within ID tokens
   * or userinfo responses (or any place that can have the `verified_claims` claim).
   *
   * Possible values are listed in the <a href=
   * "https://www.iana.org/assignments/named-information/named-information.xhtml#hash-alg"
   * >Hash Algorithm Registry</a> of IANA (Internet Assigned Numbers Authority),
   * but the server does not necessarily support all the values there. When
   * this property is omitted, `sha-256` is used as the default algorithm.
   *
   * This property corresponds to the `digest_algorithm` client metadata
   * which was defined by the third implementer's draft of
   * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html).
   */
  digestAlgorithm?: string | undefined;
  /**
   * If `Enabled` is selected, an attempt to issue a new access token invalidates existing access tokens that are associated with the same combination of subject and client.
   *
   * @remarks
   *
   * Note that, however, attempts by Client Credentials Flow do not invalidate existing access tokens because access tokens issued by Client Credentials Flow are not associated with any end-user's subject.
   *
   * Even if `Disabled` is selected here, single access token per subject is effective if `singleAccessTokenPerSubject` of the `Service` this client belongs to is Enabled.
   */
  singleAccessTokenPerSubject?: boolean | undefined;
  /**
   * The flag to indicate whether the use of Proof Key for Code Exchange (PKCE) is always required for authorization requests by Authorization Code Flow.
   *
   * @remarks
   *
   * If `true`, `code_challenge` request parameter is always required for authorization requests using Authorization Code Flow.
   *
   * See [RFC 7636](https://tools.ietf.org/html/rfc7636) (Proof Key for Code Exchange by OAuth Public Clients) for details about `code_challenge` request parameter.
   */
  pkceRequired?: boolean | undefined;
  /**
   * The flag to indicate whether `S256` is always required as the code challenge method whenever [PKCE (RFC 7636)](https://tools.ietf.org/html/rfc7636) is used.
   *
   * @remarks
   *
   * If this flag is set to `true`, `code_challenge_method=S256` must be included in the authorization request
   * whenever it includes the `code_challenge` request parameter.
   * Neither omission of the `code_challenge_method` request parameter nor use of plain (`code_challenge_method=plain`) is allowed.
   */
  pkceS256Required?: boolean | undefined;
  /**
   * If the DPoP is required for this client
   *
   * @remarks
   */
  dpopRequired?: boolean | undefined;
  /**
   * The flag indicating whether this client was registered by the
   *
   * @remarks
   * "automatic" client registration of OIDC Federation.
   */
  automaticallyRegistered?: boolean | undefined;
  /**
   * The flag indicating whether this client was registered by the
   *
   * @remarks
   * "explicit" client registration of OIDC Federation.
   */
  explicitlyRegistered?: boolean | undefined;
  /**
   * The flag indicating whether this service signs responses from the resource server.
   *
   * @remarks
   */
  rsRequestSigned?: boolean | undefined;
  /**
   * The key ID of a JWK containing the public key used by this client to sign requests to the resource server.
   *
   * @remarks
   */
  rsSignedRequestKeyId?: string | undefined;
  /**
   * The client registration types that the client has declared it may use.
   *
   * @remarks
   */
  clientRegistrationTypes?:
    | Array<ClientUpdateApiClientRegistrationTypeRequest>
    | undefined;
  /**
   * The human-readable name representing the organization that manages this client. This property corresponds
   *
   * @remarks
   * to the organization_name client metadata that is defined in OpenID Connect Federation 1.0.
   */
  organizationName?: string | undefined;
  /**
   * The URI of the endpoint that returns this client's JWK Set document in the JWT format. This property
   *
   * @remarks
   * corresponds to the `signed_jwks_uri` client metadata defined in OpenID Connect Federation 1.0.
   */
  signedJwksUri?: string | undefined;
  /**
   * the entity ID of this client.
   *
   * @remarks
   */
  entityId?: string | undefined;
  /**
   * The entity ID of the trust anchor of the trust chain that was used when this client was registered or updated by
   *
   * @remarks
   * the mechanism defined in OpenID Connect Federation 1.0
   */
  trustAnchorId?: string | undefined;
  /**
   * The trust chain that was used when this client was registered or updated by the mechanism defined in
   *
   * @remarks
   * OpenID Connect Federation 1.0
   */
  trustChain?: Array<string> | undefined;
  /**
   * the expiration time of the trust chain that was used when this client was registered or updated by the mechanism
   *
   * @remarks
   * defined in OpenID Connect Federation 1.0. The value is represented as milliseconds elapsed since the Unix epoch (1970-01-01).
   */
  trustChainExpiresAt?: number | undefined;
  /**
   * the time at which the trust chain was updated by the mechanism defined in OpenID Connect Federation 1.0
   *
   * @remarks
   */
  trustChainUpdatedAt?: number | undefined;
  /**
   * The flag which indicates whether this client is locked.
   *
   * @remarks
   */
  locked?: boolean | undefined;
  /**
   * The URL of the credential offer endpoint at which this client
   *
   * @remarks
   * (wallet) receives a credential offer from the credential issuer.
   */
  credentialOfferEndpoint?: string | undefined;
  /**
   * The FAPI modes for this client.
   *
   * @remarks
   *
   * When the value of this property is not `null`, Authlete always processes requests from this client
   * based on the specified FAPI modes if the FAPI feature is enabled in Authlete, the FAPI profile
   * is supported by the service, and the FAPI modes for the service are set to `null`.
   *
   * For instance, when this property is set to an array containing `FAPI1_ADVANCED` only, Authlete
   * always processes requests from this client based on "Financial-grade API Security Profile 1.0 -
   * Part 2: Advanced" if the FAPI feature is enabled in Authlete, the FAPI profile is supported by
   * the service, and the FAPI modes for the service are set to `null`.
   */
  fapiModes?: Array<ClientUpdateApiFapiModeRequest> | undefined;
  /**
   * The response modes that this client may use.
   */
  responseModes?: Array<ClientUpdateApiResponseModeRequest> | undefined;
  /**
   * True if credential responses to this client must be always encrypted.
   */
  credentialResponseEncryptionRequired?: boolean | undefined;
};

export type ClientUpdateApiRequest = {
  /**
   * A service ID.
   */
  serviceId: string;
  /**
   * A client ID.
   */
  clientId: string;
  requestBody?: ClientUpdateApiRequestBody | undefined;
};

export type ClientUpdateApiClientNameResponse = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ClientUpdateApiDescriptionResponse = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * The client type, either `CONFIDENTIAL` or `PUBLIC`. See [RFC 6749, 2.1. Client Types](https://datatracker.ietf.org/doc/html/rfc6749#section-2.1)
 *
 * @remarks
 * for details.
 */
export const ClientUpdateApiClientTypeResponse = {
  Public: "PUBLIC",
  Confidential: "CONFIDENTIAL",
} as const;
/**
 * The client type, either `CONFIDENTIAL` or `PUBLIC`. See [RFC 6749, 2.1. Client Types](https://datatracker.ietf.org/doc/html/rfc6749#section-2.1)
 *
 * @remarks
 * for details.
 */
export type ClientUpdateApiClientTypeResponse = ClosedEnum<
  typeof ClientUpdateApiClientTypeResponse
>;

/**
 * The application type. The value of this property affects the validation steps for a redirect URI.
 *
 * @remarks
 * See the description about `redirectUris` property for more details.
 */
export const ClientUpdateApiApplicationTypeResponse = {
  Web: "WEB",
  Native: "NATIVE",
} as const;
/**
 * The application type. The value of this property affects the validation steps for a redirect URI.
 *
 * @remarks
 * See the description about `redirectUris` property for more details.
 */
export type ClientUpdateApiApplicationTypeResponse = ClosedEnum<
  typeof ClientUpdateApiApplicationTypeResponse
>;

export type ClientUpdateApiLogoUrisResponse = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export const ClientUpdateApiGrantTypeResponse = {
  AuthorizationCode: "AUTHORIZATION_CODE",
  Implicit: "IMPLICIT",
  Password: "PASSWORD",
  ClientCredentials: "CLIENT_CREDENTIALS",
  RefreshToken: "REFRESH_TOKEN",
  Ciba: "CIBA",
  DeviceCode: "DEVICE_CODE",
  TokenExchange: "TOKEN_EXCHANGE",
  JwtBearer: "JWT_BEARER",
} as const;
/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export type ClientUpdateApiGrantTypeResponse = ClosedEnum<
  typeof ClientUpdateApiGrantTypeResponse
>;

export const ClientUpdateApiResponseTypeResponse = {
  None: "NONE",
  Code: "CODE",
  Token: "TOKEN",
  IdToken: "ID_TOKEN",
  CodeToken: "CODE_TOKEN",
  CodeIdToken: "CODE_ID_TOKEN",
  IdTokenToken: "ID_TOKEN_TOKEN",
  CodeIdTokenToken: "CODE_ID_TOKEN_TOKEN",
} as const;
export type ClientUpdateApiResponseTypeResponse = ClosedEnum<
  typeof ClientUpdateApiResponseTypeResponse
>;

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiAuthorizationSignAlgResponse = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiAuthorizationSignAlgResponse = ClosedEnum<
  typeof ClientUpdateApiAuthorizationSignAlgResponse
>;

/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export const ClientUpdateApiAuthorizationEncryptionAlgResponse = {
  Rsa15: "RSA1_5",
  RsaOaep: "RSA_OAEP",
  RsaOaep256: "RSA_OAEP_256",
  A128Kw: "A128KW",
  A192Kw: "A192KW",
  A256Kw: "A256KW",
  Dir: "DIR",
  EcdhEs: "ECDH_ES",
  EcdhEsA128Kw: "ECDH_ES_A128KW",
  EcdhEsA192Kw: "ECDH_ES_A192KW",
  EcdhEsA256Kw: "ECDH_ES_A256KW",
  A128Gcmkw: "A128GCMKW",
  A192Gcmkw: "A192GCMKW",
  A256Gcmkw: "A256GCMKW",
  Pbes2Hs256A128Kw: "PBES2_HS256_A128KW",
  Pbes2Hs384A192Kw: "PBES2_HS384_A192KW",
  Pbes2Hs512A256Kw: "PBES2_HS512_A256KW",
} as const;
/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export type ClientUpdateApiAuthorizationEncryptionAlgResponse = ClosedEnum<
  typeof ClientUpdateApiAuthorizationEncryptionAlgResponse
>;

/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export const ClientUpdateApiAuthorizationEncryptionEncResponse = {
  A128CbcHs256: "A128CBC_HS256",
  A192CbcHs384: "A192CBC_HS384",
  A256CbcHs512: "A256CBC_HS512",
  A128Gcm: "A128GCM",
  A192Gcm: "A192GCM",
  A256Gcm: "A256GCM",
} as const;
/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export type ClientUpdateApiAuthorizationEncryptionEncResponse = ClosedEnum<
  typeof ClientUpdateApiAuthorizationEncryptionEncResponse
>;

/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export const ClientUpdateApiTokenAuthMethodResponse = {
  None: "NONE",
  ClientSecretBasic: "CLIENT_SECRET_BASIC",
  ClientSecretPost: "CLIENT_SECRET_POST",
  ClientSecretJwt: "CLIENT_SECRET_JWT",
  PrivateKeyJwt: "PRIVATE_KEY_JWT",
  TlsClientAuth: "TLS_CLIENT_AUTH",
  SelfSignedTlsClientAuth: "SELF_SIGNED_TLS_CLIENT_AUTH",
} as const;
/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export type ClientUpdateApiTokenAuthMethodResponse = ClosedEnum<
  typeof ClientUpdateApiTokenAuthMethodResponse
>;

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiTokenAuthSignAlgResponse = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiTokenAuthSignAlgResponse = ClosedEnum<
  typeof ClientUpdateApiTokenAuthSignAlgResponse
>;

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiRequestSignAlgResponse = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiRequestSignAlgResponse = ClosedEnum<
  typeof ClientUpdateApiRequestSignAlgResponse
>;

/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export const ClientUpdateApiRequestEncryptionAlgResponse = {
  Rsa15: "RSA1_5",
  RsaOaep: "RSA_OAEP",
  RsaOaep256: "RSA_OAEP_256",
  A128Kw: "A128KW",
  A192Kw: "A192KW",
  A256Kw: "A256KW",
  Dir: "DIR",
  EcdhEs: "ECDH_ES",
  EcdhEsA128Kw: "ECDH_ES_A128KW",
  EcdhEsA192Kw: "ECDH_ES_A192KW",
  EcdhEsA256Kw: "ECDH_ES_A256KW",
  A128Gcmkw: "A128GCMKW",
  A192Gcmkw: "A192GCMKW",
  A256Gcmkw: "A256GCMKW",
  Pbes2Hs256A128Kw: "PBES2_HS256_A128KW",
  Pbes2Hs384A192Kw: "PBES2_HS384_A192KW",
  Pbes2Hs512A256Kw: "PBES2_HS512_A256KW",
} as const;
/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export type ClientUpdateApiRequestEncryptionAlgResponse = ClosedEnum<
  typeof ClientUpdateApiRequestEncryptionAlgResponse
>;

/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export const ClientUpdateApiRequestEncryptionEncResponse = {
  A128CbcHs256: "A128CBC_HS256",
  A192CbcHs384: "A192CBC_HS384",
  A256CbcHs512: "A256CBC_HS512",
  A128Gcm: "A128GCM",
  A192Gcm: "A192GCM",
  A256Gcm: "A256GCM",
} as const;
/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export type ClientUpdateApiRequestEncryptionEncResponse = ClosedEnum<
  typeof ClientUpdateApiRequestEncryptionEncResponse
>;

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiIdTokenSignAlgResponse = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiIdTokenSignAlgResponse = ClosedEnum<
  typeof ClientUpdateApiIdTokenSignAlgResponse
>;

/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export const ClientUpdateApiIdTokenEncryptionAlgResponse = {
  Rsa15: "RSA1_5",
  RsaOaep: "RSA_OAEP",
  RsaOaep256: "RSA_OAEP_256",
  A128Kw: "A128KW",
  A192Kw: "A192KW",
  A256Kw: "A256KW",
  Dir: "DIR",
  EcdhEs: "ECDH_ES",
  EcdhEsA128Kw: "ECDH_ES_A128KW",
  EcdhEsA192Kw: "ECDH_ES_A192KW",
  EcdhEsA256Kw: "ECDH_ES_A256KW",
  A128Gcmkw: "A128GCMKW",
  A192Gcmkw: "A192GCMKW",
  A256Gcmkw: "A256GCMKW",
  Pbes2Hs256A128Kw: "PBES2_HS256_A128KW",
  Pbes2Hs384A192Kw: "PBES2_HS384_A192KW",
  Pbes2Hs512A256Kw: "PBES2_HS512_A256KW",
} as const;
/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export type ClientUpdateApiIdTokenEncryptionAlgResponse = ClosedEnum<
  typeof ClientUpdateApiIdTokenEncryptionAlgResponse
>;

/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export const ClientUpdateApiIdTokenEncryptionEncResponse = {
  A128CbcHs256: "A128CBC_HS256",
  A192CbcHs384: "A192CBC_HS384",
  A256CbcHs512: "A256CBC_HS512",
  A128Gcm: "A128GCM",
  A192Gcm: "A192GCM",
  A256Gcm: "A256GCM",
} as const;
/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export type ClientUpdateApiIdTokenEncryptionEncResponse = ClosedEnum<
  typeof ClientUpdateApiIdTokenEncryptionEncResponse
>;

/**
 * The subject type that the client application requests. Details about the subject type are described in
 *
 * @remarks
 * [OpenID Connect Core 1.0, 8. Subjct Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes).
 *
 * This property corresponds to `subject_type` in
 * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export const ClientUpdateApiSubjectTypeResponse = {
  Public: "PUBLIC",
  Pairwise: "PAIRWISE",
} as const;
/**
 * The subject type that the client application requests. Details about the subject type are described in
 *
 * @remarks
 * [OpenID Connect Core 1.0, 8. Subjct Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes).
 *
 * This property corresponds to `subject_type` in
 * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export type ClientUpdateApiSubjectTypeResponse = ClosedEnum<
  typeof ClientUpdateApiSubjectTypeResponse
>;

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiUserInfoSignAlgResponse = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiUserInfoSignAlgResponse = ClosedEnum<
  typeof ClientUpdateApiUserInfoSignAlgResponse
>;

/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export const ClientUpdateApiUserInfoEncryptionAlgResponse = {
  Rsa15: "RSA1_5",
  RsaOaep: "RSA_OAEP",
  RsaOaep256: "RSA_OAEP_256",
  A128Kw: "A128KW",
  A192Kw: "A192KW",
  A256Kw: "A256KW",
  Dir: "DIR",
  EcdhEs: "ECDH_ES",
  EcdhEsA128Kw: "ECDH_ES_A128KW",
  EcdhEsA192Kw: "ECDH_ES_A192KW",
  EcdhEsA256Kw: "ECDH_ES_A256KW",
  A128Gcmkw: "A128GCMKW",
  A192Gcmkw: "A192GCMKW",
  A256Gcmkw: "A256GCMKW",
  Pbes2Hs256A128Kw: "PBES2_HS256_A128KW",
  Pbes2Hs384A192Kw: "PBES2_HS384_A192KW",
  Pbes2Hs512A256Kw: "PBES2_HS512_A256KW",
} as const;
/**
 * this is the 'alg' header value for encrypted JWT tokens.
 *
 * @remarks
 * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
 * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
 * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
 * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
 *
 * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
 */
export type ClientUpdateApiUserInfoEncryptionAlgResponse = ClosedEnum<
  typeof ClientUpdateApiUserInfoEncryptionAlgResponse
>;

/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export const ClientUpdateApiUserInfoEncryptionEncResponse = {
  A128CbcHs256: "A128CBC_HS256",
  A192CbcHs384: "A192CBC_HS384",
  A256CbcHs512: "A256CBC_HS512",
  A128Gcm: "A128GCM",
  A192Gcm: "A192GCM",
  A256Gcm: "A256GCM",
} as const;
/**
 * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
 *
 * @remarks
 * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
 *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
 *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
 *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
 */
export type ClientUpdateApiUserInfoEncryptionEncResponse = ClosedEnum<
  typeof ClientUpdateApiUserInfoEncryptionEncResponse
>;

export type ClientUpdateApiTosUrisResponse = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ClientUpdateApiPolicyUrisResponse = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ClientUpdateApiClientUrisResponse = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ClientUpdateApiBcRequestSignAlgResponse = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ClientUpdateApiBcRequestSignAlgResponse = ClosedEnum<
  typeof ClientUpdateApiBcRequestSignAlgResponse
>;

export type ClientUpdateApiAttributeResponse = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ClientUpdateApiExtensionResponse = {
  /**
   * The set of scopes that the client application is allowed to request. This paramter will be one
   *
   * @remarks
   * of the following.
   *
   *   - `null`
   *   - an empty set
   *   - a set with at least one element
   *
   * When the value of this parameter is `null`, it means that the set of scopes that the client
   * application is allowed to request is the set of the scopes that the service supports. When the
   * value of this parameter is an empty set, it means that the client application is not allowed to
   * request any scopes. When the value of this parameter is a set with at least one element, it means
   * that the set is the set of scopes that the client application is allowed to request.
   */
  requestableScopes?: Array<string> | undefined;
  /**
   * The flag to indicate whether "Requestable Scopes per Client" is enabled or not. If `true`, you
   *
   * @remarks
   * can define the set of scopes which this client application can request. If `false`, this client
   * application can request any scope which is supported by the authorization server.
   */
  requestableScopesEnabled?: boolean | undefined;
  /**
   * The value of the duration of access tokens per client in seconds. In normal cases, the value of
   *
   * @remarks
   * the service's `accessTokenDuration` property is used as the duration of access tokens issued by
   * the service. However, if this `accessTokenDuration` property holds a non-zero positive number
   * and its value is less than the duration configured by the service, the value is used as the duration
   * of access tokens issued to the client application.
   *
   * Note that the duration of access tokens can be controlled by the scope attribute `access_token.duration`,
   * too. Authlete chooses the minimum value among the candidates.
   */
  accessTokenDuration?: number | undefined;
  /**
   * The value of the duration of refresh tokens per client in seconds. In normal cases, the value
   *
   * @remarks
   * of the service's `refreshTokenDuration` property is used as the duration of refresh tokens issued
   * by the service. However, if this `refreshTokenDuration` property holds a non-zero positive number
   * and its value is less than the duration configured by the service, the value is used as the duration
   * of refresh tokens issued to the client application.
   *
   * Note that the duration of refresh tokens can be controlled by the scope attribute `refresh_token.duration`,
   * too. Authlete chooses the minimum value among the candidates.
   */
  refreshTokenDuration?: number | undefined;
  /**
   * The value of the duration of ID tokens per client in seconds. In normal cases, the value
   *
   * @remarks
   * of the service's `idTokenDuration` property is used as the duration of ID tokens issued
   * by the service. However, if this `idTokenDuration` property holds a non-zero positive number
   * and its value is less than the duration configured by the service, the value is used as the duration
   * of ID tokens issued to the client application.
   *
   * Note that the duration of refresh tokens can be controlled by the scope attribute `id_token.duration`,
   * too. Authlete chooses the minimum value among the candidates.
   */
  idTokenDuration?: number | undefined;
  /**
   * Get the flag indicating whether the client is explicitly given a
   *
   * @remarks
   * permission to make token exchange requests ([RFC 8693][https://www.rfc-editor.org/rfc/rfc8693.html])
   */
  tokenExchangePermitted?: boolean | undefined;
};

/**
 * Values for the `client_registration_types` RP metadata and the
 *
 * @remarks
 *  `client_registration_types_supported` OP metadata that are defined in
 *  [OpenID Connect Federation 1.0](https://openid.net/specs/openid-connect-federation-1_0.html).
 */
export const ClientUpdateApiClientRegistrationTypeResponse = {
  Automatic: "AUTOMATIC",
  Explicit: "EXPLICIT",
} as const;
/**
 * Values for the `client_registration_types` RP metadata and the
 *
 * @remarks
 *  `client_registration_types_supported` OP metadata that are defined in
 *  [OpenID Connect Federation 1.0](https://openid.net/specs/openid-connect-federation-1_0.html).
 */
export type ClientUpdateApiClientRegistrationTypeResponse = ClosedEnum<
  typeof ClientUpdateApiClientRegistrationTypeResponse
>;

export const ClientUpdateApiFapiModeResponse = {
  Fapi1Advanced: "FAPI1_ADVANCED",
  Fapi1Baseline: "FAPI1_BASELINE",
  Fapi2MessageSigningAuthReq: "FAPI2_MESSAGE_SIGNING_AUTH_REQ",
  Fapi2MessageSigningAuthRes: "FAPI2_MESSAGE_SIGNING_AUTH_RES",
  Fapi2MessageSigningIntrospectionRes:
    "FAPI2_MESSAGE_SIGNING_INTROSPECTION_RES",
  Fapi2Security: "FAPI2_SECURITY",
} as const;
export type ClientUpdateApiFapiModeResponse = ClosedEnum<
  typeof ClientUpdateApiFapiModeResponse
>;

export const ClientUpdateApiResponseModeResponse = {
  Query: "QUERY",
  Fragment: "FRAGMENT",
  FormPost: "FORM_POST",
  Jwt: "JWT",
  QueryJwt: "QUERY_JWT",
  FragmentJwt: "FRAGMENT_JWT",
  FormPostJwt: "FORM_POST_JWT",
} as const;
export type ClientUpdateApiResponseModeResponse = ClosedEnum<
  typeof ClientUpdateApiResponseModeResponse
>;

export type ClientUpdateApiResponse = {
  /**
   * The sequential number of the client. The value of this property is assigned by Authlete.
   *
   * @remarks
   */
  number?: number | undefined;
  /**
   * The sequential number of the service of the client application. The value of this property is
   *
   * @remarks
   * assigned by Authlete.
   */
  serviceNumber?: number | undefined;
  /**
   * The name of the client application. This property corresponds to `client_name` in
   *
   * @remarks
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  clientName?: string | undefined;
  /**
   * Client names with language tags. If the client application has different names for different
   *
   * @remarks
   * languages, this property can be used to register the names.
   */
  clientNames?: Array<ClientUpdateApiClientNameResponse> | undefined;
  /**
   * The description about the client application.
   */
  description?: string | undefined;
  /**
   * Descriptions about the client application with language tags. If the client application has different
   *
   * @remarks
   * descriptions for different languages, this property can be used to register the descriptions.
   */
  descriptions?: Array<ClientUpdateApiDescriptionResponse> | undefined;
  /**
   * The client identifier used in Authlete API calls. The value of this property is assigned by Authlete.
   */
  clientId?: number | undefined;
  /**
   * The client secret. A random 512-bit value encoded by base64url (86 letters). The value of this
   *
   * @remarks
   * property is assigned by Authlete.
   *
   * Note that Authlete issues a client secret even to a "public" client application, but the client
   * application should not use the client secret unless it changes its client type to "confidential".
   * That is, a public client application should behave as if it had not been issued a client secret.
   * To be specific, a token request from a public client of Authlete should not come along with a
   * client secret although [RFC 6749, 3.2.1. Client Authentication](https://datatracker.ietf.org/doc/html/rfc6749#section-3.2.1)
   * says as follows.
   *
   * > Confidential clients or other clients issued client credentials MUST authenticate with the
   * authorization server as described in Section 2.3 when making requests to the token endpoint.
   */
  clientSecret?: string | undefined;
  /**
   * The value of the client's `client_id` property used in OAuth and OpenID Connect calls. By
   *
   * @remarks
   * default, this is a string version of the `clientId` property.
   */
  clientIdAlias?: string | undefined;
  /**
   * Deprecated. Always set to `true`.
   */
  clientIdAliasEnabled?: boolean | undefined;
  /**
   * The client type, either `CONFIDENTIAL` or `PUBLIC`. See [RFC 6749, 2.1. Client Types](https://datatracker.ietf.org/doc/html/rfc6749#section-2.1)
   *
   * @remarks
   * for details.
   */
  clientType?: ClientUpdateApiClientTypeResponse | undefined;
  /**
   * The application type. The value of this property affects the validation steps for a redirect URI.
   *
   * @remarks
   * See the description about `redirectUris` property for more details.
   */
  applicationType?: ClientUpdateApiApplicationTypeResponse | undefined;
  /**
   * The URL pointing to the logo image of the client application.
   *
   * @remarks
   *
   * This property corresponds to `logo_uri` in [OpenID Connect Dynamic Client Registration 1.0, 2.
   * Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  logoUri?: string | undefined;
  /**
   * Logo image URLs with language tags. If the client application has different logo images for
   *
   * @remarks
   * different languages, this property can be used to register URLs of the images.
   */
  logoUris?: Array<ClientUpdateApiLogoUrisResponse> | undefined;
  /**
   * An array of email addresses of people responsible for the client application.
   *
   * @remarks
   *
   * This property corresponds to contacts in [OpenID Connect Dynamic Client Registration 1.0, 2. Client
   * Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  contacts?: Array<string> | undefined;
  /**
   * The flag to indicate whether this client use TLS client certificate bound access tokens.
   *
   * @remarks
   */
  tlsClientCertificateBoundAccessTokens?: boolean | undefined;
  /**
   * The flag to indicate whether this client has been registered dynamically.
   *
   * @remarks
   * For more details, see [RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591).
   */
  dynamicallyRegistered?: boolean | undefined;
  /**
   * The unique identifier string assigned by the client developer or software publisher used by
   *
   * @remarks
   * registration endpoints to identify the client software to be dynamically registered.
   *
   * This property corresponds to the `software_id metadata` defined in [2. Client Metadata](https://datatracker.ietf.org/doc/html/rfc7591#section-2)
   * of [RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591).
   */
  softwareId?: string | undefined;
  /**
   * The version identifier string for the client software identified by the software ID.
   *
   * @remarks
   *
   * This property corresponds to the software_version metadata defined in [2. Client Metadata](https://datatracker.ietf.org/doc/html/rfc7591#section-2)
   * of [RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591).
   */
  softwareVersion?: string | undefined;
  /**
   * The hash of the registration access token for this client.
   *
   * @remarks
   */
  registrationAccessTokenHash?: string | undefined;
  /**
   * The time at which this client was created. The value is represented as milliseconds since the UNIX epoch (1970-01-01).
   */
  createdAt?: number | undefined;
  /**
   * The time at which this client was last modified. The value is represented as milliseconds since the UNIX epoch (1970-01-01).
   */
  modifiedAt?: number | undefined;
  /**
   * A string array of grant types which the client application declares that it will restrict itself to using.
   *
   * @remarks
   * This property corresponds to `grant_types` in [OpenID Connect Dynamic Client Registration 1.0,
   * 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  grantTypes?: Array<ClientUpdateApiGrantTypeResponse> | undefined;
  /**
   * A string array of response types which the client application declares that it will restrict itself to using.
   *
   * @remarks
   * This property corresponds to `response_types` in [OpenID Connect Dynamic Client Registration 1.0,
   * 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  responseTypes?: Array<ClientUpdateApiResponseTypeResponse> | undefined;
  /**
   * Redirect URIs that the client application uses to receive a response from the authorization endpoint.
   *
   * @remarks
   * Requirements for a redirect URI are as follows.
   *
   * **Requirements by RFC 6749** (From [RFC 6749, 3.1.2. Redirection Endpoint](https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2))
   *
   * - Must be an absolute URI.
   * - Must not have a fragment component.
   *
   * **Requirements by OpenID Connect** (From "[OpenID Connect Dynamic Client Registration 1.0, 2.
   * Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata),
   * application_type")
   *
   * - The scheme of the redirect URI used for Implicit Grant by a client application whose application
   * is `web` must be `https`. This is checked at runtime by Authlete.
   * - The hostname of the redirect URI used for Implicit Grant by a client application whose application
   * type is `web` must not be `localhost`. This is checked at runtime by Authlete.
   * - The scheme of the redirect URI used by a client application whose application type is `native`
   * must be either (1) a custom scheme or (2) `http`, which is allowed only when the hostname part
   * is `localhost`. This is checked at runtime by Authlete.
   *
   * **Requirements by Authlete**
   *
   * - Must consist of printable ASCII letters only.
   * - Must not exceed 200 letters.
   *
   * Note that Authlete allows the application type to be `null`. In other words, a client application
   * does not have to choose `web` or `native` as its application type.
   * If the application type is `null`, the requirements by OpenID Connect are not checked at runtime.
   *
   * An authorization request from a client application which has not registered any redirect URI
   * fails unless at least all the following conditions are satisfied.
   *
   * - The client type of the client application is `confidential`.
   * - The value of `response_type` request parameter is `code`.
   * - The authorization request has the `redirect_uri` request parameter.
   * - The value of `scope` request parameter does not contain `openid`.
   *
   * RFC 6749 allows partial match of redirect URI under some conditions (see [RFC 6749, 3.1.2.2.
   * Registration Requirements](https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2.2) for
   * details), but OpenID Connect requires exact match.
   */
  redirectUris?: Array<string> | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  authorizationSignAlg?:
    | ClientUpdateApiAuthorizationSignAlgResponse
    | undefined;
  /**
   * this is the 'alg' header value for encrypted JWT tokens.
   *
   * @remarks
   * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
   * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
   * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
   * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
   *
   * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
   */
  authorizationEncryptionAlg?:
    | ClientUpdateApiAuthorizationEncryptionAlgResponse
    | undefined;
  /**
   * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
   *
   * @remarks
   * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
   *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
   *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
   *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
   */
  authorizationEncryptionEnc?:
    | ClientUpdateApiAuthorizationEncryptionEncResponse
    | undefined;
  /**
   * The client authentication method that the client application declares that it uses at the token
   *
   * @remarks
   * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
   * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  tokenAuthMethod?: ClientUpdateApiTokenAuthMethodResponse | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  tokenAuthSignAlg?: ClientUpdateApiTokenAuthSignAlgResponse | undefined;
  /**
   * The key ID of a JWK containing a self-signed certificate of this client.
   *
   * @remarks
   */
  selfSignedCertificateKeyId?: string | undefined;
  /**
   * The string representation of the expected subject distinguished name of the certificate this
   *
   * @remarks
   * client will use in mutual TLS authentication.
   *
   * See `tls_client_auth_subject_dn` in "Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client
   * Registration" for details.
   */
  tlsClientAuthSubjectDn?: string | undefined;
  /**
   * The string representation of the expected DNS subject alternative name of the certificate this
   *
   * @remarks
   * client will use in mutual TLS authentication.
   *
   * See `tls_client_auth_san_dns` in "Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client
   * Registration" for details.
   */
  tlsClientAuthSanDns?: string | undefined;
  /**
   * The string representation of the expected URI subject alternative name of the certificate this
   *
   * @remarks
   * client will use in mutual TLS authentication.
   *
   * See `tls_client_auth_san_uri` in "Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client
   * Registration" for details.
   */
  tlsClientAuthSanUri?: string | undefined;
  /**
   * The string representation of the expected IP address subject alternative name of the certificate
   *
   * @remarks
   * this client will use in mutual TLS authentication.
   *
   * See `tls_client_auth_san_ip` in "Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client
   * Registration" for details.
   */
  tlsClientAuthSanIp?: string | undefined;
  /**
   * The string representation of the expected email address subject alternative name of the certificate
   *
   * @remarks
   * this client will use in mutual TLS authentication.
   *
   * See `tls_client_auth_san_email` in "Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client
   * Registration" for details.
   */
  tlsClientAuthSanEmail?: string | undefined;
  /**
   * The flag to indicate whether this client is required to use the pushed authorization request endpoint.
   *
   * @remarks
   * This property corresponds to the `require_pushed_authorization_requests` client metadata defined
   * in "OAuth 2.0 Pushed Authorization Requests".
   */
  parRequired?: boolean | undefined;
  /**
   * The flag to indicate whether authorization requests from this client are always required to
   *
   * @remarks
   * utilize a request object by using either `request` or `request_uri` request parameter.
   *
   * If this flag is set to `true` and the service's `traditionalRequestObjectProcessingApplied` is
   * set to `false`, authorization requests from this client are processed as if `require_signed_request_object`
   * client metadata of this client is `true`. The metadata is defined in "JAR (JWT Secured Authorization Request)".
   */
  requestObjectRequired?: boolean | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  requestSignAlg?: ClientUpdateApiRequestSignAlgResponse | undefined;
  /**
   * this is the 'alg' header value for encrypted JWT tokens.
   *
   * @remarks
   * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
   * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
   * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
   * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
   *
   * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
   */
  requestEncryptionAlg?:
    | ClientUpdateApiRequestEncryptionAlgResponse
    | undefined;
  /**
   * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
   *
   * @remarks
   * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
   *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
   *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
   *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
   */
  requestEncryptionEnc?:
    | ClientUpdateApiRequestEncryptionEncResponse
    | undefined;
  /**
   * An array of URLs each of which points to a request object.
   *
   * @remarks
   *
   * Authlete requires that URLs used as values for `request_uri` request parameter be pre-registered.
   * This property is used for the pre-registration.
   * See [OpenID Connect Core 1.0, 6.2. Passing a Request Object by Reference](https://openid.net/specs/openid-connect-core-1_0.html#RequestUriParameter) for details.
   */
  requestUris?: Array<string> | undefined;
  /**
   * The default maximum authentication age in seconds. This value is used when an authorization request from the client application does not have `max_age` request parameter.
   *
   * @remarks
   *
   * This property corresponds to `default_max_age` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  defaultMaxAge?: number | undefined;
  /**
   * The default ACRs (Authentication Context Class References). This value is used when an authorization
   *
   * @remarks
   * request from the client application has neither `acr_values` request parameter nor `acr` claim
   * in claims request parameter.
   */
  defaultAcrs?: Array<string> | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  idTokenSignAlg?: ClientUpdateApiIdTokenSignAlgResponse | undefined;
  /**
   * this is the 'alg' header value for encrypted JWT tokens.
   *
   * @remarks
   * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
   * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
   * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
   * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
   *
   * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
   */
  idTokenEncryptionAlg?:
    | ClientUpdateApiIdTokenEncryptionAlgResponse
    | undefined;
  /**
   * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
   *
   * @remarks
   * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
   *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
   *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
   *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
   */
  idTokenEncryptionEnc?:
    | ClientUpdateApiIdTokenEncryptionEncResponse
    | undefined;
  /**
   * The flag to indicate whether this client requires `auth_time` claim to be embedded in the ID token.
   *
   * @remarks
   *
   * This property corresponds to `require_auth_time` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  authTimeRequired?: boolean | undefined;
  /**
   * The subject type that the client application requests. Details about the subject type are described in
   *
   * @remarks
   * [OpenID Connect Core 1.0, 8. Subjct Identifier Types](https://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes).
   *
   * This property corresponds to `subject_type` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  subjectType?: ClientUpdateApiSubjectTypeResponse | undefined;
  /**
   * The value of the sector identifier URI.
   *
   * @remarks
   * This represents the `sector_identifier_uri` client metadata which is defined in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata)
   */
  sectorIdentifierUri?: string | undefined;
  /**
   * The sector identifier host component as derived from either the `sector_identifier_uri` or the
   *
   * @remarks
   * registered redirect URI. If no `sector_identifier_uri` is registered and multiple redirect URIs
   * are also registered, the value of this property is `null`.
   */
  derivedSectorIdentifier?: string | undefined;
  /**
   * The URL pointing to the JWK Set of the client application.
   *
   * @remarks
   * The content pointed to by the URL is JSON which complies with the format described in
   * [JSON Web Key (JWK), 5. JWK Set Format](https://datatracker.ietf.org/doc/html/rfc7517#section-5).
   * The JWK Set must not include private keys of the client application.
   *
   * If the client application requests encryption for ID tokens (from the authorization/token/userinfo endpoints)
   * and/or signs request objects, it must make available its JWK Set containing public keys for the
   * encryption and/or the signature at the URL of `jwksUri`. The service (Authlete) fetches the JWK
   * Set from the URL as necessary.
   *
   * [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
   * says that `jwks` must not be used when the client can use `jwks_uri`, but Authlete allows both
   * properties to be registered at the same time. However, Authlete does not use the content of `jwks`
   * when `jwksUri` is registered.
   *
   * This property corresponds to `jwks_uri` in [OpenID Connect Dynamic Client Registration 1.0, 2.
   * Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  jwksUri?: string | undefined;
  /**
   * The content of the JWK Set of the client application.
   *
   * @remarks
   * The format is described in
   * [JSON Web Key (JWK), 5. JWK Set Format](https://datatracker.ietf.org/doc/html/rfc7517#section-5).
   * The JWK Set must not include private keys of the client application.
   *
   * [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
   * says that `jwks` must not be used when the client can use `jwks_uri`, but Authlete allows both
   * properties to be registered at the same time. However, Authlete does not use the content of `jwks`
   * when `jwksUri` is registered.
   *
   * This property corresponds to `jwks_uri` in [OpenID Connect Dynamic Client Registration 1.0, 2.
   * Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  jwks?: string | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  userInfoSignAlg?: ClientUpdateApiUserInfoSignAlgResponse | undefined;
  /**
   * this is the 'alg' header value for encrypted JWT tokens.
   *
   * @remarks
   * Depending upon the context, this refers to key transport scheme to be used by the client and by the server. For instance:
   * - as `authorizationEncryptionAlg` value, it refers to the encoding algorithm used by server for transporting they keys on JARM objects
   * - as `requestEncryptionAlg` value, it refers to the expected key transport encoding algorithm that server expect from client when encrypting a Request Object
   * - as `idTokenEncryptionAlg` value, it refers to the algorithm used by the server to key transport of id_tokens
   *
   * **Please note that some of the algorithms are more secure than others, some are not supported very well cross platforms and some (like RSA1_5) is known to be weak**.
   */
  userInfoEncryptionAlg?:
    | ClientUpdateApiUserInfoEncryptionAlgResponse
    | undefined;
  /**
   * This is the encryption algorithm to be used when encrypting a JWT on client or server side.
   *
   * @remarks
   * Depending upon the context, this refers to encryption done by the client or by the server. For instance:
   *   - as `authorizationEncryptionEnc` value, it refers to the encryption algorithm used by server when creating a JARM response
   *   - as `requestEncryptionEnc` value, it refers to the expected encryption algorithm used by the client when encrypting a Request Object
   *   - as `idTokenEncryptionEnc` value, it refers to the algorithm used by the server to encrypt id_tokens
   */
  userInfoEncryptionEnc?:
    | ClientUpdateApiUserInfoEncryptionEncResponse
    | undefined;
  /**
   * The URL which a third party can use to initiate a login by the client application.
   *
   * @remarks
   *
   * This property corresponds to `initiate_login_uri` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  loginUri?: string | undefined;
  /**
   * The URL pointing to the "Terms Of Service" page.
   *
   * @remarks
   *
   * This property corresponds to `tos_uri` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  tosUri?: string | undefined;
  /**
   * URLs of "Terms Of Service" pages with language tags.
   *
   * @remarks
   *
   * If the client application has different "Terms Of Service" pages for different languages,
   * this property can be used to register the URLs.
   */
  tosUris?: Array<ClientUpdateApiTosUrisResponse> | undefined;
  /**
   * The URL pointing to the page which describes the policy as to how end-user's profile data is used.
   *
   * @remarks
   *
   * This property corresponds to `policy_uri` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  policyUri?: string | undefined;
  /**
   * URLs of policy pages with language tags.
   *
   * @remarks
   * If the client application has different policy pages for different languages, this property can be used to register the URLs.
   */
  policyUris?: Array<ClientUpdateApiPolicyUrisResponse> | undefined;
  /**
   * The URL pointing to the home page of the client application.
   *
   * @remarks
   *
   * This property corresponds to `client_uri` in
   * [OpenID Connect Dynamic Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
   */
  clientUri?: string | undefined;
  /**
   * Home page URLs with language tags.
   *
   * @remarks
   * If the client application has different home pages for different languages, this property can
   * be used to register the URLs.
   */
  clientUris?: Array<ClientUpdateApiClientUrisResponse> | undefined;
  /**
   * The backchannel token delivery mode.
   *
   * @remarks
   *
   * This property corresponds to the `backchannel_token_delivery_mode` metadata.
   * The backchannel token delivery mode is defined in the specification of "CIBA (Client Initiated
   * Backchannel Authentication)".
   */
  bcDeliveryMode?: string | undefined;
  /**
   * The backchannel client notification endpoint.
   *
   * @remarks
   *
   * This property corresponds to the `backchannel_client_notification_endpoint` metadata.
   * The backchannel token delivery mode is defined in the specification of "CIBA (Client Initiated
   * Backchannel Authentication)".
   */
  bcNotificationEndpoint?: string | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  bcRequestSignAlg?: ClientUpdateApiBcRequestSignAlgResponse | undefined;
  /**
   * The boolean flag to indicate whether a user code is required when this client makes a backchannel
   *
   * @remarks
   * authentication request.
   *
   * This property corresponds to the `backchannel_user_code_parameter` metadata.
   */
  bcUserCodeRequired?: boolean | undefined;
  /**
   * The attributes of this client.
   *
   * @remarks
   */
  attributes?: Array<ClientUpdateApiAttributeResponse> | undefined;
  extension?: ClientUpdateApiExtensionResponse | undefined;
  /**
   * The authorization details types that this client may use as values of the `type` field in
   *
   * @remarks
   * `authorization_details`.
   *
   * This property corresponds to the `authorization_details_types` metadata. See [OAuth 2.0 Rich
   * Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/) for details.
   *
   * Note that the property name was renamed from authorizationDataTypes to authorizationDetailsTypes
   * to align with the change made by the 5th draft of the RAR specification.
   */
  authorizationDetailsTypes?: Array<string> | undefined;
  /**
   * The custom client metadata in JSON format.
   *
   * @remarks
   *
   * Standard specifications define client metadata as necessary. The following are such examples.
   *
   * * [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
   * * [RFC 7591 OAuth 2.0 Dynamic Client Registration Protocol](https://www.rfc-editor.org/rfc/rfc7591.html)
   * * [RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens](https://www.rfc-editor.org/rfc/rfc8705.html)
   * * [OpenID Connect Client-Initiated Backchannel Authentication Flow - Core 1.0](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html)
   * * [The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-jwsreq/)
   * * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
   * * [OAuth 2.0 Pushed Authorization Requests (PAR)](https://datatracker.ietf.org/doc/rfc9126/)
   * * [OAuth 2.0 Rich Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/)
   *
   * Standard client metadata included in Client Registration Request and Client Update Request (cf.
   * [OIDC DynReg](https://openid.net/specs/openid-connect-registration-1_0.html), [RFC 7591](https://www.rfc-editor.org/rfc/rfc7591.html)
   * and [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)) are, if supported by Authlete, set
   * to corresponding properties of the client application. For example, the value of the `client_name`
   * client metadata in Client Registration/Update Request is set to the clientName property. On the
   * other hand, unrecognized client metadata are discarded.
   *
   * By listing up custom client metadata in advance by using the `supportedCustomClientMetadata` property
   * of Service, Authlete can recognize them and stores their values into the database. The stored
   * custom client metadata values can be referenced by this property.
   */
  customMetadata?: string | undefined;
  /**
   * The flag indicating whether encryption of request object is required when the request object
   *
   * @remarks
   * is passed through the front channel.
   *
   * This flag does not affect the processing of request objects at the Pushed Authorization Request
   * Endpoint, which is defined in [OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/).
   * Unecrypted request objects are accepted at the endpoint even if this flag is `true`.
   *
   * This flag does not indicate whether a request object is always required. There is a different
   * flag, `requestObjectRequired`, for the purpose.
   *
   * Even if this flag is `false`, encryption of request object is required if the `frontChannelRequestObjectEncryptionRequired`
   * flag of the service is `true`.
   */
  frontChannelRequestObjectEncryptionRequired?: boolean | undefined;
  /**
   * The flag indicating whether the JWE alg of encrypted request object must match the `request_object_encryption_alg`
   *
   * @remarks
   * client metadata.
   *
   * The `request_object_encryption_alg` client metadata itself is defined in [OpenID Connect Dynamic
   * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
   *
   * > request_object_encryption_alg
   * >
   * > OPTIONAL. JWE [JWE] alg algorithm [JWA] the RP is declaring that it may use for encrypting Request
   *   Objects sent to the OP. This parameter SHOULD be included when symmetric encryption will be used,
   *   since this signals to the OP that a client_secret value needs to be returned from which the
   *   symmetric key will be derived, that might not otherwise be returned. The RP MAY still use other
   *   supported encryption algorithms or send unencrypted Request Objects, even when this parameter
   *   is present. If both signing and encryption are requested, the Request Object will be signed
   *   then encrypted, with the result being a Nested JWT, as defined in [JWT]. The default, if omitted,
   *   is that the RP is not declaring whether it might encrypt any Request Objects.
   *
   * The point here is "The RP MAY still use other supported encryption algorithms or send unencrypted
   * Request Objects, even when this parameter is present."
   *
   * The property that represents the client metadata is `requestEncryptionAlg`. See the description
   * of `requestEncryptionAlg` for details.
   *
   * Even if this flag is `false`, the match is required if the `requestObjectEncryptionAlgMatchRequired`
   * flag of the service is `true`.
   */
  requestObjectEncryptionAlgMatchRequired?: boolean | undefined;
  /**
   * The flag indicating whether the JWE enc of encrypted request object must match the `request_object_encryption_enc`
   *
   * @remarks
   * client metadata.
   *
   * The `request_object_encryption_enc` client metadata itself is defined in [OpenID Connect Dynamic
   * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
   *
   * > request_object_encryption_enc
   * >
   * > OPTIONAL. JWE enc algorithm [JWA] the RP is declaring that it may use for encrypting Request
   *   Objects sent to the OP. If request_object_encryption_alg is specified, the default for this
   *   value is A128CBC-HS256. When request_object_encryption_enc is included, request_object_encryption_alg
   *   MUST also be provided.
   *
   * The property that represents the client metadata is `requestEncryptionEnc`. See the description
   * of `requestEncryptionEnc`  for details.
   *
   * Even if this flag is `false`, the match is required if the `requestObjectEncryptionEncMatchRequired`
   * flag of the service is `true`.
   */
  requestObjectEncryptionEncMatchRequired?: boolean | undefined;
  /**
   * The digest algorithm that this client requests the server to use
   *
   * @remarks
   * when it computes digest values of <a href=
   * "https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#name-external-attachments"
   * >external attachments</a>, which may be referenced from within ID tokens
   * or userinfo responses (or any place that can have the `verified_claims` claim).
   *
   * Possible values are listed in the <a href=
   * "https://www.iana.org/assignments/named-information/named-information.xhtml#hash-alg"
   * >Hash Algorithm Registry</a> of IANA (Internet Assigned Numbers Authority),
   * but the server does not necessarily support all the values there. When
   * this property is omitted, `sha-256` is used as the default algorithm.
   *
   * This property corresponds to the `digest_algorithm` client metadata
   * which was defined by the third implementer's draft of
   * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html).
   */
  digestAlgorithm?: string | undefined;
  /**
   * If `Enabled` is selected, an attempt to issue a new access token invalidates existing access tokens that are associated with the same combination of subject and client.
   *
   * @remarks
   *
   * Note that, however, attempts by Client Credentials Flow do not invalidate existing access tokens because access tokens issued by Client Credentials Flow are not associated with any end-user's subject.
   *
   * Even if `Disabled` is selected here, single access token per subject is effective if `singleAccessTokenPerSubject` of the `Service` this client belongs to is Enabled.
   */
  singleAccessTokenPerSubject?: boolean | undefined;
  /**
   * The flag to indicate whether the use of Proof Key for Code Exchange (PKCE) is always required for authorization requests by Authorization Code Flow.
   *
   * @remarks
   *
   * If `true`, `code_challenge` request parameter is always required for authorization requests using Authorization Code Flow.
   *
   * See [RFC 7636](https://tools.ietf.org/html/rfc7636) (Proof Key for Code Exchange by OAuth Public Clients) for details about `code_challenge` request parameter.
   */
  pkceRequired?: boolean | undefined;
  /**
   * The flag to indicate whether `S256` is always required as the code challenge method whenever [PKCE (RFC 7636)](https://tools.ietf.org/html/rfc7636) is used.
   *
   * @remarks
   *
   * If this flag is set to `true`, `code_challenge_method=S256` must be included in the authorization request
   * whenever it includes the `code_challenge` request parameter.
   * Neither omission of the `code_challenge_method` request parameter nor use of plain (`code_challenge_method=plain`) is allowed.
   */
  pkceS256Required?: boolean | undefined;
  /**
   * If the DPoP is required for this client
   *
   * @remarks
   */
  dpopRequired?: boolean | undefined;
  /**
   * The flag indicating whether this client was registered by the
   *
   * @remarks
   * "automatic" client registration of OIDC Federation.
   */
  automaticallyRegistered?: boolean | undefined;
  /**
   * The flag indicating whether this client was registered by the
   *
   * @remarks
   * "explicit" client registration of OIDC Federation.
   */
  explicitlyRegistered?: boolean | undefined;
  /**
   * The flag indicating whether this service signs responses from the resource server.
   *
   * @remarks
   */
  rsRequestSigned?: boolean | undefined;
  /**
   * The key ID of a JWK containing the public key used by this client to sign requests to the resource server.
   *
   * @remarks
   */
  rsSignedRequestKeyId?: string | undefined;
  /**
   * The client registration types that the client has declared it may use.
   *
   * @remarks
   */
  clientRegistrationTypes?:
    | Array<ClientUpdateApiClientRegistrationTypeResponse>
    | undefined;
  /**
   * The human-readable name representing the organization that manages this client. This property corresponds
   *
   * @remarks
   * to the organization_name client metadata that is defined in OpenID Connect Federation 1.0.
   */
  organizationName?: string | undefined;
  /**
   * The URI of the endpoint that returns this client's JWK Set document in the JWT format. This property
   *
   * @remarks
   * corresponds to the `signed_jwks_uri` client metadata defined in OpenID Connect Federation 1.0.
   */
  signedJwksUri?: string | undefined;
  /**
   * the entity ID of this client.
   *
   * @remarks
   */
  entityId?: string | undefined;
  /**
   * The entity ID of the trust anchor of the trust chain that was used when this client was registered or updated by
   *
   * @remarks
   * the mechanism defined in OpenID Connect Federation 1.0
   */
  trustAnchorId?: string | undefined;
  /**
   * The trust chain that was used when this client was registered or updated by the mechanism defined in
   *
   * @remarks
   * OpenID Connect Federation 1.0
   */
  trustChain?: Array<string> | undefined;
  /**
   * the expiration time of the trust chain that was used when this client was registered or updated by the mechanism
   *
   * @remarks
   * defined in OpenID Connect Federation 1.0. The value is represented as milliseconds elapsed since the Unix epoch (1970-01-01).
   */
  trustChainExpiresAt?: number | undefined;
  /**
   * the time at which the trust chain was updated by the mechanism defined in OpenID Connect Federation 1.0
   *
   * @remarks
   */
  trustChainUpdatedAt?: number | undefined;
  /**
   * The flag which indicates whether this client is locked.
   *
   * @remarks
   */
  locked?: boolean | undefined;
  /**
   * The URL of the credential offer endpoint at which this client
   *
   * @remarks
   * (wallet) receives a credential offer from the credential issuer.
   */
  credentialOfferEndpoint?: string | undefined;
  /**
   * The FAPI modes for this client.
   *
   * @remarks
   *
   * When the value of this property is not `null`, Authlete always processes requests from this client
   * based on the specified FAPI modes if the FAPI feature is enabled in Authlete, the FAPI profile
   * is supported by the service, and the FAPI modes for the service are set to `null`.
   *
   * For instance, when this property is set to an array containing `FAPI1_ADVANCED` only, Authlete
   * always processes requests from this client based on "Financial-grade API Security Profile 1.0 -
   * Part 2: Advanced" if the FAPI feature is enabled in Authlete, the FAPI profile is supported by
   * the service, and the FAPI modes for the service are set to `null`.
   */
  fapiModes?: Array<ClientUpdateApiFapiModeResponse> | undefined;
  /**
   * The response modes that this client may use.
   */
  responseModes?: Array<ClientUpdateApiResponseModeResponse> | undefined;
  /**
   * True if credential responses to this client must be always encrypted.
   */
  credentialResponseEncryptionRequired?: boolean | undefined;
};

/** @internal */
export const ClientUpdateApiClientNameRequest$inboundSchema: z.ZodType<
  ClientUpdateApiClientNameRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiClientNameRequest$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiClientNameRequest$outboundSchema: z.ZodType<
  ClientUpdateApiClientNameRequest$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiClientNameRequest
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiClientNameRequest$ {
  /** @deprecated use `ClientUpdateApiClientNameRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiClientNameRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiClientNameRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiClientNameRequest$outboundSchema;
  /** @deprecated use `ClientUpdateApiClientNameRequest$Outbound` instead. */
  export type Outbound = ClientUpdateApiClientNameRequest$Outbound;
}

export function clientUpdateApiClientNameRequestToJSON(
  clientUpdateApiClientNameRequest: ClientUpdateApiClientNameRequest,
): string {
  return JSON.stringify(
    ClientUpdateApiClientNameRequest$outboundSchema.parse(
      clientUpdateApiClientNameRequest,
    ),
  );
}

export function clientUpdateApiClientNameRequestFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiClientNameRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiClientNameRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiClientNameRequest' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiDescriptionRequest$inboundSchema: z.ZodType<
  ClientUpdateApiDescriptionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiDescriptionRequest$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiDescriptionRequest$outboundSchema: z.ZodType<
  ClientUpdateApiDescriptionRequest$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiDescriptionRequest
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiDescriptionRequest$ {
  /** @deprecated use `ClientUpdateApiDescriptionRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiDescriptionRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiDescriptionRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiDescriptionRequest$outboundSchema;
  /** @deprecated use `ClientUpdateApiDescriptionRequest$Outbound` instead. */
  export type Outbound = ClientUpdateApiDescriptionRequest$Outbound;
}

export function clientUpdateApiDescriptionRequestToJSON(
  clientUpdateApiDescriptionRequest: ClientUpdateApiDescriptionRequest,
): string {
  return JSON.stringify(
    ClientUpdateApiDescriptionRequest$outboundSchema.parse(
      clientUpdateApiDescriptionRequest,
    ),
  );
}

export function clientUpdateApiDescriptionRequestFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiDescriptionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiDescriptionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiDescriptionRequest' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiClientTypeRequest$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiClientTypeRequest
> = z.nativeEnum(ClientUpdateApiClientTypeRequest);

/** @internal */
export const ClientUpdateApiClientTypeRequest$outboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiClientTypeRequest
> = ClientUpdateApiClientTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiClientTypeRequest$ {
  /** @deprecated use `ClientUpdateApiClientTypeRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiClientTypeRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiClientTypeRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiClientTypeRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiApplicationTypeRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiApplicationTypeRequest> = z.nativeEnum(
    ClientUpdateApiApplicationTypeRequest,
  );

/** @internal */
export const ClientUpdateApiApplicationTypeRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiApplicationTypeRequest> =
    ClientUpdateApiApplicationTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiApplicationTypeRequest$ {
  /** @deprecated use `ClientUpdateApiApplicationTypeRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiApplicationTypeRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiApplicationTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiApplicationTypeRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiLogoUrisRequest$inboundSchema: z.ZodType<
  ClientUpdateApiLogoUrisRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiLogoUrisRequest$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiLogoUrisRequest$outboundSchema: z.ZodType<
  ClientUpdateApiLogoUrisRequest$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiLogoUrisRequest
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiLogoUrisRequest$ {
  /** @deprecated use `ClientUpdateApiLogoUrisRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiLogoUrisRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiLogoUrisRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiLogoUrisRequest$outboundSchema;
  /** @deprecated use `ClientUpdateApiLogoUrisRequest$Outbound` instead. */
  export type Outbound = ClientUpdateApiLogoUrisRequest$Outbound;
}

export function clientUpdateApiLogoUrisRequestToJSON(
  clientUpdateApiLogoUrisRequest: ClientUpdateApiLogoUrisRequest,
): string {
  return JSON.stringify(
    ClientUpdateApiLogoUrisRequest$outboundSchema.parse(
      clientUpdateApiLogoUrisRequest,
    ),
  );
}

export function clientUpdateApiLogoUrisRequestFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiLogoUrisRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiLogoUrisRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiLogoUrisRequest' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiGrantTypeRequest$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiGrantTypeRequest
> = z.nativeEnum(ClientUpdateApiGrantTypeRequest);

/** @internal */
export const ClientUpdateApiGrantTypeRequest$outboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiGrantTypeRequest
> = ClientUpdateApiGrantTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiGrantTypeRequest$ {
  /** @deprecated use `ClientUpdateApiGrantTypeRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiGrantTypeRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiGrantTypeRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiGrantTypeRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiResponseTypeRequest$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiResponseTypeRequest
> = z.nativeEnum(ClientUpdateApiResponseTypeRequest);

/** @internal */
export const ClientUpdateApiResponseTypeRequest$outboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiResponseTypeRequest
> = ClientUpdateApiResponseTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiResponseTypeRequest$ {
  /** @deprecated use `ClientUpdateApiResponseTypeRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiResponseTypeRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiResponseTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiResponseTypeRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiAuthorizationSignAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationSignAlgRequest> = z
    .nativeEnum(ClientUpdateApiAuthorizationSignAlgRequest);

/** @internal */
export const ClientUpdateApiAuthorizationSignAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationSignAlgRequest> =
    ClientUpdateApiAuthorizationSignAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiAuthorizationSignAlgRequest$ {
  /** @deprecated use `ClientUpdateApiAuthorizationSignAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiAuthorizationSignAlgRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiAuthorizationSignAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiAuthorizationSignAlgRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiAuthorizationEncryptionAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationEncryptionAlgRequest> = z
    .nativeEnum(ClientUpdateApiAuthorizationEncryptionAlgRequest);

/** @internal */
export const ClientUpdateApiAuthorizationEncryptionAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationEncryptionAlgRequest> =
    ClientUpdateApiAuthorizationEncryptionAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiAuthorizationEncryptionAlgRequest$ {
  /** @deprecated use `ClientUpdateApiAuthorizationEncryptionAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiAuthorizationEncryptionAlgRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiAuthorizationEncryptionAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiAuthorizationEncryptionAlgRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiAuthorizationEncryptionEncRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationEncryptionEncRequest> = z
    .nativeEnum(ClientUpdateApiAuthorizationEncryptionEncRequest);

/** @internal */
export const ClientUpdateApiAuthorizationEncryptionEncRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationEncryptionEncRequest> =
    ClientUpdateApiAuthorizationEncryptionEncRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiAuthorizationEncryptionEncRequest$ {
  /** @deprecated use `ClientUpdateApiAuthorizationEncryptionEncRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiAuthorizationEncryptionEncRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiAuthorizationEncryptionEncRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiAuthorizationEncryptionEncRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiTokenAuthMethodRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiTokenAuthMethodRequest> = z.nativeEnum(
    ClientUpdateApiTokenAuthMethodRequest,
  );

/** @internal */
export const ClientUpdateApiTokenAuthMethodRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiTokenAuthMethodRequest> =
    ClientUpdateApiTokenAuthMethodRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiTokenAuthMethodRequest$ {
  /** @deprecated use `ClientUpdateApiTokenAuthMethodRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiTokenAuthMethodRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiTokenAuthMethodRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiTokenAuthMethodRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiTokenAuthSignAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiTokenAuthSignAlgRequest> = z.nativeEnum(
    ClientUpdateApiTokenAuthSignAlgRequest,
  );

/** @internal */
export const ClientUpdateApiTokenAuthSignAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiTokenAuthSignAlgRequest> =
    ClientUpdateApiTokenAuthSignAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiTokenAuthSignAlgRequest$ {
  /** @deprecated use `ClientUpdateApiTokenAuthSignAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiTokenAuthSignAlgRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiTokenAuthSignAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiTokenAuthSignAlgRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiRequestSignAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestSignAlgRequest> = z.nativeEnum(
    ClientUpdateApiRequestSignAlgRequest,
  );

/** @internal */
export const ClientUpdateApiRequestSignAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestSignAlgRequest> =
    ClientUpdateApiRequestSignAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiRequestSignAlgRequest$ {
  /** @deprecated use `ClientUpdateApiRequestSignAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiRequestSignAlgRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiRequestSignAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiRequestSignAlgRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiRequestEncryptionAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestEncryptionAlgRequest> = z
    .nativeEnum(ClientUpdateApiRequestEncryptionAlgRequest);

/** @internal */
export const ClientUpdateApiRequestEncryptionAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestEncryptionAlgRequest> =
    ClientUpdateApiRequestEncryptionAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiRequestEncryptionAlgRequest$ {
  /** @deprecated use `ClientUpdateApiRequestEncryptionAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiRequestEncryptionAlgRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiRequestEncryptionAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiRequestEncryptionAlgRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiRequestEncryptionEncRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestEncryptionEncRequest> = z
    .nativeEnum(ClientUpdateApiRequestEncryptionEncRequest);

/** @internal */
export const ClientUpdateApiRequestEncryptionEncRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestEncryptionEncRequest> =
    ClientUpdateApiRequestEncryptionEncRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiRequestEncryptionEncRequest$ {
  /** @deprecated use `ClientUpdateApiRequestEncryptionEncRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiRequestEncryptionEncRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiRequestEncryptionEncRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiRequestEncryptionEncRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiIdTokenSignAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenSignAlgRequest> = z.nativeEnum(
    ClientUpdateApiIdTokenSignAlgRequest,
  );

/** @internal */
export const ClientUpdateApiIdTokenSignAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenSignAlgRequest> =
    ClientUpdateApiIdTokenSignAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiIdTokenSignAlgRequest$ {
  /** @deprecated use `ClientUpdateApiIdTokenSignAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiIdTokenSignAlgRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiIdTokenSignAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiIdTokenSignAlgRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiIdTokenEncryptionAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenEncryptionAlgRequest> = z
    .nativeEnum(ClientUpdateApiIdTokenEncryptionAlgRequest);

/** @internal */
export const ClientUpdateApiIdTokenEncryptionAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenEncryptionAlgRequest> =
    ClientUpdateApiIdTokenEncryptionAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiIdTokenEncryptionAlgRequest$ {
  /** @deprecated use `ClientUpdateApiIdTokenEncryptionAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiIdTokenEncryptionAlgRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiIdTokenEncryptionAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiIdTokenEncryptionAlgRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiIdTokenEncryptionEncRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenEncryptionEncRequest> = z
    .nativeEnum(ClientUpdateApiIdTokenEncryptionEncRequest);

/** @internal */
export const ClientUpdateApiIdTokenEncryptionEncRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenEncryptionEncRequest> =
    ClientUpdateApiIdTokenEncryptionEncRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiIdTokenEncryptionEncRequest$ {
  /** @deprecated use `ClientUpdateApiIdTokenEncryptionEncRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiIdTokenEncryptionEncRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiIdTokenEncryptionEncRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiIdTokenEncryptionEncRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiSubjectTypeRequest$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiSubjectTypeRequest
> = z.nativeEnum(ClientUpdateApiSubjectTypeRequest);

/** @internal */
export const ClientUpdateApiSubjectTypeRequest$outboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiSubjectTypeRequest
> = ClientUpdateApiSubjectTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiSubjectTypeRequest$ {
  /** @deprecated use `ClientUpdateApiSubjectTypeRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiSubjectTypeRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiSubjectTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiSubjectTypeRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiUserInfoSignAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoSignAlgRequest> = z.nativeEnum(
    ClientUpdateApiUserInfoSignAlgRequest,
  );

/** @internal */
export const ClientUpdateApiUserInfoSignAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoSignAlgRequest> =
    ClientUpdateApiUserInfoSignAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiUserInfoSignAlgRequest$ {
  /** @deprecated use `ClientUpdateApiUserInfoSignAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiUserInfoSignAlgRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiUserInfoSignAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiUserInfoSignAlgRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiUserInfoEncryptionAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoEncryptionAlgRequest> = z
    .nativeEnum(ClientUpdateApiUserInfoEncryptionAlgRequest);

/** @internal */
export const ClientUpdateApiUserInfoEncryptionAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoEncryptionAlgRequest> =
    ClientUpdateApiUserInfoEncryptionAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiUserInfoEncryptionAlgRequest$ {
  /** @deprecated use `ClientUpdateApiUserInfoEncryptionAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiUserInfoEncryptionAlgRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiUserInfoEncryptionAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiUserInfoEncryptionAlgRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiUserInfoEncryptionEncRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoEncryptionEncRequest> = z
    .nativeEnum(ClientUpdateApiUserInfoEncryptionEncRequest);

/** @internal */
export const ClientUpdateApiUserInfoEncryptionEncRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoEncryptionEncRequest> =
    ClientUpdateApiUserInfoEncryptionEncRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiUserInfoEncryptionEncRequest$ {
  /** @deprecated use `ClientUpdateApiUserInfoEncryptionEncRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiUserInfoEncryptionEncRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiUserInfoEncryptionEncRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiUserInfoEncryptionEncRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiTosUrisRequest$inboundSchema: z.ZodType<
  ClientUpdateApiTosUrisRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiTosUrisRequest$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiTosUrisRequest$outboundSchema: z.ZodType<
  ClientUpdateApiTosUrisRequest$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiTosUrisRequest
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiTosUrisRequest$ {
  /** @deprecated use `ClientUpdateApiTosUrisRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiTosUrisRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiTosUrisRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiTosUrisRequest$outboundSchema;
  /** @deprecated use `ClientUpdateApiTosUrisRequest$Outbound` instead. */
  export type Outbound = ClientUpdateApiTosUrisRequest$Outbound;
}

export function clientUpdateApiTosUrisRequestToJSON(
  clientUpdateApiTosUrisRequest: ClientUpdateApiTosUrisRequest,
): string {
  return JSON.stringify(
    ClientUpdateApiTosUrisRequest$outboundSchema.parse(
      clientUpdateApiTosUrisRequest,
    ),
  );
}

export function clientUpdateApiTosUrisRequestFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiTosUrisRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiTosUrisRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiTosUrisRequest' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiPolicyUrisRequest$inboundSchema: z.ZodType<
  ClientUpdateApiPolicyUrisRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiPolicyUrisRequest$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiPolicyUrisRequest$outboundSchema: z.ZodType<
  ClientUpdateApiPolicyUrisRequest$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiPolicyUrisRequest
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiPolicyUrisRequest$ {
  /** @deprecated use `ClientUpdateApiPolicyUrisRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiPolicyUrisRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiPolicyUrisRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiPolicyUrisRequest$outboundSchema;
  /** @deprecated use `ClientUpdateApiPolicyUrisRequest$Outbound` instead. */
  export type Outbound = ClientUpdateApiPolicyUrisRequest$Outbound;
}

export function clientUpdateApiPolicyUrisRequestToJSON(
  clientUpdateApiPolicyUrisRequest: ClientUpdateApiPolicyUrisRequest,
): string {
  return JSON.stringify(
    ClientUpdateApiPolicyUrisRequest$outboundSchema.parse(
      clientUpdateApiPolicyUrisRequest,
    ),
  );
}

export function clientUpdateApiPolicyUrisRequestFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiPolicyUrisRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiPolicyUrisRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiPolicyUrisRequest' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiClientUrisRequest$inboundSchema: z.ZodType<
  ClientUpdateApiClientUrisRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiClientUrisRequest$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiClientUrisRequest$outboundSchema: z.ZodType<
  ClientUpdateApiClientUrisRequest$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiClientUrisRequest
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiClientUrisRequest$ {
  /** @deprecated use `ClientUpdateApiClientUrisRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiClientUrisRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiClientUrisRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiClientUrisRequest$outboundSchema;
  /** @deprecated use `ClientUpdateApiClientUrisRequest$Outbound` instead. */
  export type Outbound = ClientUpdateApiClientUrisRequest$Outbound;
}

export function clientUpdateApiClientUrisRequestToJSON(
  clientUpdateApiClientUrisRequest: ClientUpdateApiClientUrisRequest,
): string {
  return JSON.stringify(
    ClientUpdateApiClientUrisRequest$outboundSchema.parse(
      clientUpdateApiClientUrisRequest,
    ),
  );
}

export function clientUpdateApiClientUrisRequestFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiClientUrisRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiClientUrisRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiClientUrisRequest' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiBcRequestSignAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiBcRequestSignAlgRequest> = z.nativeEnum(
    ClientUpdateApiBcRequestSignAlgRequest,
  );

/** @internal */
export const ClientUpdateApiBcRequestSignAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiBcRequestSignAlgRequest> =
    ClientUpdateApiBcRequestSignAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiBcRequestSignAlgRequest$ {
  /** @deprecated use `ClientUpdateApiBcRequestSignAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiBcRequestSignAlgRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiBcRequestSignAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiBcRequestSignAlgRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiAttributeRequest$inboundSchema: z.ZodType<
  ClientUpdateApiAttributeRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiAttributeRequest$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiAttributeRequest$outboundSchema: z.ZodType<
  ClientUpdateApiAttributeRequest$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiAttributeRequest
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiAttributeRequest$ {
  /** @deprecated use `ClientUpdateApiAttributeRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiAttributeRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiAttributeRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiAttributeRequest$outboundSchema;
  /** @deprecated use `ClientUpdateApiAttributeRequest$Outbound` instead. */
  export type Outbound = ClientUpdateApiAttributeRequest$Outbound;
}

export function clientUpdateApiAttributeRequestToJSON(
  clientUpdateApiAttributeRequest: ClientUpdateApiAttributeRequest,
): string {
  return JSON.stringify(
    ClientUpdateApiAttributeRequest$outboundSchema.parse(
      clientUpdateApiAttributeRequest,
    ),
  );
}

export function clientUpdateApiAttributeRequestFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiAttributeRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiAttributeRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiAttributeRequest' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiExtensionRequest$inboundSchema: z.ZodType<
  ClientUpdateApiExtensionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  requestableScopes: z.array(z.string()).optional(),
  requestableScopesEnabled: z.boolean().optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  idTokenDuration: z.number().int().optional(),
  tokenExchangePermitted: z.boolean().optional(),
});

/** @internal */
export type ClientUpdateApiExtensionRequest$Outbound = {
  requestableScopes?: Array<string> | undefined;
  requestableScopesEnabled?: boolean | undefined;
  accessTokenDuration?: number | undefined;
  refreshTokenDuration?: number | undefined;
  idTokenDuration?: number | undefined;
  tokenExchangePermitted?: boolean | undefined;
};

/** @internal */
export const ClientUpdateApiExtensionRequest$outboundSchema: z.ZodType<
  ClientUpdateApiExtensionRequest$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiExtensionRequest
> = z.object({
  requestableScopes: z.array(z.string()).optional(),
  requestableScopesEnabled: z.boolean().optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  idTokenDuration: z.number().int().optional(),
  tokenExchangePermitted: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiExtensionRequest$ {
  /** @deprecated use `ClientUpdateApiExtensionRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiExtensionRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiExtensionRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiExtensionRequest$outboundSchema;
  /** @deprecated use `ClientUpdateApiExtensionRequest$Outbound` instead. */
  export type Outbound = ClientUpdateApiExtensionRequest$Outbound;
}

export function clientUpdateApiExtensionRequestToJSON(
  clientUpdateApiExtensionRequest: ClientUpdateApiExtensionRequest,
): string {
  return JSON.stringify(
    ClientUpdateApiExtensionRequest$outboundSchema.parse(
      clientUpdateApiExtensionRequest,
    ),
  );
}

export function clientUpdateApiExtensionRequestFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiExtensionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiExtensionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiExtensionRequest' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiClientRegistrationTypeRequest$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiClientRegistrationTypeRequest> = z
    .nativeEnum(ClientUpdateApiClientRegistrationTypeRequest);

/** @internal */
export const ClientUpdateApiClientRegistrationTypeRequest$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiClientRegistrationTypeRequest> =
    ClientUpdateApiClientRegistrationTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiClientRegistrationTypeRequest$ {
  /** @deprecated use `ClientUpdateApiClientRegistrationTypeRequest$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiClientRegistrationTypeRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiClientRegistrationTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiClientRegistrationTypeRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiFapiModeRequest$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiFapiModeRequest
> = z.nativeEnum(ClientUpdateApiFapiModeRequest);

/** @internal */
export const ClientUpdateApiFapiModeRequest$outboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiFapiModeRequest
> = ClientUpdateApiFapiModeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiFapiModeRequest$ {
  /** @deprecated use `ClientUpdateApiFapiModeRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiFapiModeRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiFapiModeRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiFapiModeRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiResponseModeRequest$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiResponseModeRequest
> = z.nativeEnum(ClientUpdateApiResponseModeRequest);

/** @internal */
export const ClientUpdateApiResponseModeRequest$outboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiResponseModeRequest
> = ClientUpdateApiResponseModeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiResponseModeRequest$ {
  /** @deprecated use `ClientUpdateApiResponseModeRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiResponseModeRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiResponseModeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiResponseModeRequest$outboundSchema;
}

/** @internal */
export const ClientUpdateApiRequestBody$inboundSchema: z.ZodType<
  ClientUpdateApiRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  clientName: z.string().optional(),
  clientNames: z.array(
    z.lazy(() => ClientUpdateApiClientNameRequest$inboundSchema),
  ).optional(),
  description: z.string().optional(),
  descriptions: z.array(
    z.lazy(() => ClientUpdateApiDescriptionRequest$inboundSchema),
  ).optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasEnabled: z.boolean().optional(),
  clientType: ClientUpdateApiClientTypeRequest$inboundSchema.optional(),
  applicationType: ClientUpdateApiApplicationTypeRequest$inboundSchema
    .optional(),
  logoUri: z.string().optional(),
  logoUris: z.array(z.lazy(() => ClientUpdateApiLogoUrisRequest$inboundSchema))
    .optional(),
  contacts: z.array(z.string()).optional(),
  tlsClientCertificateBoundAccessTokens: z.boolean().optional(),
  softwareId: z.string().optional(),
  softwareVersion: z.string().optional(),
  registrationAccessTokenHash: z.string().optional(),
  grantTypes: z.array(ClientUpdateApiGrantTypeRequest$inboundSchema).optional(),
  responseTypes: z.array(ClientUpdateApiResponseTypeRequest$inboundSchema)
    .optional(),
  redirectUris: z.array(z.string()).optional(),
  authorizationSignAlg: ClientUpdateApiAuthorizationSignAlgRequest$inboundSchema
    .optional(),
  authorizationEncryptionAlg:
    ClientUpdateApiAuthorizationEncryptionAlgRequest$inboundSchema.optional(),
  authorizationEncryptionEnc:
    ClientUpdateApiAuthorizationEncryptionEncRequest$inboundSchema.optional(),
  tokenAuthMethod: ClientUpdateApiTokenAuthMethodRequest$inboundSchema
    .optional(),
  tokenAuthSignAlg: ClientUpdateApiTokenAuthSignAlgRequest$inboundSchema
    .optional(),
  selfSignedCertificateKeyId: z.string().optional(),
  tlsClientAuthSubjectDn: z.string().optional(),
  tlsClientAuthSanDns: z.string().optional(),
  tlsClientAuthSanUri: z.string().optional(),
  tlsClientAuthSanIp: z.string().optional(),
  tlsClientAuthSanEmail: z.string().optional(),
  parRequired: z.boolean().optional(),
  requestObjectRequired: z.boolean().optional(),
  requestSignAlg: ClientUpdateApiRequestSignAlgRequest$inboundSchema.optional(),
  requestEncryptionAlg: ClientUpdateApiRequestEncryptionAlgRequest$inboundSchema
    .optional(),
  requestEncryptionEnc: ClientUpdateApiRequestEncryptionEncRequest$inboundSchema
    .optional(),
  requestUris: z.array(z.string()).optional(),
  defaultMaxAge: z.number().int().optional(),
  defaultAcrs: z.array(z.string()).optional(),
  idTokenSignAlg: ClientUpdateApiIdTokenSignAlgRequest$inboundSchema.optional(),
  idTokenEncryptionAlg: ClientUpdateApiIdTokenEncryptionAlgRequest$inboundSchema
    .optional(),
  idTokenEncryptionEnc: ClientUpdateApiIdTokenEncryptionEncRequest$inboundSchema
    .optional(),
  authTimeRequired: z.boolean().optional(),
  subjectType: ClientUpdateApiSubjectTypeRequest$inboundSchema.optional(),
  sectorIdentifierUri: z.string().optional(),
  jwksUri: z.string().optional(),
  jwks: z.string().optional(),
  userInfoSignAlg: ClientUpdateApiUserInfoSignAlgRequest$inboundSchema
    .optional(),
  userInfoEncryptionAlg:
    ClientUpdateApiUserInfoEncryptionAlgRequest$inboundSchema.optional(),
  userInfoEncryptionEnc:
    ClientUpdateApiUserInfoEncryptionEncRequest$inboundSchema.optional(),
  loginUri: z.string().optional(),
  tosUri: z.string().optional(),
  tosUris: z.array(z.lazy(() => ClientUpdateApiTosUrisRequest$inboundSchema))
    .optional(),
  policyUri: z.string().optional(),
  policyUris: z.array(
    z.lazy(() => ClientUpdateApiPolicyUrisRequest$inboundSchema),
  ).optional(),
  clientUri: z.string().optional(),
  clientUris: z.array(
    z.lazy(() => ClientUpdateApiClientUrisRequest$inboundSchema),
  ).optional(),
  bcDeliveryMode: z.string().optional(),
  bcNotificationEndpoint: z.string().optional(),
  bcRequestSignAlg: ClientUpdateApiBcRequestSignAlgRequest$inboundSchema
    .optional(),
  bcUserCodeRequired: z.boolean().optional(),
  attributes: z.array(
    z.lazy(() => ClientUpdateApiAttributeRequest$inboundSchema),
  ).optional(),
  extension: z.lazy(() => ClientUpdateApiExtensionRequest$inboundSchema)
    .optional(),
  authorizationDetailsTypes: z.array(z.string()).optional(),
  customMetadata: z.string().optional(),
  frontChannelRequestObjectEncryptionRequired: z.boolean().optional(),
  requestObjectEncryptionAlgMatchRequired: z.boolean().optional(),
  requestObjectEncryptionEncMatchRequired: z.boolean().optional(),
  digestAlgorithm: z.string().optional(),
  singleAccessTokenPerSubject: z.boolean().optional(),
  pkceRequired: z.boolean().optional(),
  pkceS256Required: z.boolean().optional(),
  dpopRequired: z.boolean().optional(),
  automaticallyRegistered: z.boolean().optional(),
  explicitlyRegistered: z.boolean().optional(),
  rsRequestSigned: z.boolean().optional(),
  rsSignedRequestKeyId: z.string().optional(),
  clientRegistrationTypes: z.array(
    ClientUpdateApiClientRegistrationTypeRequest$inboundSchema,
  ).optional(),
  organizationName: z.string().optional(),
  signedJwksUri: z.string().optional(),
  entityId: z.string().optional(),
  trustAnchorId: z.string().optional(),
  trustChain: z.array(z.string()).optional(),
  trustChainExpiresAt: z.number().int().optional(),
  trustChainUpdatedAt: z.number().int().optional(),
  locked: z.boolean().optional(),
  credentialOfferEndpoint: z.string().optional(),
  fapiModes: z.array(ClientUpdateApiFapiModeRequest$inboundSchema).optional(),
  responseModes: z.array(ClientUpdateApiResponseModeRequest$inboundSchema)
    .optional(),
  credentialResponseEncryptionRequired: z.boolean().optional(),
});

/** @internal */
export type ClientUpdateApiRequestBody$Outbound = {
  clientName?: string | undefined;
  clientNames?: Array<ClientUpdateApiClientNameRequest$Outbound> | undefined;
  description?: string | undefined;
  descriptions?: Array<ClientUpdateApiDescriptionRequest$Outbound> | undefined;
  clientIdAlias?: string | undefined;
  clientIdAliasEnabled?: boolean | undefined;
  clientType?: string | undefined;
  applicationType?: string | undefined;
  logoUri?: string | undefined;
  logoUris?: Array<ClientUpdateApiLogoUrisRequest$Outbound> | undefined;
  contacts?: Array<string> | undefined;
  tlsClientCertificateBoundAccessTokens?: boolean | undefined;
  softwareId?: string | undefined;
  softwareVersion?: string | undefined;
  registrationAccessTokenHash?: string | undefined;
  grantTypes?: Array<string> | undefined;
  responseTypes?: Array<string> | undefined;
  redirectUris?: Array<string> | undefined;
  authorizationSignAlg?: string | undefined;
  authorizationEncryptionAlg?: string | undefined;
  authorizationEncryptionEnc?: string | undefined;
  tokenAuthMethod?: string | undefined;
  tokenAuthSignAlg?: string | undefined;
  selfSignedCertificateKeyId?: string | undefined;
  tlsClientAuthSubjectDn?: string | undefined;
  tlsClientAuthSanDns?: string | undefined;
  tlsClientAuthSanUri?: string | undefined;
  tlsClientAuthSanIp?: string | undefined;
  tlsClientAuthSanEmail?: string | undefined;
  parRequired?: boolean | undefined;
  requestObjectRequired?: boolean | undefined;
  requestSignAlg?: string | undefined;
  requestEncryptionAlg?: string | undefined;
  requestEncryptionEnc?: string | undefined;
  requestUris?: Array<string> | undefined;
  defaultMaxAge?: number | undefined;
  defaultAcrs?: Array<string> | undefined;
  idTokenSignAlg?: string | undefined;
  idTokenEncryptionAlg?: string | undefined;
  idTokenEncryptionEnc?: string | undefined;
  authTimeRequired?: boolean | undefined;
  subjectType?: string | undefined;
  sectorIdentifierUri?: string | undefined;
  jwksUri?: string | undefined;
  jwks?: string | undefined;
  userInfoSignAlg?: string | undefined;
  userInfoEncryptionAlg?: string | undefined;
  userInfoEncryptionEnc?: string | undefined;
  loginUri?: string | undefined;
  tosUri?: string | undefined;
  tosUris?: Array<ClientUpdateApiTosUrisRequest$Outbound> | undefined;
  policyUri?: string | undefined;
  policyUris?: Array<ClientUpdateApiPolicyUrisRequest$Outbound> | undefined;
  clientUri?: string | undefined;
  clientUris?: Array<ClientUpdateApiClientUrisRequest$Outbound> | undefined;
  bcDeliveryMode?: string | undefined;
  bcNotificationEndpoint?: string | undefined;
  bcRequestSignAlg?: string | undefined;
  bcUserCodeRequired?: boolean | undefined;
  attributes?: Array<ClientUpdateApiAttributeRequest$Outbound> | undefined;
  extension?: ClientUpdateApiExtensionRequest$Outbound | undefined;
  authorizationDetailsTypes?: Array<string> | undefined;
  customMetadata?: string | undefined;
  frontChannelRequestObjectEncryptionRequired?: boolean | undefined;
  requestObjectEncryptionAlgMatchRequired?: boolean | undefined;
  requestObjectEncryptionEncMatchRequired?: boolean | undefined;
  digestAlgorithm?: string | undefined;
  singleAccessTokenPerSubject?: boolean | undefined;
  pkceRequired?: boolean | undefined;
  pkceS256Required?: boolean | undefined;
  dpopRequired?: boolean | undefined;
  automaticallyRegistered?: boolean | undefined;
  explicitlyRegistered?: boolean | undefined;
  rsRequestSigned?: boolean | undefined;
  rsSignedRequestKeyId?: string | undefined;
  clientRegistrationTypes?: Array<string> | undefined;
  organizationName?: string | undefined;
  signedJwksUri?: string | undefined;
  entityId?: string | undefined;
  trustAnchorId?: string | undefined;
  trustChain?: Array<string> | undefined;
  trustChainExpiresAt?: number | undefined;
  trustChainUpdatedAt?: number | undefined;
  locked?: boolean | undefined;
  credentialOfferEndpoint?: string | undefined;
  fapiModes?: Array<string> | undefined;
  responseModes?: Array<string> | undefined;
  credentialResponseEncryptionRequired?: boolean | undefined;
};

/** @internal */
export const ClientUpdateApiRequestBody$outboundSchema: z.ZodType<
  ClientUpdateApiRequestBody$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiRequestBody
> = z.object({
  clientName: z.string().optional(),
  clientNames: z.array(
    z.lazy(() => ClientUpdateApiClientNameRequest$outboundSchema),
  ).optional(),
  description: z.string().optional(),
  descriptions: z.array(
    z.lazy(() => ClientUpdateApiDescriptionRequest$outboundSchema),
  ).optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasEnabled: z.boolean().optional(),
  clientType: ClientUpdateApiClientTypeRequest$outboundSchema.optional(),
  applicationType: ClientUpdateApiApplicationTypeRequest$outboundSchema
    .optional(),
  logoUri: z.string().optional(),
  logoUris: z.array(z.lazy(() => ClientUpdateApiLogoUrisRequest$outboundSchema))
    .optional(),
  contacts: z.array(z.string()).optional(),
  tlsClientCertificateBoundAccessTokens: z.boolean().optional(),
  softwareId: z.string().optional(),
  softwareVersion: z.string().optional(),
  registrationAccessTokenHash: z.string().optional(),
  grantTypes: z.array(ClientUpdateApiGrantTypeRequest$outboundSchema)
    .optional(),
  responseTypes: z.array(ClientUpdateApiResponseTypeRequest$outboundSchema)
    .optional(),
  redirectUris: z.array(z.string()).optional(),
  authorizationSignAlg:
    ClientUpdateApiAuthorizationSignAlgRequest$outboundSchema.optional(),
  authorizationEncryptionAlg:
    ClientUpdateApiAuthorizationEncryptionAlgRequest$outboundSchema.optional(),
  authorizationEncryptionEnc:
    ClientUpdateApiAuthorizationEncryptionEncRequest$outboundSchema.optional(),
  tokenAuthMethod: ClientUpdateApiTokenAuthMethodRequest$outboundSchema
    .optional(),
  tokenAuthSignAlg: ClientUpdateApiTokenAuthSignAlgRequest$outboundSchema
    .optional(),
  selfSignedCertificateKeyId: z.string().optional(),
  tlsClientAuthSubjectDn: z.string().optional(),
  tlsClientAuthSanDns: z.string().optional(),
  tlsClientAuthSanUri: z.string().optional(),
  tlsClientAuthSanIp: z.string().optional(),
  tlsClientAuthSanEmail: z.string().optional(),
  parRequired: z.boolean().optional(),
  requestObjectRequired: z.boolean().optional(),
  requestSignAlg: ClientUpdateApiRequestSignAlgRequest$outboundSchema
    .optional(),
  requestEncryptionAlg:
    ClientUpdateApiRequestEncryptionAlgRequest$outboundSchema.optional(),
  requestEncryptionEnc:
    ClientUpdateApiRequestEncryptionEncRequest$outboundSchema.optional(),
  requestUris: z.array(z.string()).optional(),
  defaultMaxAge: z.number().int().optional(),
  defaultAcrs: z.array(z.string()).optional(),
  idTokenSignAlg: ClientUpdateApiIdTokenSignAlgRequest$outboundSchema
    .optional(),
  idTokenEncryptionAlg:
    ClientUpdateApiIdTokenEncryptionAlgRequest$outboundSchema.optional(),
  idTokenEncryptionEnc:
    ClientUpdateApiIdTokenEncryptionEncRequest$outboundSchema.optional(),
  authTimeRequired: z.boolean().optional(),
  subjectType: ClientUpdateApiSubjectTypeRequest$outboundSchema.optional(),
  sectorIdentifierUri: z.string().optional(),
  jwksUri: z.string().optional(),
  jwks: z.string().optional(),
  userInfoSignAlg: ClientUpdateApiUserInfoSignAlgRequest$outboundSchema
    .optional(),
  userInfoEncryptionAlg:
    ClientUpdateApiUserInfoEncryptionAlgRequest$outboundSchema.optional(),
  userInfoEncryptionEnc:
    ClientUpdateApiUserInfoEncryptionEncRequest$outboundSchema.optional(),
  loginUri: z.string().optional(),
  tosUri: z.string().optional(),
  tosUris: z.array(z.lazy(() => ClientUpdateApiTosUrisRequest$outboundSchema))
    .optional(),
  policyUri: z.string().optional(),
  policyUris: z.array(
    z.lazy(() => ClientUpdateApiPolicyUrisRequest$outboundSchema),
  ).optional(),
  clientUri: z.string().optional(),
  clientUris: z.array(
    z.lazy(() => ClientUpdateApiClientUrisRequest$outboundSchema),
  ).optional(),
  bcDeliveryMode: z.string().optional(),
  bcNotificationEndpoint: z.string().optional(),
  bcRequestSignAlg: ClientUpdateApiBcRequestSignAlgRequest$outboundSchema
    .optional(),
  bcUserCodeRequired: z.boolean().optional(),
  attributes: z.array(
    z.lazy(() => ClientUpdateApiAttributeRequest$outboundSchema),
  ).optional(),
  extension: z.lazy(() => ClientUpdateApiExtensionRequest$outboundSchema)
    .optional(),
  authorizationDetailsTypes: z.array(z.string()).optional(),
  customMetadata: z.string().optional(),
  frontChannelRequestObjectEncryptionRequired: z.boolean().optional(),
  requestObjectEncryptionAlgMatchRequired: z.boolean().optional(),
  requestObjectEncryptionEncMatchRequired: z.boolean().optional(),
  digestAlgorithm: z.string().optional(),
  singleAccessTokenPerSubject: z.boolean().optional(),
  pkceRequired: z.boolean().optional(),
  pkceS256Required: z.boolean().optional(),
  dpopRequired: z.boolean().optional(),
  automaticallyRegistered: z.boolean().optional(),
  explicitlyRegistered: z.boolean().optional(),
  rsRequestSigned: z.boolean().optional(),
  rsSignedRequestKeyId: z.string().optional(),
  clientRegistrationTypes: z.array(
    ClientUpdateApiClientRegistrationTypeRequest$outboundSchema,
  ).optional(),
  organizationName: z.string().optional(),
  signedJwksUri: z.string().optional(),
  entityId: z.string().optional(),
  trustAnchorId: z.string().optional(),
  trustChain: z.array(z.string()).optional(),
  trustChainExpiresAt: z.number().int().optional(),
  trustChainUpdatedAt: z.number().int().optional(),
  locked: z.boolean().optional(),
  credentialOfferEndpoint: z.string().optional(),
  fapiModes: z.array(ClientUpdateApiFapiModeRequest$outboundSchema).optional(),
  responseModes: z.array(ClientUpdateApiResponseModeRequest$outboundSchema)
    .optional(),
  credentialResponseEncryptionRequired: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiRequestBody$ {
  /** @deprecated use `ClientUpdateApiRequestBody$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiRequestBody$inboundSchema;
  /** @deprecated use `ClientUpdateApiRequestBody$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiRequestBody$outboundSchema;
  /** @deprecated use `ClientUpdateApiRequestBody$Outbound` instead. */
  export type Outbound = ClientUpdateApiRequestBody$Outbound;
}

export function clientUpdateApiRequestBodyToJSON(
  clientUpdateApiRequestBody: ClientUpdateApiRequestBody,
): string {
  return JSON.stringify(
    ClientUpdateApiRequestBody$outboundSchema.parse(clientUpdateApiRequestBody),
  );
}

export function clientUpdateApiRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiRequestBody' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiRequest$inboundSchema: z.ZodType<
  ClientUpdateApiRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  serviceId: z.string(),
  clientId: z.string(),
  RequestBody: z.lazy(() => ClientUpdateApiRequestBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type ClientUpdateApiRequest$Outbound = {
  serviceId: string;
  clientId: string;
  RequestBody?: ClientUpdateApiRequestBody$Outbound | undefined;
};

/** @internal */
export const ClientUpdateApiRequest$outboundSchema: z.ZodType<
  ClientUpdateApiRequest$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiRequest
> = z.object({
  serviceId: z.string(),
  clientId: z.string(),
  requestBody: z.lazy(() => ClientUpdateApiRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiRequest$ {
  /** @deprecated use `ClientUpdateApiRequest$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiRequest$inboundSchema;
  /** @deprecated use `ClientUpdateApiRequest$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiRequest$outboundSchema;
  /** @deprecated use `ClientUpdateApiRequest$Outbound` instead. */
  export type Outbound = ClientUpdateApiRequest$Outbound;
}

export function clientUpdateApiRequestToJSON(
  clientUpdateApiRequest: ClientUpdateApiRequest,
): string {
  return JSON.stringify(
    ClientUpdateApiRequest$outboundSchema.parse(clientUpdateApiRequest),
  );
}

export function clientUpdateApiRequestFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiRequest' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiClientNameResponse$inboundSchema: z.ZodType<
  ClientUpdateApiClientNameResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiClientNameResponse$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiClientNameResponse$outboundSchema: z.ZodType<
  ClientUpdateApiClientNameResponse$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiClientNameResponse
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiClientNameResponse$ {
  /** @deprecated use `ClientUpdateApiClientNameResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiClientNameResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiClientNameResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiClientNameResponse$outboundSchema;
  /** @deprecated use `ClientUpdateApiClientNameResponse$Outbound` instead. */
  export type Outbound = ClientUpdateApiClientNameResponse$Outbound;
}

export function clientUpdateApiClientNameResponseToJSON(
  clientUpdateApiClientNameResponse: ClientUpdateApiClientNameResponse,
): string {
  return JSON.stringify(
    ClientUpdateApiClientNameResponse$outboundSchema.parse(
      clientUpdateApiClientNameResponse,
    ),
  );
}

export function clientUpdateApiClientNameResponseFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiClientNameResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiClientNameResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiClientNameResponse' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiDescriptionResponse$inboundSchema: z.ZodType<
  ClientUpdateApiDescriptionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiDescriptionResponse$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiDescriptionResponse$outboundSchema: z.ZodType<
  ClientUpdateApiDescriptionResponse$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiDescriptionResponse
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiDescriptionResponse$ {
  /** @deprecated use `ClientUpdateApiDescriptionResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiDescriptionResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiDescriptionResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiDescriptionResponse$outboundSchema;
  /** @deprecated use `ClientUpdateApiDescriptionResponse$Outbound` instead. */
  export type Outbound = ClientUpdateApiDescriptionResponse$Outbound;
}

export function clientUpdateApiDescriptionResponseToJSON(
  clientUpdateApiDescriptionResponse: ClientUpdateApiDescriptionResponse,
): string {
  return JSON.stringify(
    ClientUpdateApiDescriptionResponse$outboundSchema.parse(
      clientUpdateApiDescriptionResponse,
    ),
  );
}

export function clientUpdateApiDescriptionResponseFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiDescriptionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ClientUpdateApiDescriptionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiDescriptionResponse' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiClientTypeResponse$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiClientTypeResponse
> = z.nativeEnum(ClientUpdateApiClientTypeResponse);

/** @internal */
export const ClientUpdateApiClientTypeResponse$outboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiClientTypeResponse
> = ClientUpdateApiClientTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiClientTypeResponse$ {
  /** @deprecated use `ClientUpdateApiClientTypeResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiClientTypeResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiClientTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiClientTypeResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiApplicationTypeResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiApplicationTypeResponse> = z.nativeEnum(
    ClientUpdateApiApplicationTypeResponse,
  );

/** @internal */
export const ClientUpdateApiApplicationTypeResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiApplicationTypeResponse> =
    ClientUpdateApiApplicationTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiApplicationTypeResponse$ {
  /** @deprecated use `ClientUpdateApiApplicationTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiApplicationTypeResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiApplicationTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiApplicationTypeResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiLogoUrisResponse$inboundSchema: z.ZodType<
  ClientUpdateApiLogoUrisResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiLogoUrisResponse$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiLogoUrisResponse$outboundSchema: z.ZodType<
  ClientUpdateApiLogoUrisResponse$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiLogoUrisResponse
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiLogoUrisResponse$ {
  /** @deprecated use `ClientUpdateApiLogoUrisResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiLogoUrisResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiLogoUrisResponse$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiLogoUrisResponse$outboundSchema;
  /** @deprecated use `ClientUpdateApiLogoUrisResponse$Outbound` instead. */
  export type Outbound = ClientUpdateApiLogoUrisResponse$Outbound;
}

export function clientUpdateApiLogoUrisResponseToJSON(
  clientUpdateApiLogoUrisResponse: ClientUpdateApiLogoUrisResponse,
): string {
  return JSON.stringify(
    ClientUpdateApiLogoUrisResponse$outboundSchema.parse(
      clientUpdateApiLogoUrisResponse,
    ),
  );
}

export function clientUpdateApiLogoUrisResponseFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiLogoUrisResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiLogoUrisResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiLogoUrisResponse' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiGrantTypeResponse$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiGrantTypeResponse
> = z.nativeEnum(ClientUpdateApiGrantTypeResponse);

/** @internal */
export const ClientUpdateApiGrantTypeResponse$outboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiGrantTypeResponse
> = ClientUpdateApiGrantTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiGrantTypeResponse$ {
  /** @deprecated use `ClientUpdateApiGrantTypeResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiGrantTypeResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiGrantTypeResponse$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiGrantTypeResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiResponseTypeResponse$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiResponseTypeResponse
> = z.nativeEnum(ClientUpdateApiResponseTypeResponse);

/** @internal */
export const ClientUpdateApiResponseTypeResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiResponseTypeResponse> =
    ClientUpdateApiResponseTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiResponseTypeResponse$ {
  /** @deprecated use `ClientUpdateApiResponseTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiResponseTypeResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiResponseTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiResponseTypeResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiAuthorizationSignAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationSignAlgResponse> = z
    .nativeEnum(ClientUpdateApiAuthorizationSignAlgResponse);

/** @internal */
export const ClientUpdateApiAuthorizationSignAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationSignAlgResponse> =
    ClientUpdateApiAuthorizationSignAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiAuthorizationSignAlgResponse$ {
  /** @deprecated use `ClientUpdateApiAuthorizationSignAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiAuthorizationSignAlgResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiAuthorizationSignAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiAuthorizationSignAlgResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiAuthorizationEncryptionAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationEncryptionAlgResponse> = z
    .nativeEnum(ClientUpdateApiAuthorizationEncryptionAlgResponse);

/** @internal */
export const ClientUpdateApiAuthorizationEncryptionAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationEncryptionAlgResponse> =
    ClientUpdateApiAuthorizationEncryptionAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiAuthorizationEncryptionAlgResponse$ {
  /** @deprecated use `ClientUpdateApiAuthorizationEncryptionAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiAuthorizationEncryptionAlgResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiAuthorizationEncryptionAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiAuthorizationEncryptionAlgResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiAuthorizationEncryptionEncResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationEncryptionEncResponse> = z
    .nativeEnum(ClientUpdateApiAuthorizationEncryptionEncResponse);

/** @internal */
export const ClientUpdateApiAuthorizationEncryptionEncResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiAuthorizationEncryptionEncResponse> =
    ClientUpdateApiAuthorizationEncryptionEncResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiAuthorizationEncryptionEncResponse$ {
  /** @deprecated use `ClientUpdateApiAuthorizationEncryptionEncResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiAuthorizationEncryptionEncResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiAuthorizationEncryptionEncResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiAuthorizationEncryptionEncResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiTokenAuthMethodResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiTokenAuthMethodResponse> = z.nativeEnum(
    ClientUpdateApiTokenAuthMethodResponse,
  );

/** @internal */
export const ClientUpdateApiTokenAuthMethodResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiTokenAuthMethodResponse> =
    ClientUpdateApiTokenAuthMethodResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiTokenAuthMethodResponse$ {
  /** @deprecated use `ClientUpdateApiTokenAuthMethodResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiTokenAuthMethodResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiTokenAuthMethodResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiTokenAuthMethodResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiTokenAuthSignAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiTokenAuthSignAlgResponse> = z
    .nativeEnum(ClientUpdateApiTokenAuthSignAlgResponse);

/** @internal */
export const ClientUpdateApiTokenAuthSignAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiTokenAuthSignAlgResponse> =
    ClientUpdateApiTokenAuthSignAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiTokenAuthSignAlgResponse$ {
  /** @deprecated use `ClientUpdateApiTokenAuthSignAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiTokenAuthSignAlgResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiTokenAuthSignAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiTokenAuthSignAlgResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiRequestSignAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestSignAlgResponse> = z.nativeEnum(
    ClientUpdateApiRequestSignAlgResponse,
  );

/** @internal */
export const ClientUpdateApiRequestSignAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestSignAlgResponse> =
    ClientUpdateApiRequestSignAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiRequestSignAlgResponse$ {
  /** @deprecated use `ClientUpdateApiRequestSignAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiRequestSignAlgResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiRequestSignAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiRequestSignAlgResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiRequestEncryptionAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestEncryptionAlgResponse> = z
    .nativeEnum(ClientUpdateApiRequestEncryptionAlgResponse);

/** @internal */
export const ClientUpdateApiRequestEncryptionAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestEncryptionAlgResponse> =
    ClientUpdateApiRequestEncryptionAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiRequestEncryptionAlgResponse$ {
  /** @deprecated use `ClientUpdateApiRequestEncryptionAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiRequestEncryptionAlgResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiRequestEncryptionAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiRequestEncryptionAlgResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiRequestEncryptionEncResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestEncryptionEncResponse> = z
    .nativeEnum(ClientUpdateApiRequestEncryptionEncResponse);

/** @internal */
export const ClientUpdateApiRequestEncryptionEncResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiRequestEncryptionEncResponse> =
    ClientUpdateApiRequestEncryptionEncResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiRequestEncryptionEncResponse$ {
  /** @deprecated use `ClientUpdateApiRequestEncryptionEncResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiRequestEncryptionEncResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiRequestEncryptionEncResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiRequestEncryptionEncResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiIdTokenSignAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenSignAlgResponse> = z.nativeEnum(
    ClientUpdateApiIdTokenSignAlgResponse,
  );

/** @internal */
export const ClientUpdateApiIdTokenSignAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenSignAlgResponse> =
    ClientUpdateApiIdTokenSignAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiIdTokenSignAlgResponse$ {
  /** @deprecated use `ClientUpdateApiIdTokenSignAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiIdTokenSignAlgResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiIdTokenSignAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiIdTokenSignAlgResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiIdTokenEncryptionAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenEncryptionAlgResponse> = z
    .nativeEnum(ClientUpdateApiIdTokenEncryptionAlgResponse);

/** @internal */
export const ClientUpdateApiIdTokenEncryptionAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenEncryptionAlgResponse> =
    ClientUpdateApiIdTokenEncryptionAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiIdTokenEncryptionAlgResponse$ {
  /** @deprecated use `ClientUpdateApiIdTokenEncryptionAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiIdTokenEncryptionAlgResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiIdTokenEncryptionAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiIdTokenEncryptionAlgResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiIdTokenEncryptionEncResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenEncryptionEncResponse> = z
    .nativeEnum(ClientUpdateApiIdTokenEncryptionEncResponse);

/** @internal */
export const ClientUpdateApiIdTokenEncryptionEncResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiIdTokenEncryptionEncResponse> =
    ClientUpdateApiIdTokenEncryptionEncResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiIdTokenEncryptionEncResponse$ {
  /** @deprecated use `ClientUpdateApiIdTokenEncryptionEncResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiIdTokenEncryptionEncResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiIdTokenEncryptionEncResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiIdTokenEncryptionEncResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiSubjectTypeResponse$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiSubjectTypeResponse
> = z.nativeEnum(ClientUpdateApiSubjectTypeResponse);

/** @internal */
export const ClientUpdateApiSubjectTypeResponse$outboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiSubjectTypeResponse
> = ClientUpdateApiSubjectTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiSubjectTypeResponse$ {
  /** @deprecated use `ClientUpdateApiSubjectTypeResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiSubjectTypeResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiSubjectTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiSubjectTypeResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiUserInfoSignAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoSignAlgResponse> = z.nativeEnum(
    ClientUpdateApiUserInfoSignAlgResponse,
  );

/** @internal */
export const ClientUpdateApiUserInfoSignAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoSignAlgResponse> =
    ClientUpdateApiUserInfoSignAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiUserInfoSignAlgResponse$ {
  /** @deprecated use `ClientUpdateApiUserInfoSignAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiUserInfoSignAlgResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiUserInfoSignAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiUserInfoSignAlgResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiUserInfoEncryptionAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoEncryptionAlgResponse> = z
    .nativeEnum(ClientUpdateApiUserInfoEncryptionAlgResponse);

/** @internal */
export const ClientUpdateApiUserInfoEncryptionAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoEncryptionAlgResponse> =
    ClientUpdateApiUserInfoEncryptionAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiUserInfoEncryptionAlgResponse$ {
  /** @deprecated use `ClientUpdateApiUserInfoEncryptionAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiUserInfoEncryptionAlgResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiUserInfoEncryptionAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiUserInfoEncryptionAlgResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiUserInfoEncryptionEncResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoEncryptionEncResponse> = z
    .nativeEnum(ClientUpdateApiUserInfoEncryptionEncResponse);

/** @internal */
export const ClientUpdateApiUserInfoEncryptionEncResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiUserInfoEncryptionEncResponse> =
    ClientUpdateApiUserInfoEncryptionEncResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiUserInfoEncryptionEncResponse$ {
  /** @deprecated use `ClientUpdateApiUserInfoEncryptionEncResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiUserInfoEncryptionEncResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiUserInfoEncryptionEncResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiUserInfoEncryptionEncResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiTosUrisResponse$inboundSchema: z.ZodType<
  ClientUpdateApiTosUrisResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiTosUrisResponse$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiTosUrisResponse$outboundSchema: z.ZodType<
  ClientUpdateApiTosUrisResponse$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiTosUrisResponse
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiTosUrisResponse$ {
  /** @deprecated use `ClientUpdateApiTosUrisResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiTosUrisResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiTosUrisResponse$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiTosUrisResponse$outboundSchema;
  /** @deprecated use `ClientUpdateApiTosUrisResponse$Outbound` instead. */
  export type Outbound = ClientUpdateApiTosUrisResponse$Outbound;
}

export function clientUpdateApiTosUrisResponseToJSON(
  clientUpdateApiTosUrisResponse: ClientUpdateApiTosUrisResponse,
): string {
  return JSON.stringify(
    ClientUpdateApiTosUrisResponse$outboundSchema.parse(
      clientUpdateApiTosUrisResponse,
    ),
  );
}

export function clientUpdateApiTosUrisResponseFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiTosUrisResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiTosUrisResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiTosUrisResponse' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiPolicyUrisResponse$inboundSchema: z.ZodType<
  ClientUpdateApiPolicyUrisResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiPolicyUrisResponse$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiPolicyUrisResponse$outboundSchema: z.ZodType<
  ClientUpdateApiPolicyUrisResponse$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiPolicyUrisResponse
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiPolicyUrisResponse$ {
  /** @deprecated use `ClientUpdateApiPolicyUrisResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiPolicyUrisResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiPolicyUrisResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiPolicyUrisResponse$outboundSchema;
  /** @deprecated use `ClientUpdateApiPolicyUrisResponse$Outbound` instead. */
  export type Outbound = ClientUpdateApiPolicyUrisResponse$Outbound;
}

export function clientUpdateApiPolicyUrisResponseToJSON(
  clientUpdateApiPolicyUrisResponse: ClientUpdateApiPolicyUrisResponse,
): string {
  return JSON.stringify(
    ClientUpdateApiPolicyUrisResponse$outboundSchema.parse(
      clientUpdateApiPolicyUrisResponse,
    ),
  );
}

export function clientUpdateApiPolicyUrisResponseFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiPolicyUrisResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiPolicyUrisResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiPolicyUrisResponse' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiClientUrisResponse$inboundSchema: z.ZodType<
  ClientUpdateApiClientUrisResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiClientUrisResponse$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiClientUrisResponse$outboundSchema: z.ZodType<
  ClientUpdateApiClientUrisResponse$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiClientUrisResponse
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiClientUrisResponse$ {
  /** @deprecated use `ClientUpdateApiClientUrisResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiClientUrisResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiClientUrisResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiClientUrisResponse$outboundSchema;
  /** @deprecated use `ClientUpdateApiClientUrisResponse$Outbound` instead. */
  export type Outbound = ClientUpdateApiClientUrisResponse$Outbound;
}

export function clientUpdateApiClientUrisResponseToJSON(
  clientUpdateApiClientUrisResponse: ClientUpdateApiClientUrisResponse,
): string {
  return JSON.stringify(
    ClientUpdateApiClientUrisResponse$outboundSchema.parse(
      clientUpdateApiClientUrisResponse,
    ),
  );
}

export function clientUpdateApiClientUrisResponseFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiClientUrisResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiClientUrisResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiClientUrisResponse' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiBcRequestSignAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiBcRequestSignAlgResponse> = z
    .nativeEnum(ClientUpdateApiBcRequestSignAlgResponse);

/** @internal */
export const ClientUpdateApiBcRequestSignAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiBcRequestSignAlgResponse> =
    ClientUpdateApiBcRequestSignAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiBcRequestSignAlgResponse$ {
  /** @deprecated use `ClientUpdateApiBcRequestSignAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiBcRequestSignAlgResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiBcRequestSignAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiBcRequestSignAlgResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiAttributeResponse$inboundSchema: z.ZodType<
  ClientUpdateApiAttributeResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ClientUpdateApiAttributeResponse$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ClientUpdateApiAttributeResponse$outboundSchema: z.ZodType<
  ClientUpdateApiAttributeResponse$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiAttributeResponse
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiAttributeResponse$ {
  /** @deprecated use `ClientUpdateApiAttributeResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiAttributeResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiAttributeResponse$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiAttributeResponse$outboundSchema;
  /** @deprecated use `ClientUpdateApiAttributeResponse$Outbound` instead. */
  export type Outbound = ClientUpdateApiAttributeResponse$Outbound;
}

export function clientUpdateApiAttributeResponseToJSON(
  clientUpdateApiAttributeResponse: ClientUpdateApiAttributeResponse,
): string {
  return JSON.stringify(
    ClientUpdateApiAttributeResponse$outboundSchema.parse(
      clientUpdateApiAttributeResponse,
    ),
  );
}

export function clientUpdateApiAttributeResponseFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiAttributeResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiAttributeResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiAttributeResponse' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiExtensionResponse$inboundSchema: z.ZodType<
  ClientUpdateApiExtensionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  requestableScopes: z.array(z.string()).optional(),
  requestableScopesEnabled: z.boolean().optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  idTokenDuration: z.number().int().optional(),
  tokenExchangePermitted: z.boolean().optional(),
});

/** @internal */
export type ClientUpdateApiExtensionResponse$Outbound = {
  requestableScopes?: Array<string> | undefined;
  requestableScopesEnabled?: boolean | undefined;
  accessTokenDuration?: number | undefined;
  refreshTokenDuration?: number | undefined;
  idTokenDuration?: number | undefined;
  tokenExchangePermitted?: boolean | undefined;
};

/** @internal */
export const ClientUpdateApiExtensionResponse$outboundSchema: z.ZodType<
  ClientUpdateApiExtensionResponse$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiExtensionResponse
> = z.object({
  requestableScopes: z.array(z.string()).optional(),
  requestableScopesEnabled: z.boolean().optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  idTokenDuration: z.number().int().optional(),
  tokenExchangePermitted: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiExtensionResponse$ {
  /** @deprecated use `ClientUpdateApiExtensionResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiExtensionResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiExtensionResponse$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiExtensionResponse$outboundSchema;
  /** @deprecated use `ClientUpdateApiExtensionResponse$Outbound` instead. */
  export type Outbound = ClientUpdateApiExtensionResponse$Outbound;
}

export function clientUpdateApiExtensionResponseToJSON(
  clientUpdateApiExtensionResponse: ClientUpdateApiExtensionResponse,
): string {
  return JSON.stringify(
    ClientUpdateApiExtensionResponse$outboundSchema.parse(
      clientUpdateApiExtensionResponse,
    ),
  );
}

export function clientUpdateApiExtensionResponseFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiExtensionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiExtensionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiExtensionResponse' from JSON`,
  );
}

/** @internal */
export const ClientUpdateApiClientRegistrationTypeResponse$inboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiClientRegistrationTypeResponse> = z
    .nativeEnum(ClientUpdateApiClientRegistrationTypeResponse);

/** @internal */
export const ClientUpdateApiClientRegistrationTypeResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiClientRegistrationTypeResponse> =
    ClientUpdateApiClientRegistrationTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiClientRegistrationTypeResponse$ {
  /** @deprecated use `ClientUpdateApiClientRegistrationTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiClientRegistrationTypeResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiClientRegistrationTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiClientRegistrationTypeResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiFapiModeResponse$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiFapiModeResponse
> = z.nativeEnum(ClientUpdateApiFapiModeResponse);

/** @internal */
export const ClientUpdateApiFapiModeResponse$outboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiFapiModeResponse
> = ClientUpdateApiFapiModeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiFapiModeResponse$ {
  /** @deprecated use `ClientUpdateApiFapiModeResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiFapiModeResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiFapiModeResponse$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiFapiModeResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiResponseModeResponse$inboundSchema: z.ZodNativeEnum<
  typeof ClientUpdateApiResponseModeResponse
> = z.nativeEnum(ClientUpdateApiResponseModeResponse);

/** @internal */
export const ClientUpdateApiResponseModeResponse$outboundSchema:
  z.ZodNativeEnum<typeof ClientUpdateApiResponseModeResponse> =
    ClientUpdateApiResponseModeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiResponseModeResponse$ {
  /** @deprecated use `ClientUpdateApiResponseModeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ClientUpdateApiResponseModeResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiResponseModeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ClientUpdateApiResponseModeResponse$outboundSchema;
}

/** @internal */
export const ClientUpdateApiResponse$inboundSchema: z.ZodType<
  ClientUpdateApiResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  number: z.number().int().optional(),
  serviceNumber: z.number().int().optional(),
  clientName: z.string().optional(),
  clientNames: z.array(
    z.lazy(() => ClientUpdateApiClientNameResponse$inboundSchema),
  ).optional(),
  description: z.string().optional(),
  descriptions: z.array(
    z.lazy(() => ClientUpdateApiDescriptionResponse$inboundSchema),
  ).optional(),
  clientId: z.number().int().optional(),
  clientSecret: z.string().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasEnabled: z.boolean().optional(),
  clientType: ClientUpdateApiClientTypeResponse$inboundSchema.optional(),
  applicationType: ClientUpdateApiApplicationTypeResponse$inboundSchema
    .optional(),
  logoUri: z.string().optional(),
  logoUris: z.array(z.lazy(() => ClientUpdateApiLogoUrisResponse$inboundSchema))
    .optional(),
  contacts: z.array(z.string()).optional(),
  tlsClientCertificateBoundAccessTokens: z.boolean().optional(),
  dynamicallyRegistered: z.boolean().optional(),
  softwareId: z.string().optional(),
  softwareVersion: z.string().optional(),
  registrationAccessTokenHash: z.string().optional(),
  createdAt: z.number().int().optional(),
  modifiedAt: z.number().int().optional(),
  grantTypes: z.array(ClientUpdateApiGrantTypeResponse$inboundSchema)
    .optional(),
  responseTypes: z.array(ClientUpdateApiResponseTypeResponse$inboundSchema)
    .optional(),
  redirectUris: z.array(z.string()).optional(),
  authorizationSignAlg:
    ClientUpdateApiAuthorizationSignAlgResponse$inboundSchema.optional(),
  authorizationEncryptionAlg:
    ClientUpdateApiAuthorizationEncryptionAlgResponse$inboundSchema.optional(),
  authorizationEncryptionEnc:
    ClientUpdateApiAuthorizationEncryptionEncResponse$inboundSchema.optional(),
  tokenAuthMethod: ClientUpdateApiTokenAuthMethodResponse$inboundSchema
    .optional(),
  tokenAuthSignAlg: ClientUpdateApiTokenAuthSignAlgResponse$inboundSchema
    .optional(),
  selfSignedCertificateKeyId: z.string().optional(),
  tlsClientAuthSubjectDn: z.string().optional(),
  tlsClientAuthSanDns: z.string().optional(),
  tlsClientAuthSanUri: z.string().optional(),
  tlsClientAuthSanIp: z.string().optional(),
  tlsClientAuthSanEmail: z.string().optional(),
  parRequired: z.boolean().optional(),
  requestObjectRequired: z.boolean().optional(),
  requestSignAlg: ClientUpdateApiRequestSignAlgResponse$inboundSchema
    .optional(),
  requestEncryptionAlg:
    ClientUpdateApiRequestEncryptionAlgResponse$inboundSchema.optional(),
  requestEncryptionEnc:
    ClientUpdateApiRequestEncryptionEncResponse$inboundSchema.optional(),
  requestUris: z.array(z.string()).optional(),
  defaultMaxAge: z.number().int().optional(),
  defaultAcrs: z.array(z.string()).optional(),
  idTokenSignAlg: ClientUpdateApiIdTokenSignAlgResponse$inboundSchema
    .optional(),
  idTokenEncryptionAlg:
    ClientUpdateApiIdTokenEncryptionAlgResponse$inboundSchema.optional(),
  idTokenEncryptionEnc:
    ClientUpdateApiIdTokenEncryptionEncResponse$inboundSchema.optional(),
  authTimeRequired: z.boolean().optional(),
  subjectType: ClientUpdateApiSubjectTypeResponse$inboundSchema.optional(),
  sectorIdentifierUri: z.string().optional(),
  derivedSectorIdentifier: z.string().optional(),
  jwksUri: z.string().optional(),
  jwks: z.string().optional(),
  userInfoSignAlg: ClientUpdateApiUserInfoSignAlgResponse$inboundSchema
    .optional(),
  userInfoEncryptionAlg:
    ClientUpdateApiUserInfoEncryptionAlgResponse$inboundSchema.optional(),
  userInfoEncryptionEnc:
    ClientUpdateApiUserInfoEncryptionEncResponse$inboundSchema.optional(),
  loginUri: z.string().optional(),
  tosUri: z.string().optional(),
  tosUris: z.array(z.lazy(() => ClientUpdateApiTosUrisResponse$inboundSchema))
    .optional(),
  policyUri: z.string().optional(),
  policyUris: z.array(
    z.lazy(() => ClientUpdateApiPolicyUrisResponse$inboundSchema),
  ).optional(),
  clientUri: z.string().optional(),
  clientUris: z.array(
    z.lazy(() => ClientUpdateApiClientUrisResponse$inboundSchema),
  ).optional(),
  bcDeliveryMode: z.string().optional(),
  bcNotificationEndpoint: z.string().optional(),
  bcRequestSignAlg: ClientUpdateApiBcRequestSignAlgResponse$inboundSchema
    .optional(),
  bcUserCodeRequired: z.boolean().optional(),
  attributes: z.array(
    z.lazy(() => ClientUpdateApiAttributeResponse$inboundSchema),
  ).optional(),
  extension: z.lazy(() => ClientUpdateApiExtensionResponse$inboundSchema)
    .optional(),
  authorizationDetailsTypes: z.array(z.string()).optional(),
  customMetadata: z.string().optional(),
  frontChannelRequestObjectEncryptionRequired: z.boolean().optional(),
  requestObjectEncryptionAlgMatchRequired: z.boolean().optional(),
  requestObjectEncryptionEncMatchRequired: z.boolean().optional(),
  digestAlgorithm: z.string().optional(),
  singleAccessTokenPerSubject: z.boolean().optional(),
  pkceRequired: z.boolean().optional(),
  pkceS256Required: z.boolean().optional(),
  dpopRequired: z.boolean().optional(),
  automaticallyRegistered: z.boolean().optional(),
  explicitlyRegistered: z.boolean().optional(),
  rsRequestSigned: z.boolean().optional(),
  rsSignedRequestKeyId: z.string().optional(),
  clientRegistrationTypes: z.array(
    ClientUpdateApiClientRegistrationTypeResponse$inboundSchema,
  ).optional(),
  organizationName: z.string().optional(),
  signedJwksUri: z.string().optional(),
  entityId: z.string().optional(),
  trustAnchorId: z.string().optional(),
  trustChain: z.array(z.string()).optional(),
  trustChainExpiresAt: z.number().int().optional(),
  trustChainUpdatedAt: z.number().int().optional(),
  locked: z.boolean().optional(),
  credentialOfferEndpoint: z.string().optional(),
  fapiModes: z.array(ClientUpdateApiFapiModeResponse$inboundSchema).optional(),
  responseModes: z.array(ClientUpdateApiResponseModeResponse$inboundSchema)
    .optional(),
  credentialResponseEncryptionRequired: z.boolean().optional(),
});

/** @internal */
export type ClientUpdateApiResponse$Outbound = {
  number?: number | undefined;
  serviceNumber?: number | undefined;
  clientName?: string | undefined;
  clientNames?: Array<ClientUpdateApiClientNameResponse$Outbound> | undefined;
  description?: string | undefined;
  descriptions?: Array<ClientUpdateApiDescriptionResponse$Outbound> | undefined;
  clientId?: number | undefined;
  clientSecret?: string | undefined;
  clientIdAlias?: string | undefined;
  clientIdAliasEnabled?: boolean | undefined;
  clientType?: string | undefined;
  applicationType?: string | undefined;
  logoUri?: string | undefined;
  logoUris?: Array<ClientUpdateApiLogoUrisResponse$Outbound> | undefined;
  contacts?: Array<string> | undefined;
  tlsClientCertificateBoundAccessTokens?: boolean | undefined;
  dynamicallyRegistered?: boolean | undefined;
  softwareId?: string | undefined;
  softwareVersion?: string | undefined;
  registrationAccessTokenHash?: string | undefined;
  createdAt?: number | undefined;
  modifiedAt?: number | undefined;
  grantTypes?: Array<string> | undefined;
  responseTypes?: Array<string> | undefined;
  redirectUris?: Array<string> | undefined;
  authorizationSignAlg?: string | undefined;
  authorizationEncryptionAlg?: string | undefined;
  authorizationEncryptionEnc?: string | undefined;
  tokenAuthMethod?: string | undefined;
  tokenAuthSignAlg?: string | undefined;
  selfSignedCertificateKeyId?: string | undefined;
  tlsClientAuthSubjectDn?: string | undefined;
  tlsClientAuthSanDns?: string | undefined;
  tlsClientAuthSanUri?: string | undefined;
  tlsClientAuthSanIp?: string | undefined;
  tlsClientAuthSanEmail?: string | undefined;
  parRequired?: boolean | undefined;
  requestObjectRequired?: boolean | undefined;
  requestSignAlg?: string | undefined;
  requestEncryptionAlg?: string | undefined;
  requestEncryptionEnc?: string | undefined;
  requestUris?: Array<string> | undefined;
  defaultMaxAge?: number | undefined;
  defaultAcrs?: Array<string> | undefined;
  idTokenSignAlg?: string | undefined;
  idTokenEncryptionAlg?: string | undefined;
  idTokenEncryptionEnc?: string | undefined;
  authTimeRequired?: boolean | undefined;
  subjectType?: string | undefined;
  sectorIdentifierUri?: string | undefined;
  derivedSectorIdentifier?: string | undefined;
  jwksUri?: string | undefined;
  jwks?: string | undefined;
  userInfoSignAlg?: string | undefined;
  userInfoEncryptionAlg?: string | undefined;
  userInfoEncryptionEnc?: string | undefined;
  loginUri?: string | undefined;
  tosUri?: string | undefined;
  tosUris?: Array<ClientUpdateApiTosUrisResponse$Outbound> | undefined;
  policyUri?: string | undefined;
  policyUris?: Array<ClientUpdateApiPolicyUrisResponse$Outbound> | undefined;
  clientUri?: string | undefined;
  clientUris?: Array<ClientUpdateApiClientUrisResponse$Outbound> | undefined;
  bcDeliveryMode?: string | undefined;
  bcNotificationEndpoint?: string | undefined;
  bcRequestSignAlg?: string | undefined;
  bcUserCodeRequired?: boolean | undefined;
  attributes?: Array<ClientUpdateApiAttributeResponse$Outbound> | undefined;
  extension?: ClientUpdateApiExtensionResponse$Outbound | undefined;
  authorizationDetailsTypes?: Array<string> | undefined;
  customMetadata?: string | undefined;
  frontChannelRequestObjectEncryptionRequired?: boolean | undefined;
  requestObjectEncryptionAlgMatchRequired?: boolean | undefined;
  requestObjectEncryptionEncMatchRequired?: boolean | undefined;
  digestAlgorithm?: string | undefined;
  singleAccessTokenPerSubject?: boolean | undefined;
  pkceRequired?: boolean | undefined;
  pkceS256Required?: boolean | undefined;
  dpopRequired?: boolean | undefined;
  automaticallyRegistered?: boolean | undefined;
  explicitlyRegistered?: boolean | undefined;
  rsRequestSigned?: boolean | undefined;
  rsSignedRequestKeyId?: string | undefined;
  clientRegistrationTypes?: Array<string> | undefined;
  organizationName?: string | undefined;
  signedJwksUri?: string | undefined;
  entityId?: string | undefined;
  trustAnchorId?: string | undefined;
  trustChain?: Array<string> | undefined;
  trustChainExpiresAt?: number | undefined;
  trustChainUpdatedAt?: number | undefined;
  locked?: boolean | undefined;
  credentialOfferEndpoint?: string | undefined;
  fapiModes?: Array<string> | undefined;
  responseModes?: Array<string> | undefined;
  credentialResponseEncryptionRequired?: boolean | undefined;
};

/** @internal */
export const ClientUpdateApiResponse$outboundSchema: z.ZodType<
  ClientUpdateApiResponse$Outbound,
  z.ZodTypeDef,
  ClientUpdateApiResponse
> = z.object({
  number: z.number().int().optional(),
  serviceNumber: z.number().int().optional(),
  clientName: z.string().optional(),
  clientNames: z.array(
    z.lazy(() => ClientUpdateApiClientNameResponse$outboundSchema),
  ).optional(),
  description: z.string().optional(),
  descriptions: z.array(
    z.lazy(() => ClientUpdateApiDescriptionResponse$outboundSchema),
  ).optional(),
  clientId: z.number().int().optional(),
  clientSecret: z.string().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasEnabled: z.boolean().optional(),
  clientType: ClientUpdateApiClientTypeResponse$outboundSchema.optional(),
  applicationType: ClientUpdateApiApplicationTypeResponse$outboundSchema
    .optional(),
  logoUri: z.string().optional(),
  logoUris: z.array(
    z.lazy(() => ClientUpdateApiLogoUrisResponse$outboundSchema),
  ).optional(),
  contacts: z.array(z.string()).optional(),
  tlsClientCertificateBoundAccessTokens: z.boolean().optional(),
  dynamicallyRegistered: z.boolean().optional(),
  softwareId: z.string().optional(),
  softwareVersion: z.string().optional(),
  registrationAccessTokenHash: z.string().optional(),
  createdAt: z.number().int().optional(),
  modifiedAt: z.number().int().optional(),
  grantTypes: z.array(ClientUpdateApiGrantTypeResponse$outboundSchema)
    .optional(),
  responseTypes: z.array(ClientUpdateApiResponseTypeResponse$outboundSchema)
    .optional(),
  redirectUris: z.array(z.string()).optional(),
  authorizationSignAlg:
    ClientUpdateApiAuthorizationSignAlgResponse$outboundSchema.optional(),
  authorizationEncryptionAlg:
    ClientUpdateApiAuthorizationEncryptionAlgResponse$outboundSchema.optional(),
  authorizationEncryptionEnc:
    ClientUpdateApiAuthorizationEncryptionEncResponse$outboundSchema.optional(),
  tokenAuthMethod: ClientUpdateApiTokenAuthMethodResponse$outboundSchema
    .optional(),
  tokenAuthSignAlg: ClientUpdateApiTokenAuthSignAlgResponse$outboundSchema
    .optional(),
  selfSignedCertificateKeyId: z.string().optional(),
  tlsClientAuthSubjectDn: z.string().optional(),
  tlsClientAuthSanDns: z.string().optional(),
  tlsClientAuthSanUri: z.string().optional(),
  tlsClientAuthSanIp: z.string().optional(),
  tlsClientAuthSanEmail: z.string().optional(),
  parRequired: z.boolean().optional(),
  requestObjectRequired: z.boolean().optional(),
  requestSignAlg: ClientUpdateApiRequestSignAlgResponse$outboundSchema
    .optional(),
  requestEncryptionAlg:
    ClientUpdateApiRequestEncryptionAlgResponse$outboundSchema.optional(),
  requestEncryptionEnc:
    ClientUpdateApiRequestEncryptionEncResponse$outboundSchema.optional(),
  requestUris: z.array(z.string()).optional(),
  defaultMaxAge: z.number().int().optional(),
  defaultAcrs: z.array(z.string()).optional(),
  idTokenSignAlg: ClientUpdateApiIdTokenSignAlgResponse$outboundSchema
    .optional(),
  idTokenEncryptionAlg:
    ClientUpdateApiIdTokenEncryptionAlgResponse$outboundSchema.optional(),
  idTokenEncryptionEnc:
    ClientUpdateApiIdTokenEncryptionEncResponse$outboundSchema.optional(),
  authTimeRequired: z.boolean().optional(),
  subjectType: ClientUpdateApiSubjectTypeResponse$outboundSchema.optional(),
  sectorIdentifierUri: z.string().optional(),
  derivedSectorIdentifier: z.string().optional(),
  jwksUri: z.string().optional(),
  jwks: z.string().optional(),
  userInfoSignAlg: ClientUpdateApiUserInfoSignAlgResponse$outboundSchema
    .optional(),
  userInfoEncryptionAlg:
    ClientUpdateApiUserInfoEncryptionAlgResponse$outboundSchema.optional(),
  userInfoEncryptionEnc:
    ClientUpdateApiUserInfoEncryptionEncResponse$outboundSchema.optional(),
  loginUri: z.string().optional(),
  tosUri: z.string().optional(),
  tosUris: z.array(z.lazy(() => ClientUpdateApiTosUrisResponse$outboundSchema))
    .optional(),
  policyUri: z.string().optional(),
  policyUris: z.array(
    z.lazy(() => ClientUpdateApiPolicyUrisResponse$outboundSchema),
  ).optional(),
  clientUri: z.string().optional(),
  clientUris: z.array(
    z.lazy(() => ClientUpdateApiClientUrisResponse$outboundSchema),
  ).optional(),
  bcDeliveryMode: z.string().optional(),
  bcNotificationEndpoint: z.string().optional(),
  bcRequestSignAlg: ClientUpdateApiBcRequestSignAlgResponse$outboundSchema
    .optional(),
  bcUserCodeRequired: z.boolean().optional(),
  attributes: z.array(
    z.lazy(() => ClientUpdateApiAttributeResponse$outboundSchema),
  ).optional(),
  extension: z.lazy(() => ClientUpdateApiExtensionResponse$outboundSchema)
    .optional(),
  authorizationDetailsTypes: z.array(z.string()).optional(),
  customMetadata: z.string().optional(),
  frontChannelRequestObjectEncryptionRequired: z.boolean().optional(),
  requestObjectEncryptionAlgMatchRequired: z.boolean().optional(),
  requestObjectEncryptionEncMatchRequired: z.boolean().optional(),
  digestAlgorithm: z.string().optional(),
  singleAccessTokenPerSubject: z.boolean().optional(),
  pkceRequired: z.boolean().optional(),
  pkceS256Required: z.boolean().optional(),
  dpopRequired: z.boolean().optional(),
  automaticallyRegistered: z.boolean().optional(),
  explicitlyRegistered: z.boolean().optional(),
  rsRequestSigned: z.boolean().optional(),
  rsSignedRequestKeyId: z.string().optional(),
  clientRegistrationTypes: z.array(
    ClientUpdateApiClientRegistrationTypeResponse$outboundSchema,
  ).optional(),
  organizationName: z.string().optional(),
  signedJwksUri: z.string().optional(),
  entityId: z.string().optional(),
  trustAnchorId: z.string().optional(),
  trustChain: z.array(z.string()).optional(),
  trustChainExpiresAt: z.number().int().optional(),
  trustChainUpdatedAt: z.number().int().optional(),
  locked: z.boolean().optional(),
  credentialOfferEndpoint: z.string().optional(),
  fapiModes: z.array(ClientUpdateApiFapiModeResponse$outboundSchema).optional(),
  responseModes: z.array(ClientUpdateApiResponseModeResponse$outboundSchema)
    .optional(),
  credentialResponseEncryptionRequired: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ClientUpdateApiResponse$ {
  /** @deprecated use `ClientUpdateApiResponse$inboundSchema` instead. */
  export const inboundSchema = ClientUpdateApiResponse$inboundSchema;
  /** @deprecated use `ClientUpdateApiResponse$outboundSchema` instead. */
  export const outboundSchema = ClientUpdateApiResponse$outboundSchema;
  /** @deprecated use `ClientUpdateApiResponse$Outbound` instead. */
  export type Outbound = ClientUpdateApiResponse$Outbound;
}

export function clientUpdateApiResponseToJSON(
  clientUpdateApiResponse: ClientUpdateApiResponse,
): string {
  return JSON.stringify(
    ClientUpdateApiResponse$outboundSchema.parse(clientUpdateApiResponse),
  );
}

export function clientUpdateApiResponseFromJSON(
  jsonString: string,
): SafeParseResult<ClientUpdateApiResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientUpdateApiResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientUpdateApiResponse' from JSON`,
  );
}
