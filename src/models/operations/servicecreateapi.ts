/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const ServiceCreateApiServerList = [
  /**
   * ðŸ‡ºðŸ‡¸ US Cluster
   */
  "https://us.authlete.com",
  /**
   * ðŸ‡¯ðŸ‡µ Japan Cluster
   */
  "https://jp.authlete.com",
  /**
   * ðŸ‡ªðŸ‡º Europe Cluster
   */
  "https://eu.authlete.com",
  /**
   * ðŸ‡§ðŸ‡· Brazil Cluster
   */
  "https://br.authlete.com",
] as const;

export type ServiceCreateApiMetadatumRequest = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export const ServiceCreateApiSupportedGrantTypeRequest = {
  AuthorizationCode: "AUTHORIZATION_CODE",
  Implicit: "IMPLICIT",
  Password: "PASSWORD",
  ClientCredentials: "CLIENT_CREDENTIALS",
  RefreshToken: "REFRESH_TOKEN",
  Ciba: "CIBA",
  DeviceCode: "DEVICE_CODE",
  TokenExchange: "TOKEN_EXCHANGE",
  JwtBearer: "JWT_BEARER",
} as const;
/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export type ServiceCreateApiSupportedGrantTypeRequest = ClosedEnum<
  typeof ServiceCreateApiSupportedGrantTypeRequest
>;

export const ServiceCreateApiSupportedResponseTypeRequest = {
  None: "NONE",
  Code: "CODE",
  Token: "TOKEN",
  IdToken: "ID_TOKEN",
  CodeToken: "CODE_TOKEN",
  CodeIdToken: "CODE_ID_TOKEN",
  IdTokenToken: "ID_TOKEN_TOKEN",
  CodeIdTokenToken: "CODE_ID_TOKEN_TOKEN",
} as const;
export type ServiceCreateApiSupportedResponseTypeRequest = ClosedEnum<
  typeof ServiceCreateApiSupportedResponseTypeRequest
>;

export const ServiceCreateApiSupportedServiceProfileRequest = {
  Fapi: "FAPI",
  OpenBanking: "OPEN_BANKING",
} as const;
export type ServiceCreateApiSupportedServiceProfileRequest = ClosedEnum<
  typeof ServiceCreateApiSupportedServiceProfileRequest
>;

/**
 * The display mode which the client application requests by `display` request parameter.
 *
 * @remarks
 * When the authorization request does not have `display` request parameter, `PAGE` is set as the default value.
 *
 * It is ensured that the value of `display` is one of the supported display modes which are specified
 * by `supportedDisplays` configuration parameter of the service. If the display mode specified by the
 * authorization request is not supported, an error is raised.
 *
 * Values for this property correspond to the values listed in
 * "[OpenID Connect Core 1.0, 3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest), display".
 */
export const ServiceCreateApiSupportedDisplayRequest = {
  Page: "PAGE",
  Popup: "POPUP",
  Touch: "TOUCH",
  Wap: "WAP",
} as const;
/**
 * The display mode which the client application requests by `display` request parameter.
 *
 * @remarks
 * When the authorization request does not have `display` request parameter, `PAGE` is set as the default value.
 *
 * It is ensured that the value of `display` is one of the supported display modes which are specified
 * by `supportedDisplays` configuration parameter of the service. If the display mode specified by the
 * authorization request is not supported, an error is raised.
 *
 * Values for this property correspond to the values listed in
 * "[OpenID Connect Core 1.0, 3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest), display".
 */
export type ServiceCreateApiSupportedDisplayRequest = ClosedEnum<
  typeof ServiceCreateApiSupportedDisplayRequest
>;

/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export const ServiceCreateApiSupportedTokenAuthMethodRequest = {
  None: "NONE",
  ClientSecretBasic: "CLIENT_SECRET_BASIC",
  ClientSecretPost: "CLIENT_SECRET_POST",
  ClientSecretJwt: "CLIENT_SECRET_JWT",
  PrivateKeyJwt: "PRIVATE_KEY_JWT",
  TlsClientAuth: "TLS_CLIENT_AUTH",
  SelfSignedTlsClientAuth: "SELF_SIGNED_TLS_CLIENT_AUTH",
} as const;
/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export type ServiceCreateApiSupportedTokenAuthMethodRequest = ClosedEnum<
  typeof ServiceCreateApiSupportedTokenAuthMethodRequest
>;

/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export const ServiceCreateApiSupportedRevocationAuthMethodRequest = {
  None: "NONE",
  ClientSecretBasic: "CLIENT_SECRET_BASIC",
  ClientSecretPost: "CLIENT_SECRET_POST",
  ClientSecretJwt: "CLIENT_SECRET_JWT",
  PrivateKeyJwt: "PRIVATE_KEY_JWT",
  TlsClientAuth: "TLS_CLIENT_AUTH",
  SelfSignedTlsClientAuth: "SELF_SIGNED_TLS_CLIENT_AUTH",
} as const;
/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export type ServiceCreateApiSupportedRevocationAuthMethodRequest = ClosedEnum<
  typeof ServiceCreateApiSupportedRevocationAuthMethodRequest
>;

/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export const ServiceCreateApiSupportedIntrospectionAuthMethodRequest = {
  None: "NONE",
  ClientSecretBasic: "CLIENT_SECRET_BASIC",
  ClientSecretPost: "CLIENT_SECRET_POST",
  ClientSecretJwt: "CLIENT_SECRET_JWT",
  PrivateKeyJwt: "PRIVATE_KEY_JWT",
  TlsClientAuth: "TLS_CLIENT_AUTH",
  SelfSignedTlsClientAuth: "SELF_SIGNED_TLS_CLIENT_AUTH",
} as const;
/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export type ServiceCreateApiSupportedIntrospectionAuthMethodRequest =
  ClosedEnum<typeof ServiceCreateApiSupportedIntrospectionAuthMethodRequest>;

export type ServiceCreateApiMtlsEndpointAliasRequest = {
  name?: string | undefined;
  uri?: string | undefined;
};

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ServiceCreateApiAccessTokenSignAlgRequest = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ServiceCreateApiAccessTokenSignAlgRequest = ClosedEnum<
  typeof ServiceCreateApiAccessTokenSignAlgRequest
>;

export type ServiceCreateApiDescriptionRequest = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ServiceCreateApiSupportedScopeAttributeRequest = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ServiceCreateApiSupportedScopeRequest = {
  /**
   * The name of the scope.
   */
  name?: string | undefined;
  /**
   * `true` to mark the scope as default. Scopes marked as default are regarded as requested when an authorization request from a client application does not contain scope request parameter.
   */
  defaultEntry?: boolean | undefined;
  /**
   * The description about the scope.
   */
  description?: string | undefined;
  /**
   * The descriptions about this scope in multiple languages.
   */
  descriptions?: Array<ServiceCreateApiDescriptionRequest> | undefined;
  /**
   * The attributes of the scope.
   */
  attributes?:
    | Array<ServiceCreateApiSupportedScopeAttributeRequest>
    | undefined;
};

export const ServiceCreateApiSupportedClaimTypeRequest = {
  Normal: "NORMAL",
  Aggregated: "AGGREGATED",
  Distributed: "DISTRIBUTED",
} as const;
export type ServiceCreateApiSupportedClaimTypeRequest = ClosedEnum<
  typeof ServiceCreateApiSupportedClaimTypeRequest
>;

export const ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest = {
  Ping: "PING",
  Poll: "POLL",
  Push: "PUSH",
} as const;
export type ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest =
  ClosedEnum<
    typeof ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest
  >;

/**
 * The character set for end-user verification codes (`user_code`) for Device Flow.
 *
 * @remarks
 */
export const ServiceCreateApiUserCodeCharsetRequest = {
  Base20: "BASE20",
  Numeric: "NUMERIC",
} as const;
/**
 * The character set for end-user verification codes (`user_code`) for Device Flow.
 *
 * @remarks
 */
export type ServiceCreateApiUserCodeCharsetRequest = ClosedEnum<
  typeof ServiceCreateApiUserCodeCharsetRequest
>;

/**
 * OIDC4IDA / verifiedClaimsValidationSchemaSet
 *
 * @remarks
 */
export const ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest = {
  Standard: "standard",
  StandardPlusIdDocument: "standard+id_document",
} as const;
/**
 * OIDC4IDA / verifiedClaimsValidationSchemaSet
 *
 * @remarks
 */
export type ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest =
  ClosedEnum<typeof ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest>;

export type ServiceCreateApiAttributeRequest = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * Holds information about a key managed in an HSM (Hardware Security Module)
 *
 * @remarks
 */
export type ServiceCreateApiHskRequest = {
  /**
   * The key type (EC or RSA)
   *
   * @remarks
   */
  kty?: string | undefined;
  /**
   * Get the use of the key on the HSM.
   *
   * @remarks
   * When the key use is "sig" (signature), the private key on the HSM is used to sign data and the corresponding public key is used to verify the signature.
   * When the key use is "enc" (encryption), the private key on the HSM is used to decrypt encrypted data which have been encrypted with the corresponding public key
   */
  use?: string | undefined;
  /**
   * Key ID for the key on the HSM.
   *
   * @remarks
   */
  kid?: string | undefined;
  /**
   * The name of the HSM.
   *
   * @remarks
   * The identifier for the HSM that sits behind the Authlete server. For example, "google".
   */
  hsmName?: string | undefined;
  /**
   * The handle for the key on the HSM.
   *
   * @remarks
   * A handle is a base64url-encoded 256-bit random value (43 letters) which is assigned by Authlete on the call of the /api/hsk/create API
   */
  handle?: string | undefined;
  /**
   * The public key that corresponds to the key on the HSM.
   *
   * @remarks
   */
  publicKey?: string | undefined;
};

/**
 * Supported attachment types. This property corresponds to the `attachments_supported`
 *
 * @remarks
 *  server metadata which was added by the third implementer's draft of OpenID Connect
 *  for Identity Assurance 1.0.
 */
export const ServiceCreateApiSupportedAttachmentRequest = {
  Embedded: "EMBEDDED",
  External: "EXTERNAL",
} as const;
/**
 * Supported attachment types. This property corresponds to the `attachments_supported`
 *
 * @remarks
 *  server metadata which was added by the third implementer's draft of OpenID Connect
 *  for Identity Assurance 1.0.
 */
export type ServiceCreateApiSupportedAttachmentRequest = ClosedEnum<
  typeof ServiceCreateApiSupportedAttachmentRequest
>;

/**
 * Values for the `client_registration_types` RP metadata and the
 *
 * @remarks
 *  `client_registration_types_supported` OP metadata that are defined in
 *  [OpenID Connect Federation 1.0](https://openid.net/specs/openid-connect-federation-1_0.html).
 */
export const ServiceCreateApiSupportedClientRegistrationTypeRequest = {
  Automatic: "AUTOMATIC",
  Explicit: "EXPLICIT",
} as const;
/**
 * Values for the `client_registration_types` RP metadata and the
 *
 * @remarks
 *  `client_registration_types_supported` OP metadata that are defined in
 *  [OpenID Connect Federation 1.0](https://openid.net/specs/openid-connect-federation-1_0.html).
 */
export type ServiceCreateApiSupportedClientRegistrationTypeRequest = ClosedEnum<
  typeof ServiceCreateApiSupportedClientRegistrationTypeRequest
>;

export type ServiceCreateApiTrustAnchorRequest = {
  /**
   * the entity ID of the trust anchor
   *
   * @remarks
   */
  entityId?: string | undefined;
  /**
   * the JWK Set document containing public keys of the trust anchor
   *
   * @remarks
   */
  jwks?: string | undefined;
};

/**
 * The prompt that the UI displayed to the end-user must satisfy as the minimum level. This value comes from `prompt` request parameter.
 *
 * @remarks
 *
 * When the authorization request does not contain `prompt` request parameter, `CONSENT` is used as the default value.
 *
 * See "[OpenID Connect Core 1.0, 3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest), prompt" for `prompt` request parameter.
 */
export const ServiceCreateApiSupportedPromptValueRequest = {
  None: "NONE",
  Login: "LOGIN",
  Consent: "CONSENT",
  SelectAccount: "SELECT_ACCOUNT",
} as const;
/**
 * The prompt that the UI displayed to the end-user must satisfy as the minimum level. This value comes from `prompt` request parameter.
 *
 * @remarks
 *
 * When the authorization request does not contain `prompt` request parameter, `CONSENT` is used as the default value.
 *
 * See "[OpenID Connect Core 1.0, 3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest), prompt" for `prompt` request parameter.
 */
export type ServiceCreateApiSupportedPromptValueRequest = ClosedEnum<
  typeof ServiceCreateApiSupportedPromptValueRequest
>;

export const ServiceCreateApiFapiModeRequest = {
  Fapi1Advanced: "FAPI1_ADVANCED",
  Fapi1Baseline: "FAPI1_BASELINE",
  Fapi2MessageSigningAuthReq: "FAPI2_MESSAGE_SIGNING_AUTH_REQ",
  Fapi2MessageSigningAuthRes: "FAPI2_MESSAGE_SIGNING_AUTH_RES",
  Fapi2MessageSigningIntrospectionRes:
    "FAPI2_MESSAGE_SIGNING_INTROSPECTION_RES",
  Fapi2Security: "FAPI2_SECURITY",
} as const;
export type ServiceCreateApiFapiModeRequest = ClosedEnum<
  typeof ServiceCreateApiFapiModeRequest
>;

export type ServiceCreateApiCredentialIssuerMetadataRequest = {
  /**
   * The identifier of a credential request.
   */
  credentialIssuer?: string | undefined;
  /**
   * The identifier of the authorization server that the credential issuer
   *
   * @remarks
   * relies on for authorization.
   */
  authorizationServer?: string | undefined;
  /**
   * The URL of the credential endpoint of the credential issuer.
   */
  credentialEndpoint?: boolean | undefined;
  /**
   * The URL of the batch credential endpoint of the credential issuer.
   */
  batchCredentialEndpoint?: number | undefined;
  /**
   * The URL of the deferred credential endpoint of the credential issuer.
   */
  deferredCredentialEndpoint?: string | undefined;
  /**
   * A JSON array describing supported credentials.
   */
  credentialsSupported?: boolean | undefined;
};

export type ServiceCreateApiRequest = {
  /**
   * The name of this service.
   */
  serviceName?: string | undefined;
  /**
   * The issuer identifier of the service.
   *
   * @remarks
   *
   * A URL that starts with  https:// and has no query or fragment component.
   *
   * The value of this property is used as `iss` claim in an [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)
   * and `issuer` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  issuer?: string | undefined;
  /**
   * The description about the service.
   */
  description?: string | undefined;
  /**
   * Deprecated. Always `true`.
   */
  clientIdAliasEnabled?: boolean | undefined;
  /**
   * The `metadata` of the service. The content of the returned array depends on contexts.
   *
   * @remarks
   * The predefined service metadata is listed in the following table.
   *
   *   | Key | Description |
   *   | --- | --- |
   *   | `clientCount` | The number of client applications which belong to this service.  |
   */
  metadata?: Array<ServiceCreateApiMetadatumRequest> | undefined;
  /**
   * A Web API endpoint for user authentication which is to be prepared on the service side.
   *
   * @remarks
   *
   * The endpoint must be implemented if you do not implement the UI at the authorization endpoint
   * but use the one provided by Authlete.
   *
   * The user authentication at the authorization endpoint provided by Authlete is performed by making
   * a `POST` request to this endpoint.
   */
  authenticationCallbackEndpoint?: string | undefined;
  /**
   * API key for basic authentication at the authentication callback endpoint.
   *
   * @remarks
   *
   * If the value is not empty, Authlete generates Authorization header for Basic authentication when
   * making a request to the authentication callback endpoint.
   */
  authenticationCallbackApiKey?: string | undefined;
  /**
   * API secret for `basic` authentication at the authentication callback endpoint.
   */
  authenticationCallbackApiSecret?: string | undefined;
  /**
   * Values of `grant_type` request parameter that the service supports.
   *
   * @remarks
   *
   * The value of this property is used as `grant_types_supported property` in the
   * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedGrantTypes?:
    | Array<ServiceCreateApiSupportedGrantTypeRequest>
    | undefined;
  /**
   * Values of `response_type` request parameter that
   *
   * @remarks
   * the service supports. Valid values are listed in Response Type.
   *
   * The value of this property is used as `response_types_supported` property in the
   * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedResponseTypes?:
    | Array<ServiceCreateApiSupportedResponseTypeRequest>
    | undefined;
  /**
   * The supported data types that can be used as values of the type field in `authorization_details`.
   *
   * @remarks
   *
   * This property corresponds to the `authorization_details_types_supported` metadata. See "OAuth 2.0
   * Rich Authorization Requests" (RAR) for details.
   */
  supportedAuthorizationDetailsTypes?: Array<string> | undefined;
  /**
   * The profiles that this service supports.
   *
   * @remarks
   */
  supportedServiceProfiles?:
    | Array<ServiceCreateApiSupportedServiceProfileRequest>
    | undefined;
  /**
   * The flag to indicate whether the `error_description` response parameter is omitted.
   *
   * @remarks
   *
   * According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include
   * the `error_description` response parameter in error responses.
   *
   * If `true`, Authlete does not embed the `error_description` response parameter in error responses.
   */
  errorDescriptionOmitted?: boolean | undefined;
  /**
   * The flag to indicate whether the `error_uri` response parameter is omitted.
   *
   * @remarks
   *
   * According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include the `error_uri` response parameter in error responses.
   *
   * If `true`, Authlete does not embed the
   * `error_uri` response parameter in error responses.
   */
  errorUriOmitted?: boolean | undefined;
  /**
   * The authorization endpoint of the service.
   *
   * @remarks
   *
   * A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/authorization`.
   *
   * The value of this property is used as `authorization_endpoint` property in the [OpenID Provider
   * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  authorizationEndpoint?: string | undefined;
  /**
   * The flag to indicate whether the direct authorization endpoint is enabled or not.
   *
   * @remarks
   *
   * The path of the endpoint is `/api/auth/authorization/direct/service-api-key`.
   */
  directAuthorizationEndpointEnabled?: boolean | undefined;
  /**
   * UI locales that the service supports.
   *
   * @remarks
   *
   * Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646). For example, `en-US` and `ja-JP`.
   *
   * The value of this property is used as `ui_locales_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedUiLocales?: Array<string> | undefined;
  /**
   * Values of `display` request parameter that service supports.
   *
   * @remarks
   *
   * The value of this property is used as `display_values_supported` property in the Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedDisplays?:
    | Array<ServiceCreateApiSupportedDisplayRequest>
    | undefined;
  /**
   * The flag to indicate whether the use of Proof Key for Code Exchange (PKCE) is always required for authorization requests by Authorization Code Flow.
   *
   * @remarks
   *
   * If `true`, `code_challenge` request parameter is always required for authorization requests using Authorization Code Flow.
   *
   * See [RFC 7636](https://tools.ietf.org/html/rfc7636) (Proof Key for Code Exchange by OAuth Public Clients) for details about `code_challenge` request parameter.
   */
  pkceRequired?: boolean | undefined;
  /**
   * The flag to indicate whether `S256` is always required as the code challenge method whenever [PKCE (RFC 7636)](https://tools.ietf.org/html/rfc7636) is used.
   *
   * @remarks
   *
   * If this flag is set to `true`, `code_challenge_method=S256` must be included in the authorization request
   * whenever it includes the `code_challenge` request parameter.
   * Neither omission of the `code_challenge_method` request parameter nor use of plain (`code_challenge_method=plain`) is allowed.
   */
  pkceS256Required?: boolean | undefined;
  /**
   * The duration of authorization response JWTs in seconds.
   *
   * @remarks
   *
   * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
   * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
   * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
   * from the authorization endpoint will be packed into a JWT. This property is used to compute the
   * value of the `exp` claim of the JWT.
   */
  authorizationResponseDuration?: number | undefined;
  /**
   * The [token endpoint](https://tools.ietf.org/html/rfc6749#section-3.2) of the service.
   *
   * @remarks
   *
   * A URL that starts with `https://` and has not fragment component. For example, `https://example.com/auth/token`.
   *
   * The value of this property is used as `token_endpoint` property in the
   * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  tokenEndpoint?: string | undefined;
  /**
   * The flag to indicate whether the direct token endpoint is enabled or not. The path of the endpoint
   *
   * @remarks
   * is `/api/auth/token/direct/service-api-key`.
   */
  directTokenEndpointEnabled?: boolean | undefined;
  /**
   * Client authentication methods supported by the token endpoint of the service.
   *
   * @remarks
   *
   * The value of this property is used as `token_endpoint_auth_methods_supports` property in the
   * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedTokenAuthMethods?:
    | Array<ServiceCreateApiSupportedTokenAuthMethodRequest>
    | undefined;
  /**
   * The flag to indicate token requests from public clients without the `client_id` request parameter are allowed when the client can be guessed from `authorization_code` or `refresh_token`.
   *
   * @remarks
   *
   * This flag should not be set unless you have special reasons.
   */
  missingClientIdAllowed?: boolean | undefined;
  /**
   * The [revocation endpoint](https://tools.ietf.org/html/rfc7009) of the service.
   *
   * @remarks
   *
   * A URL that starts with `https://`. For example, `https://example.com/auth/revocation`.
   */
  revocationEndpoint?: string | undefined;
  /**
   * The flag to indicate whether the direct revocation endpoint is enabled or not. The URL of the endpoint is `/api/auth/revocation/direct/service-api-key`.
   */
  directRevocationEndpointEnabled?: boolean | undefined;
  /**
   * Client authentication methods supported at the revocation endpoint.
   *
   * @remarks
   */
  supportedRevocationAuthMethods?:
    | Array<ServiceCreateApiSupportedRevocationAuthMethodRequest>
    | undefined;
  /**
   * The URI of the introspection endpoint.
   */
  introspectionEndpoint?: string | undefined;
  /**
   * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path of the endpoint is `/api/auth/userinfo/direct/{serviceApiKey}`.
   */
  directIntrospectionEndpointEnabled?: boolean | undefined;
  /**
   * Client authentication methods supported at the introspection endpoint.
   *
   * @remarks
   */
  supportedIntrospectionAuthMethods?:
    | Array<ServiceCreateApiSupportedIntrospectionAuthMethodRequest>
    | undefined;
  /**
   * The URI of the pushed authorization request endpoint.
   *
   * @remarks
   *
   * This property corresponds to the `pushed_authorization_request_endpoint` metadata defined in "[5. Authorization Server Metadata](https://tools.ietf.org/html/draft-lodderstedt-oauth-par#section-5)" of OAuth 2.0 Pushed Authorization Requests.
   */
  pushedAuthReqEndpoint?: string | undefined;
  /**
   * The duration of pushed authorization requests in seconds.
   *
   * @remarks
   *
   * [OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par)
   * defines an endpoint (called "pushed authorization request endpoint") which client applications
   * can register authorization requests into and get corresponding URIs (called "request URIs") from.
   * The issued URIs represent the registered authorization requests. The client applications can use
   * the URIs as the value of the `request_uri` request parameter in an authorization request.
   *
   * The property represents the duration of registered authorization requests and is used as the value
   * of the `expires_in` parameter in responses from the pushed authorization request endpoint.
   */
  pushedAuthReqDuration?: number | undefined;
  /**
   * The flag to indicate whether this service requires that clients use the pushed authorization
   *
   * @remarks
   * request endpoint.
   *
   * This property corresponds to the `require_pushed_authorization_requests` server metadata defined
   * in [OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par).
   */
  parRequired?: boolean | undefined;
  /**
   * The flag to indicate whether this service requires that authorization requests always utilize
   *
   * @remarks
   * a request object by using either request or `request_uri` request parameter.
   *
   * If this flag is set to `true` and the value of `traditionalRequestObjectProcessingApplied` is
   * `false`, the value of `require_signed_request_object` server metadata of this service is reported
   * as `true` in the discovery document. The metadata is defined in JAR (JWT Secured Authorization Request).
   * That `require_signed_request_object` is `true` means that authorization requests which don't
   * conform to the JAR specification are rejected.
   */
  requestObjectRequired?: boolean | undefined;
  /**
   * The flag to indicate whether a request object is processed based on rules defined in
   *
   * @remarks
   * [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) or JAR (JWT
   * Secured Authorization Request).
   *
   * Differences between rules in OpenID Connect Core 1.0 and ones in JAR are as follows.
   *   - JAR requires that a request object be always -signed.
   *   - JAR does not allow request parameters outside a request object to be referred to.
   *   - OIDC Core 1.0 requires that response_type request parameter exist outside a request object even if the request object includes the request parameter.
   *   - OIDC Core 1.0 requires that scope request parameter exist outside a request object if the authorization request is an
   *   - OIDC request even if the request object includes the request parameter.
   *
   * If this flag is set to `false` and the value of `requestObjectRequired` is `true`, the value of
   * `require_signed_request_object` server metadata of this service
   * is reported as `true` in the discovery document. The metadata is defined in JAR (JWT Secured
   * Authorization Request). That `require_signed_request_object` is `true` means that authorization
   * requests which don't conform to the JAR specification are rejected.
   */
  traditionalRequestObjectProcessingApplied?: boolean | undefined;
  /**
   * The flag to indicate whether this service validates certificate chains during PKI-based client mutual TLS authentication.
   *
   * @remarks
   */
  mutualTlsValidatePkiCertChain?: boolean | undefined;
  /**
   * The list of root certificates trusted by this service for PKI-based client mutual TLS authentication.
   *
   * @remarks
   */
  trustedRootCertificates?: Array<string> | undefined;
  /**
   * The MTLS endpoint aliases.
   *
   * @remarks
   *
   * This property corresponds to the mtls_endpoint_aliases metadata defined in "5. Metadata for Mutual TLS Endpoint Aliases" of [OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens](https://datatracker.ietf.org/doc/rfc8705/).
   *
   * The aliases will be embedded in the response from the discovery endpoint like the following.
   *
   * ```json
   * {
   *   ......,
   *   "mtls_endpoint_aliases": {
   *     "token_endpoint":         "https://mtls.example.com/token",
   *     "revocation_endpoint":    "https://mtls.example.com/revo",
   *     "introspection_endpoint": "https://mtls.example.com/introspect"
   *   }
   * }
   * ```
   */
  mtlsEndpointAliases?:
    | Array<ServiceCreateApiMtlsEndpointAliasRequest>
    | undefined;
  /**
   * The access token type.
   *
   * @remarks
   *
   * This value is used as the value of `token_type` property in access token responses. If this service
   * complies with [RFC 6750](https://tools.ietf.org/html/rfc6750), the value of this property should
   * be `Bearer`.
   *
   * See [RFC 6749 (OAuth 2.0), 7.1. Access Token Types](https://tools.ietf.org/html/rfc6749#section-7.1) for details.
   */
  accessTokenType?: string | undefined;
  /**
   * The flag to indicate whether this service supports issuing TLS client certificate bound access tokens.
   *
   * @remarks
   */
  tlsClientCertificateBoundAccessTokens?: boolean | undefined;
  /**
   * The duration of access tokens in seconds. This value is used as the value of `expires_in` property
   *
   * @remarks
   * in access token responses. `expires_in` is defined [RFC 6749, 5.1. Successful Response](https://tools.ietf.org/html/rfc6749#section-5.1).
   */
  accessTokenDuration?: number | undefined;
  /**
   * The flag to indicate whether the number of access tokens per subject (and per client) is at most one or can be more.
   *
   * @remarks
   *
   * If `true`, an attempt to issue a new access token invalidates existing access tokens that are associated with the same subject and the same client.
   *
   * Note that, however, attempts by [Client Credentials Flow](https://tools.ietf.org/html/rfc6749#section-4.4) do not invalidate existing access tokens because access tokens issued by Client Credentials Flow are not associated with any end-user's subject. Also note that an attempt by [Refresh Token Flow](https://tools.ietf.org/html/rfc6749#section-6) invalidates the coupled access token only and this invalidation is always performed regardless of whether the value of this setting item is `true` or `false`.
   */
  singleAccessTokenPerSubject?: boolean | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  accessTokenSignAlg?: ServiceCreateApiAccessTokenSignAlgRequest | undefined;
  /**
   * The key ID to identify a JWK used for signing access tokens.
   *
   * @remarks
   *
   * A JWK Set can be registered as a property of a service. A JWK Set can contain 0 or more JWKs.
   * Authlete Server has to pick up one JWK for signing from the JWK Set when it generates a JWT-based
   * access token. Authlete Server searches the registered JWK Set for a JWK which satisfies conditions
   * for access token signature. If the number of JWK candidates which satisfy the conditions is 1,
   * there is no problem. On the other hand, if there exist multiple candidates, a Key ID is needed
   * to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
   */
  accessTokenSignatureKeyId?: string | undefined;
  /**
   * The duration of refresh tokens in seconds. The related specifications have no requirements on refresh token duration, but Authlete sets expiration for refresh tokens.
   */
  refreshTokenDuration?: number | undefined;
  /**
   * The flag to indicate whether the remaining duration of the used refresh token is taken over to
   *
   * @remarks
   * the newly issued refresh token.
   */
  refreshTokenDurationKept?: boolean | undefined;
  /**
   * The flag which indicates whether duration of refresh tokens are reset when they are used even
   *
   * @remarks
   * if the `refreshTokenKept` property of this service set to is `true` (= even if "Refresh Token
   * Continuous Use" is "Kept").
   *
   * This flag has no effect when the `refreshTokenKept` property is set to `false`. In other words,
   * if this service issues a new refresh token on every refresh token request, the refresh token
   * will have fresh duration (unless `refreshTokenDurationKept` is set to `true`) and this
   * `refreshTokenDurationReset` property is not referenced.
   */
  refreshTokenDurationReset?: boolean | undefined;
  /**
   * The flag to indicate whether a refresh token remains unchanged or gets renewed after its use.
   *
   * @remarks
   *
   * If `true`, a refresh token used to get a new access token remains valid after its use. Otherwise, if `false`, a refresh token is invalidated after its use and a new refresh token is issued.
   *
   * See [RFC 6749 6. Refreshing an Access Token](https://tools.ietf.org/html/rfc6749#section-6), as to how to get a new access token using a refresh token.
   */
  refreshTokenKept?: boolean | undefined;
  /**
   * Scopes supported by the service.
   *
   * @remarks
   *
   * Authlete strongly recommends that the service register at least the following scopes.
   *
   * | Name | Description |
   * | --- | --- |
   * | openid | A permission to get an ID token of an end-user. The `openid` scope appears in [OpenID Connect Core 1.0, 3.1.2.1. Authentication Request, scope](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest). Without this scope, Authlete does not allow `response_type` request parameter to have values other than code and token. |
   * | profile | A permission to get information about `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale` and `updated_at` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
   * | email | A permission to get information about `email` and `email_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
   * | address | A permission to get information about address from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) and [5.1.1. Address Claim](https://openid.net/specs/openid-connect-core-1_0.html#AddressClaim) for details. |
   * | phone | A permission to get information about `phone_number` and `phone_number_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
   * | offline_access | A permission to get information from the user info endpoint even when the end-user is not present. See [OpenID Connect Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess) for details. |
   *
   * The value of this property is used as `scopes_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedScopes?: Array<ServiceCreateApiSupportedScopeRequest> | undefined;
  /**
   * The flag to indicate whether requests that request no scope are rejected or not.
   *
   * @remarks
   *
   * When a request has no explicit `scope` parameter and the service's pre-defined default scope set is empty,
   * the authorization server regards the request requests no scope. When this flag is set to `true`,
   * requests that request no scope are rejected.
   *
   * The requirement below excerpted from [RFC 6749 Section 3.3](https://tools.ietf.org/html/rfc6749#section-3.3)
   * does not explicitly mention the case where the default scope set is empty.
   *
   * > If the client omits the scope parameter when requesting authorization, the authorization server
   * MUST either process the request using a pre-defined default value or fail the request indicating an invalid scope.
   *
   * However, if you interpret *"the default scope set exists but is empty"* as *"the default scope set does not exist"*
   * and want to strictly conform to the requirement above, this flag has to be `true`.
   */
  scopeRequired?: boolean | undefined;
  /**
   * 'The duration of [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)s
   *
   * @remarks
   * in seconds. This value is used to calculate the value of `exp` claim in an ID token.'
   */
  idTokenDuration?: number | undefined;
  /**
   * The allowable clock skew between the server and clients in seconds.
   *
   * @remarks
   *
   * The clock skew is taken into consideration when time-related claims in a JWT (e.g. `exp`, `iat`, `nbf`) are verified.
   */
  allowableClockSkew?: number | undefined;
  /**
   * Claim types supported by the service. Valid values are listed in Claim Type. Note that Authlete
   *
   * @remarks
   * currently doesn't provide any API to help implementations for `AGGREGATED` and `DISTRIBUTED`.
   *
   * The value of this property is used as `claim_types_supported` property in the [OpenID Provider
   * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedClaimTypes?:
    | Array<ServiceCreateApiSupportedClaimTypeRequest>
    | undefined;
  /**
   * Claim locales that the service supports. Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646).
   *
   * @remarks
   * For example, `en-US` and `ja-JP`. See [OpenID Connect Core 1.0, 5.2. Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
   * for details.
   *
   * The value of this property is used as `claims_locales_supported` property in the
   * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedClaimLocales?: Array<string> | undefined;
  /**
   * Claim names that the service supports. The standard claim names listed in [OpenID Connect Core 1.0,
   *
   * @remarks
   * 5.1. Standard Claim](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) should
   * be supported. The following is the list of standard claims.
   *
   * - `sub`
   * - `name`
   * - `given_name`
   * - `family_name`
   * - `middle_name`
   * - `nickname`
   * - `preferred_username`
   * - `profile`
   * - `picture`
   * - `website`
   * - `email`
   * - `email_verified`
   * - `gender`
   * - `birthdate`
   * - `zoneinfo`
   * - `locale`
   * - `phone_number`
   * - `phone_number_verified`
   * - `address`
   * - `updated_at`
   *
   * The value of this property is used as `claims_supported` property in the [OpenID Provider
   * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   *
   * The service may support its original claim names. See [OpenID Connect Core 1.0, 5.1.2. Additional
   * Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims).
   */
  supportedClaims?: Array<string> | undefined;
  /**
   * The flag indicating whether claims specified by shortcut scopes (e.g. `profile`) are included
   *
   * @remarks
   * in the issued ID token only when no access token is issued.
   *
   * To strictly conform to the description below excerpted from [OpenID Connect Core 1.0 Section
   * 5.4](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims), this flag has to be `true`.
   *
   * > The Claims requested by the profile, email, address, and phone scope values are returned from
   * the UserInfo Endpoint, as described in Section 5.3.2, when a response_type value is used that
   * results in an Access Token being issued. However, when no Access Token is issued (which is the
   * case for the response_type value id_token), the resulting Claims are returned in the ID Token.
   */
  claimShortcutRestrictive?: boolean | undefined;
  /**
   * The URL of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document. For
   *
   * @remarks
   * example, `http://example.com/auth/jwks`.
   *
   * Client applications accesses this URL (1) to get the public key of the service to validate the
   * signature of an ID token issued by the service and (2) to get the public key of the service to
   * encrypt an request object of the client application. See [OpenID Connect Core 1.0, 10. Signatures
   * and Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
   *
   * The value of this property is used as `jwks_uri` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  jwksUri?: string | undefined;
  /**
   * 'The flag to indicate whether the direct jwks endpoint is enabled or not. The path of the endpoint
   *
   * @remarks
   * is `/api/service/jwks/get/direct/service-api-key`. '
   */
  directJwksEndpointEnabled?: boolean | undefined;
  /**
   * The content of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document.
   *
   * @remarks
   *
   * If this property is not `null` in a `/service/create` request or a `/service/update` request,
   * Authlete hosts the content in the database. This property must not be `null` and must contain
   * pairs of public/private keys if the service wants to support asymmetric signatures for ID tokens
   * and asymmetric encryption for request objects. See [OpenID Connect Core 1.0, 10. Signatures and
   * Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
   */
  jwks?: string | undefined;
  /**
   * The key ID to identify a JWK used for ID token signature using an asymmetric key.
   *
   * @remarks
   *
   * A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
   * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
   * to pick up one JWK for signature from the JWK Set when it generates an ID token and signature
   * using an asymmetric key is required. Authlete Server searches the registered JWK Set for a JWK
   * which satisfies conditions for ID token signature. If the number of JWK candidates which satisfy
   * the conditions is 1, there is no problem. On the other hand, if there exist multiple candidates,
   * a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5) is needed to be specified so that
   * Authlete Server can pick up one JWK from among the JWK candidates.
   *
   * This `idTokenSignatureKeyId` property exists for the purpose described above. For key rotation
   * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
   * this mechanism is needed.
   */
  idTokenSignatureKeyId?: string | undefined;
  /**
   * The key ID to identify a JWK used for user info signature using an asymmetric key.
   *
   * @remarks
   *
   * A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
   * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
   * to pick up one JWK for signature from the JWK Set when it is required to sign user info (which
   * is returned from [userinfo endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo))
   * using an asymmetric key. Authlete Server searches the registered JWK Set for a JWK which satisfies
   * conditions for user info signature. If the number of JWK candidates which satisfy the conditions
   * is 1, there is no problem. On the other hand, if there exist multiple candidates, a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5)
   * is needed to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
   *
   * This `userInfoSignatureKeyId` property exists for the purpose described above. For key rotation
   * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
   * this mechanism is needed.
   */
  userInfoSignatureKeyId?: string | undefined;
  /**
   * The key ID to identify a JWK used for signing authorization responses using an asymmetric key.
   *
   * @remarks
   *
   * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
   * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
   * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
   * from the authorization endpoint will be packed into a JWT. This property is used to compute the
   * value of the `exp` claim of the JWT.
   *
   * Authlete Server searches the JWK Set for a JWK which satisfies conditions for authorization response
   * signature. If the number of JWK candidates which satisfy the conditions is 1, there is no problem.
   * On the other hand, if there exist multiple candidates, a Key ID is needed to be specified so that
   * Authlete Server can pick up one JWK from among the JWK candidates. This property exists to specify
   * the key ID.
   */
  authorizationSignatureKeyId?: string | undefined;
  /**
   * The [user info endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo) of the
   *
   * @remarks
   * service. A URL that starts with `https://`. For example, `https://example.com/auth/userinfo`.
   *
   * The value of this property is used as `userinfo_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  userInfoEndpoint?: string | undefined;
  /**
   * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path
   *
   * @remarks
   * of the endpoint is `/api/auth/userinfo/direct/service-api-key`.
   */
  directUserInfoEndpointEnabled?: boolean | undefined;
  /**
   * The boolean flag which indicates whether the [OAuth 2.0 Dynamic Client Registration Protocol](https://tools.ietf.org/html/rfc7591)
   *
   * @remarks
   * is supported.
   */
  dynamicRegistrationSupported?: boolean | undefined;
  /**
   * The [registration endpoint](http://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration)
   *
   * @remarks
   * of the service. A URL that starts with `https://`. For example, `https://example.com/auth/registration`.
   *
   * The value of this property is used as `registration_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  registrationEndpoint?: string | undefined;
  /**
   * The URI of the registration management endpoint. If dynamic client registration is supported,
   *
   * @remarks
   * and this is set, this URI will be used as the basis of the client's management endpoint by appending
   * `/clientid}/` to it as a path element. If this is unset, the value of `registrationEndpoint` will
   * be used as the URI base instead.
   */
  registrationManagementEndpoint?: string | undefined;
  /**
   * The URL of the "Policy" of the service.
   *
   * @remarks
   *
   * The value of this property is used as `op_policy_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  policyUri?: string | undefined;
  /**
   * The URL of the "Terms Of Service" of the service.
   *
   * @remarks
   *
   * The value of this property is used as `op_tos_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  tosUri?: string | undefined;
  /**
   * The URL of a page where documents for developers can be found.
   *
   * @remarks
   *
   * The value of this property is used as `service_documentation` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  serviceDocumentation?: string | undefined;
  /**
   * The URI of backchannel authentication endpoint, which is defined in the specification of [CIBA
   *
   * @remarks
   * (Client Initiated Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
   */
  backchannelAuthenticationEndpoint?: string | undefined;
  /**
   * The supported backchannel token delivery modes. This property corresponds to the `backchannel_token_delivery_modes_supported`
   *
   * @remarks
   * metadata.
   *
   * Backchannel token delivery modes are defined in the specification of [CIBA (Client Initiated
   * Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
   */
  supportedBackchannelTokenDeliveryModes?:
    | Array<ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest>
    | undefined;
  /**
   * The duration of backchannel authentication request IDs issued from the backchannel authentication
   *
   * @remarks
   * endpoint in seconds. This is used as the value of the `expires_in` property in responses from
   * the backchannel authentication endpoint.
   */
  backchannelAuthReqIdDuration?: number | undefined;
  /**
   * The minimum interval between polling requests to the token endpoint from client applications in
   *
   * @remarks
   * seconds. This is used as the value of the `interval` property in responses from the backchannel
   * authentication endpoint.
   */
  backchannelPollingInterval?: number | undefined;
  /**
   * The boolean flag which indicates whether the `user_code` request parameter is supported at the
   *
   * @remarks
   * backchannel authentication endpoint. This property corresponds to the `backchannel_user_code_parameter_supported`
   * metadata.
   */
  backchannelUserCodeParameterSupported?: boolean | undefined;
  /**
   * The flag to indicate whether the `binding_message` request parameter is always required whenever
   *
   * @remarks
   * a backchannel authentication request is judged as a request for Financial-grade API.
   *
   * The FAPI-CIBA profile requires that the authorization server _"shall ensure unique authorization
   * context exists in the authorization request or require a `binding_message` in the authorization
   * request"_ (FAPI-CIBA, 5.2.2, 2). The simplest way to fulfill this requirement is to set this property
   * to `true`.
   *
   * If this property is set to `false`, the `binding_message` request parameter remains optional
   * even in FAPI context, but in exchange, your authorization server must implement a custom mechanism
   * that ensures each backchannel authentication request has unique context.
   */
  backchannelBindingMessageRequiredInFapi?: boolean | undefined;
  /**
   * The URI of the device authorization endpoint.
   *
   * @remarks
   *
   * Device authorization endpoint is defined in the specification of OAuth 2.0 Device Authorization Grant.
   */
  deviceAuthorizationEndpoint?: string | undefined;
  /**
   * The verification URI for the device flow. This URI is used as the value of the `verification_uri`
   *
   * @remarks
   * parameter in responses from the device authorization endpoint.
   */
  deviceVerificationUri?: string | undefined;
  /**
   * The verification URI for the device flow with a placeholder for a user code. This URI is used
   *
   * @remarks
   * to build the value of the `verification_uri_complete` parameter in responses from the device
   * authorization endpoint.
   *
   * It is expected that the URI contains a fixed string `USER_CODE` somewhere as a placeholder for
   * a user code. For example, like the following.
   *
   * `https://example.com/device?user\_code=USER\_CODE`
   *
   * The fixed string is replaced with an actual user code when Authlete builds a verification URI
   * with a user code for the `verification_uri_complete` parameter.
   *
   * If this URI is not set, the `verification_uri_complete` parameter won't appear in device authorization
   * responses.
   */
  deviceVerificationUriComplete?: string | undefined;
  /**
   * The duration of device verification codes and end-user verification codes issued from the device
   *
   * @remarks
   * authorization endpoint in seconds. This is used as the value of the `expires_in` property in responses
   * from the device authorization endpoint.
   */
  deviceFlowCodeDuration?: number | undefined;
  /**
   * The minimum interval between polling requests to the token endpoint from client applications in
   *
   * @remarks
   * seconds in device flow. This is used as the value of the `interval` property in responses from
   * the device authorization endpoint.
   */
  deviceFlowPollingInterval?: number | undefined;
  /**
   * The character set for end-user verification codes (`user_code`) for Device Flow.
   *
   * @remarks
   */
  userCodeCharset?: ServiceCreateApiUserCodeCharsetRequest | undefined;
  /**
   * The length of end-user verification codes (`user_code`) for Device Flow.
   *
   * @remarks
   */
  userCodeLength?: number | undefined;
  /**
   * Trust frameworks supported by this service. This corresponds to the `trust_frameworks_supported`
   *
   * @remarks
   * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
   */
  supportedTrustFrameworks?: Array<string> | undefined;
  /**
   * Evidence supported by this service. This corresponds to the `evidence_supported` [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
   *
   * @remarks
   */
  supportedEvidence?: Array<string> | undefined;
  /**
   * Identity documents supported by this service. This corresponds to the `id_documents_supported`
   *
   * @remarks
   * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
   */
  supportedIdentityDocuments?: Array<string> | undefined;
  /**
   * Verification methods supported by this service. This corresponds to the `id_documents_verification_methods_supported`
   *
   * @remarks
   * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
   */
  supportedVerificationMethods?: Array<string> | undefined;
  /**
   * Verified claims supported by this service. This corresponds to the `claims_in_verified_claims_supported`
   *
   * @remarks
   * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
   */
  supportedVerifiedClaims?: Array<string> | undefined;
  /**
   * OIDC4IDA / verifiedClaimsValidationSchemaSet
   *
   * @remarks
   */
  verifiedClaimsValidationSchemaSet?:
    | ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest
    | undefined;
  /**
   * The attributes of this service.
   *
   * @remarks
   */
  attributes?: Array<ServiceCreateApiAttributeRequest> | undefined;
  /**
   * The flag indicating whether the nbf claim in the request object is optional even when the authorization
   *
   * @remarks
   * request is regarded as a FAPI-Part2 request.
   *
   * The final version of Financial-grade API was approved in January, 2021. The Part 2 of the final
   * version has new requirements on lifetime of request objects. They require that request objects
   * contain an `nbf` claim and the lifetime computed by `exp` - `nbf` be no longer than 60 minutes.
   *
   * Therefore, when an authorization request is regarded as a FAPI-Part2 request, the request object
   * used in the authorization request must contain an nbf claim. Otherwise, the authorization server
   * rejects the authorization request.
   *
   * When this flag is `true`, the `nbf` claim is treated as an optional claim even when the authorization
   * request is regarded as a FAPI-Part2 request. That is, the authorization server does not perform
   * the validation on lifetime of the request object.
   *
   * Skipping the validation is a violation of the FAPI specification. The reason why this flag has
   * been prepared nevertheless is that the new requirements (which do not exist in the Implementer's
   * Draft 2 released in October, 2018) have big impacts on deployed implementations of client
   * applications and Authlete thinks there should be a mechanism whereby to make the migration
   * from ID2 to Final smooth without breaking live systems.
   */
  nbfOptional?: boolean | undefined;
  /**
   * The flag indicating whether generation of the iss response parameter is suppressed.
   *
   * @remarks
   *
   * "OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response" has defined a new
   * authorization response parameter, `iss`, as a countermeasure for a certain type of mix-up attacks.
   *
   * The specification requires that the `iss` response parameter always be included in authorization
   * responses unless JARM (JWT Secured Authorization Response Mode) is used.
   *
   * When this flag is `true`, the authorization server does not include the `iss` response parameter
   * in authorization responses. By turning this flag on and off, developers of client applications
   * can experiment the mix-up attack and the effect of the `iss` response parameter.
   *
   * Note that this flag should not be `true` in production environment unless there are special
   * reasons for it.
   */
  issSuppressed?: boolean | undefined;
  /**
   * custom client metadata supported by this service.
   *
   * @remarks
   *
   * Standard specifications define client metadata as necessary. The following are such examples.
   *
   * * [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
   * * [RFC 7591 OAuth 2.0 Dynamic Client Registration Protocol](https://www.rfc-editor.org/rfc/rfc7591.html)
   * * [RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens](https://www.rfc-editor.org/rfc/rfc8705.html)
   * * [OpenID Connect Client-Initiated Backchannel Authentication Flow - Core 1.0](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html)
   * * [The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-jwsreq/)
   * * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
   * * [OAuth 2.0 Pushed Authorization Requests (PAR)](https://datatracker.ietf.org/doc/rfc9126/)
   * * [OAuth 2.0 Rich Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/)
   *
   * Standard client metadata included in Client Registration Request and Client Update Request (cf.
   * [OIDC DynReg](https://openid.net/specs/openid-connect-registration-1_0.html), [RFC 7591](https://www.rfc-editor.org/rfc/rfc7591.html)
   * and [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)) are, if supported by Authlete, stored
   * into Authlete database. On the other hand, unrecognized client metadata are discarded.
   *
   * By listing up custom client metadata in advance by using this property (`supportedCustomClientMetadata`),
   * Authlete can recognize them and stores their values into the database. The stored custom client
   * metadata values can be referenced by `customMetadata`.
   */
  supportedCustomClientMetadata?: Array<string> | undefined;
  /**
   * The flag indicating whether the expiration date of an access token never exceeds that of the
   *
   * @remarks
   * corresponding refresh token.
   *
   * When a new access token is issued by a refresh token request (= a token request with `grant_type=refresh_token`),
   * the expiration date of the access token may exceed the expiration date of the corresponding
   * refresh token. This behavior itself is not wrong and may happen when `refreshTokenKept` is
   * `true` and/or when `refreshTokenDurationKept` is `true`.
   *
   * When this flag is `true`, the expiration date of an access token never exceeds that of the corresponding
   * refresh token regardless of the calculated duration based on other settings such as `accessTokenDuration`,
   * `accessTokenDuration` in `extension` and `access_token.duration` scope attribute.
   *
   * It is technically possible to set a value which is bigger than the duration of refresh tokens
   * as the duration of access tokens although it is strange. In the case, the duration of an access
   * token becomes longer than the duration of the refresh token which is issued together with the
   * access token. Even if the duration values are configured so, if this flag is `true`, the expiration
   * date of the access token does not exceed that of the refresh token. That is, the duration of
   * the access token will be shortened, and as a result, the access token and the refresh token
   * will have the same expiration date.
   */
  tokenExpirationLinked?: boolean | undefined;
  /**
   * The flag indicating whether encryption of request object is required when the request object
   *
   * @remarks
   * is passed through the front channel.
   *
   * This flag does not affect the processing of request objects at the Pushed Authorization Request
   * Endpoint, which is defined in [OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/).
   * Unecrypted request objects are accepted at the endpoint even if this flag is `true`.
   *
   * This flag does not indicate whether a request object is always required. There is a different
   * flag, `requestObjectRequired`, for the purpose. See the description of `requestObjectRequired`
   * for details.
   *
   * Even if this flag is `false`, encryption of request object is required if the `frontChannelRequestObjectEncryptionRequired`
   * flag of the client is `true`.
   */
  frontChannelRequestObjectEncryptionRequired?: boolean | undefined;
  /**
   * The flag indicating whether the JWE alg of encrypted request object must match the `request_object_encryption_alg`
   *
   * @remarks
   * client metadata of the client that has sent the request object.
   *
   * The request_object_encryption_alg client metadata itself is defined in [OpenID Connect Dynamic
   * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
   *
   * > request_object_encryption_alg
   * >
   * > OPTIONAL. JWE [JWE] alg algorithm [JWA] the RP is declaring that it may use for encrypting
   * Request Objects sent to the OP. This parameter SHOULD be included when symmetric encryption
   * will be used, since this signals to the OP that a client_secret value needs to be returned
   * from which the symmetric key will be derived, that might not otherwise be returned. The RP
   * MAY still use other supported encryption algorithms or send unencrypted Request Objects, even
   * when this parameter is present. If both signing and encryption are requested, the Request Object
   * will be signed then encrypted, with the result being a Nested JWT, as defined in [JWT]. The
   * default, if omitted, is that the RP is not declaring whether it might encrypt any Request Objects.
   *
   * The point here is "The RP MAY still use other supported encryption algorithms or send unencrypted
   * Request Objects, even when this parameter is present."
   *
   * The Client's property that represents the client metadata is `requestEncryptionAlg`. See the
   * description of `requestEncryptionAlg` for details.
   *
   * Even if this flag is `false`, the match is required if the `requestObjectEncryptionAlgMatchRequired`
   * flag of the client is `true`.
   */
  requestObjectEncryptionAlgMatchRequired?: boolean | undefined;
  /**
   * The flag indicating whether the JWE `enc` of encrypted request object must match the `request_object_encryption_enc`
   *
   * @remarks
   * client metadata of the client that has sent the request object.
   *
   * The `request_object_encryption_enc` client metadata itself is defined in [OpenID Connect Dynamic
   * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
   *
   * > request_object_encryption_enc
   * >
   * > OPTIONAL. JWE enc algorithm [JWA] the RP is declaring that it may use for encrypting Request
   * Objects sent to the OP. If request_object_encryption_alg is specified, the default for this
   * value is A128CBC-HS256. When request_object_encryption_enc is included, request_object_encryption_alg
   * MUST also be provided.
   *
   * The Client's property that represents the client metadata is `requestEncryptionEnc`. See the
   * description of `requestEncryptionEnc` for details.
   *
   * Even if this flag is false, the match is required if the `requestObjectEncryptionEncMatchRequired`
   * flag is `true`.
   */
  requestObjectEncryptionEncMatchRequired?: boolean | undefined;
  /**
   * The flag indicating whether HSM (Hardware Security Module) support is enabled for this service.
   *
   * @remarks
   *
   * When this flag is `false`, keys managed in HSMs are not used even if they exist. In addition,
   * `/api/hsk/*` APIs reject all requests.
   *
   * Even if this flag is `true`, HSM-related features do not work if the configuration of the Authlete
   * server you are using does not support HSM.
   */
  hsmEnabled?: boolean | undefined;
  /**
   * The information about keys managed on HSMs (Hardware Security Modules).
   *
   * @remarks
   *
   * This `hsks` property is output only, meaning that `hsks` in requests to `/api/service/create`
   * API and `/api/service/update` API do not have any effect. The contents of this property is controlled
   * only by `/api/hsk/*` APIs.
   */
  hsks?: Array<ServiceCreateApiHskRequest> | undefined;
  /**
   * The URL of the grant management endpoint.
   *
   * @remarks
   */
  grantManagementEndpoint?: string | undefined;
  /**
   * The flag indicating whether every authorization request (and any request serving as an authorization
   *
   * @remarks
   * request such as CIBA backchannel authentication request and device authorization request) must
   * include the `grant_management_action` request parameter.
   *
   * This property corresponds to the `grant_management_action_required` server metadata defined
   * in [Grant Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html).
   *
   * Note that setting true to this property will result in blocking all public clients because
   * the specification requires that grant management be usable only by confidential clients for
   * security reasons.
   */
  grantManagementActionRequired?: boolean | undefined;
  /**
   * The flag indicating whether Authlete's `/api/client/registration` API uses `UNAUTHORIZED` as
   *
   * @remarks
   * a value of the `action` response parameter when appropriate.
   *
   * The `UNAUTHORIZED` enum value was initially not defined as a possible value of the `action`
   * parameter in an `/api/client/registration` API response. This means that implementations of
   * client `configuration` endpoint were not able to conform to [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)
   * strictly.
   *
   * For backward compatibility (to avoid breaking running systems), Authlete's `/api/client/registration`
   * API does not return the `UNAUTHORIZED` enum value if this flag is not turned on.
   *
   * The steps an existing implementation of client configuration endpoint has to do in order to
   * conform to the requirement related to "401 Unauthorized" are as follows.
   *
   * 1. Update the Authlete library (e.g. authlete-java-common) your system is using.
   * 2. Update your implementation of client configuration endpoint so that it can handle the
   * `UNAUTHORIZED` action.
   * 3. Turn on this `unauthorizedOnClientConfigSupported` flag.
   */
  unauthorizedOnClientConfigSupported?: boolean | undefined;
  /**
   * The flag indicating whether the `scope` request parameter in dynamic client registration and
   *
   * @remarks
   * update requests (RFC 7591 and RFC 7592) is used as scopes that the client can request.
   *
   * Limiting the range of scopes that a client can request is achieved by listing scopes in the
   * `client.extension.requestableScopes` property and setting the `client.extension.requestableScopesEnabled`
   * property to `true`. This feature is called "requestable scopes".
   *
   * This property affects behaviors of `/api/client/registration` and other family APIs.
   */
  dcrScopeUsedAsRequestable?: boolean | undefined;
  /**
   * The endpoint for clients ending the sessions.
   *
   * @remarks
   *
   * A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/endSession`.
   *
   * The value of this property is used as `end_session_endpoint` property in the [OpenID Provider
   * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  endSessionEndpoint?: string | undefined;
  /**
   * The flag indicating whether the port number component of redirection URIs can be variable when
   *
   * @remarks
   * the host component indicates loopback.
   *
   * When this flag is `true`, if the host component of a redirection URI specified in an authorization
   * request indicates loopback (to be precise, when the host component is localhost, `127.0.0.1`
   * or `::1`), the port number component is ignored when the specified redirection URI is compared
   * to pre-registered ones. This behavior is described in [7.3. Loopback Interface Redirection](
   * https://www.rfc-editor.org/rfc/rfc8252.html#section-7.3) of [RFC 8252 OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8252.html)
   * for Native Apps.
   *
   * [3.1.2.3. Dynamic Configuration](https://www.rfc-editor.org/rfc/rfc6749.html#section-3.1.2.3)
   * of [RFC 6749](https://www.rfc-editor.org/rfc/rfc6749.html) states _"If the client registration
   * included the full redirection URI, the authorization server MUST compare the two URIs using
   * simple string comparison as defined in [RFC3986] Section 6.2.1."_ Also, the description of
   * `redirect_uri` in [3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest)
   * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) states
   * _"This URI MUST exactly match one of the Redirection URI values for the Client pre-registered
   * at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [RFC3986]
   * (**Simple String Comparison**)."_ These "Simple String Comparison" requirements are preceded
   * by this flag. That is, even when the conditions described in RFC 6749 and OpenID Connect Core 1.0
   * are satisfied, the port number component of loopback redirection URIs can be variable when this
   * flag is `true`.
   *
   * [8.3. Loopback Redirect Considerations](https://www.rfc-editor.org/rfc/rfc8252.html#section-8.3)
   * of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) states as follows.
   *
   * > While redirect URIs using localhost (i.e., `"http://localhost:{port}/{path}"`) function
   * similarly to loopback IP redirects described in Section 7.3, the use of localhost is NOT RECOMMENDED.
   * Specifying a redirect URI with the loopback IP literal rather than localhost avoids inadvertently
   * listening on network interfaces other than the loopback interface. It is also less susceptible
   * to client-side firewalls and misconfigured host name resolution on the user's device.
   *
   * However, Authlete allows the port number component to be variable in the case of `localhost`,
   * too. It is left to client applications whether they use `localhost` or a literal loopback IP
   * address (`127.0.0.1` for IPv4 or `::1` for IPv6).
   *
   * Section 7.3 and Section 8.3 of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) state
   * that loopback redirection URIs use the `"http"` scheme, but Authlete allows the port number
   * component to be variable in other cases (e.g. in the case of the `"https"` scheme), too.
   */
  loopbackRedirectionUriVariable?: boolean | undefined;
  /**
   * The flag indicating whether Authlete checks whether the `aud` claim of request objects matches
   *
   * @remarks
   * the issuer identifier of this service.
   *
   * [Section 6.1. Passing a Request Object by Value](https://openid.net/specs/openid-connect-core-1_0.html#JWTRequests)
   * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) has the following
   * statement.
   *
   * > The `aud` value SHOULD be or include the OP's Issuer Identifier URL.
   *
   * Likewise, [Section 4. Request Object](https://www.rfc-editor.org/rfc/rfc9101.html#section-4) of
   * [RFC 9101](https://www.rfc-editor.org/rfc/rfc9101.html) (The OAuth 2.0 Authorization Framework:
   * JWT-Secured Authorization Request (JAR)) has the following statement.
   *
   * > The value of aud should be the value of the authorization server (AS) issuer, as defined in
   * [RFC 8414](https://www.rfc-editor.org/rfc/rfc8414.html).
   *
   * As excerpted above, validation on the `aud` claim of request objects is optional. However, if
   * this flag is turned on, Authlete checks whether the `aud` claim of request objects matches the issuer
   * identifier of this service and raises an error if they are different.
   */
  requestObjectAudienceChecked?: boolean | undefined;
  /**
   * The flag indicating whether Authlete generates access tokens for
   *
   * @remarks
   * external attachments and embeds them in ID tokens and userinfo
   * responses.
   */
  accessTokenForExternalAttachmentEmbedded?: boolean | undefined;
  /**
   * Identifiers of entities that can issue entity statements for this
   *
   * @remarks
   * service. This property corresponds to the `authority_hints`
   * property that appears in a self-signed entity statement that is
   * defined in OpenID Connect Federation 1.0.
   */
  authorityHints?: Array<string> | undefined;
  /**
   * flag indicating whether this service supports OpenID Connect Federation 1
   *
   * @remarks
   */
  federationEnabled?: boolean | undefined;
  /**
   * JWK Set document containing keys that are used to sign (1) self-signed
   *
   * @remarks
   * entity statement of this service and (2) the response from
   * `signed_jwks_uri`.
   */
  federationJwks?: string | undefined;
  /**
   * A key ID to identify a JWK used to sign the entity configuration and
   *
   * @remarks
   * the signed JWK Set.
   */
  federationSignatureKeyId?: string | undefined;
  /**
   * The duration of the entity configuration in seconds.
   *
   * @remarks
   */
  federationConfigurationDuration?: number | undefined;
  /**
   * The URI of the federation registration endpoint. This property corresponds
   *
   * @remarks
   * to the `federation_registration_endpoint` server metadata that is
   * defined in OpenID Connect Federation 1.0.
   */
  federationRegistrationEndpoint?: string | undefined;
  /**
   * The human-readable name representing the organization that operates
   *
   * @remarks
   * this service. This property corresponds to the `organization_name`
   * server metadata that is defined in OpenID Connect Federation 1.0.
   */
  organizationName?: string | undefined;
  /**
   * The transformed claims predefined by this service in JSON format.
   *
   * @remarks
   * This property corresponds to the `transformed_claims_predefined`
   * server metadata.
   */
  predefinedTransformedClaims?: string | undefined;
  /**
   * flag indicating whether refresh token requests with the same
   *
   * @remarks
   * refresh token can be made multiple times in quick succession and
   * they can obtain the same renewed refresh token within the short
   * period.
   */
  refreshTokenIdempotent?: boolean | undefined;
  /**
   * The URI of the endpoint that returns this service's JWK Set document in
   *
   * @remarks
   * the JWT format. This property corresponds to the `signed_jwks_uri`
   * server metadata defined in OpenID Connect Federation 1.0.
   */
  signedJwksUri?: string | undefined;
  /**
   * Supported attachment types. This property corresponds to the {@code
   *
   * @remarks
   * attachments_supported} server metadata which was added by the third
   * implementer's draft of OpenID Connect for Identity Assurance 1.0.
   */
  supportedAttachments?:
    | Array<ServiceCreateApiSupportedAttachmentRequest>
    | undefined;
  /**
   * Supported algorithms used to compute digest values of external
   *
   * @remarks
   * attachments. This property corresponds to the
   * `digest_algorithms_supported` server metadata which was added
   * by the third implementer's draft of OpenID Connect for Identity
   * Assurance 1.0.
   */
  supportedDigestAlgorithms?: Array<string> | undefined;
  /**
   * Document types supported by this service. This property corresponds
   *
   * @remarks
   * to the `documents_supported` server metadata.
   */
  supportedDocuments?: Array<string> | undefined;
  /**
   * validation and verification processes supported by this service.
   *
   * @remarks
   * This property corresponds to the `documents_methods_supported`
   * server metadata.
   *
   * The third implementer's draft of [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
   * renamed the
   * `id_documents_verification_methods_supported` server metadata to
   * `documents_methods_supported`.
   */
  supportedDocumentsMethods?: Array<string> | undefined;
  /**
   * Document validation methods supported by this service. This property
   *
   * @remarks
   * corresponds to the `documents_validation_methods_supported` server
   * metadata which was added by the third implementer's draft of <a href=
   * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
   */
  supportedDocumentsValidationMethods?: Array<string> | undefined;
  /**
   * Document verification methods supported by this service. This property
   *
   * @remarks
   * corresponds to the `documents_verification_methods_supported` server
   * metadata which was added by the third implementer's draft of
   * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
   */
  supportedDocumentsVerificationMethods?: Array<string> | undefined;
  /**
   * Electronic record types supported by this service. This property
   *
   * @remarks
   * corresponds to the `electronic_records_supported` server metadata
   * which was added by the third implementer's draft of
   * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
   */
  supportedElectronicRecords?: Array<string> | undefined;
  supportedClientRegistrationTypes?:
    | Array<ServiceCreateApiSupportedClientRegistrationTypeRequest>
    | undefined;
  /**
   * The flag indicating whether to prohibit unidentifiable clients from
   *
   * @remarks
   * making token exchange requests.
   */
  tokenExchangeByIdentifiableClientsOnly?: boolean | undefined;
  /**
   * The flag indicating whether to prohibit public clients from making
   *
   * @remarks
   * token exchange requests.
   */
  tokenExchangeByConfidentialClientsOnly?: boolean | undefined;
  /**
   * The flag indicating whether to prohibit clients that have no explicit
   *
   * @remarks
   * permission from making token exchange requests.
   */
  tokenExchangeByPermittedClientsOnly?: boolean | undefined;
  /**
   * The flag indicating whether to reject token exchange requests which
   *
   * @remarks
   * use encrypted JWTs as input tokens.
   */
  tokenExchangeEncryptedJwtRejected?: boolean | undefined;
  /**
   * The flag indicating whether to reject token exchange requests which
   *
   * @remarks
   * use unsigned JWTs as input tokens.
   */
  tokenExchangeUnsignedJwtRejected?: boolean | undefined;
  /**
   * The flag indicating whether to prohibit unidentifiable clients from
   *
   * @remarks
   * using the grant type "urn:ietf:params:oauth:grant-type:jwt-bearer".
   */
  jwtGrantByIdentifiableClientsOnly?: boolean | undefined;
  /**
   * The flag indicating whether to reject token requests that use an
   *
   * @remarks
   * encrypted JWT as an authorization grant with the grant type
   * "urn:ietf:params:oauth:grant-type:jwt-bearer".
   */
  jwtGrantEncryptedJwtRejected?: boolean | undefined;
  /**
   * The flag indicating whether to reject token requests that use an
   *
   * @remarks
   * unsigned JWT as an authorization grant with the grant type
   * "urn:ietf:params:oauth:grant-type:jwt-bearer".
   */
  jwtGrantUnsignedJwtRejected?: boolean | undefined;
  /**
   * The flag indicating whether to block DCR (Dynamic Client Registration)
   *
   * @remarks
   * requests whose "software_id" has already been used previously.
   */
  dcrDuplicateSoftwareIdBlocked?: boolean | undefined;
  /**
   * The trust anchors that are referenced when this service resolves
   *
   * @remarks
   * trust chains of relying parties.
   *
   * If this property is empty, client registration fails regardless of
   * whether its type is `automatic` or `explicit`. It means
   * that OpenID Connect Federation 1.0 does not work.
   */
  trustAnchors?: Array<ServiceCreateApiTrustAnchorRequest> | undefined;
  /**
   * The flag indicating whether the openid scope should be dropped from
   *
   * @remarks
   * scopes list assigned to access token issued when a refresh token grant
   * is used.
   */
  openidDroppedOnRefreshWithoutOfflineAccess?: boolean | undefined;
  /**
   * Supported document check methods. This property corresponds to the `documents_check_methods_supported`
   *
   * @remarks
   * server metadata which was added by the fourth implementer's draft of OpenID Connect for Identity
   * Assurance 1.0.
   */
  supportedDocumentsCheckMethods?: Array<string> | undefined;
  /**
   * The flag indicating whether this service signs responses from the resource server.
   *
   * @remarks
   */
  rsResponseSigned?: boolean | undefined;
  /**
   * The duration of `c_nonce`.
   *
   * @remarks
   */
  cnonceDuration?: number | undefined;
  /**
   * Whether to require DPoP proof JWTs to include the `nonce` claim
   *
   * @remarks
   * whenever they are presented.
   */
  dpopNonceRequired?: boolean | undefined;
  /**
   * Get the flag indicating whether the feature of Verifiable Credentials
   *
   * @remarks
   * for this service is enabled or not.
   */
  verifiableCredentialsEnabled?: boolean | undefined;
  /**
   * The URL at which the JWK Set document of the credential issuer is
   *
   * @remarks
   * exposed.
   */
  credentialJwksUri?: string | undefined;
  /**
   * The default duration of credential offers in seconds.
   *
   * @remarks
   */
  credentialOfferDuration?: number | undefined;
  /**
   * The duration of nonce values for DPoP proof JWTs in seconds.
   *
   * @remarks
   */
  dpopNonceDuration?: number | undefined;
  /**
   * The flag indicating whether token requests using the pre-authorized
   *
   * @remarks
   * code grant flow by unidentifiable clients are allowed.
   */
  preAuthorizedGrantAnonymousAccessSupported?: boolean | undefined;
  /**
   * The duration of transaction ID in seconds that may be issued as a
   *
   * @remarks
   * result of a credential request or a batch credential request.
   */
  credentialTransactionDuration?: number | undefined;
  /**
   * The key ID of the key for signing introspection responses.
   *
   * @remarks
   */
  introspectionSignatureKeyId?: string | undefined;
  /**
   * The key ID of the key for signing introspection responses.
   *
   * @remarks
   */
  resourceSignatureKeyId?: string | undefined;
  /**
   * The default length of user PINs.
   *
   * @remarks
   */
  userPinLength?: number | undefined;
  /**
   * The supported `prompt` values.
   *
   * @remarks
   */
  supportedPromptValues?:
    | Array<ServiceCreateApiSupportedPromptValueRequest>
    | undefined;
  /**
   * The flag indicating whether to enable the feature of ID token
   *
   * @remarks
   * reissuance in the refresh token flow.
   */
  idTokenReissuable?: boolean | undefined;
  /**
   * The JWK Set document containing private keys that are used to sign
   *
   * @remarks
   * verifiable credentials.
   */
  credentialJwks?: string | undefined;
  /**
   * FAPI modes for this service.
   *
   * @remarks
   *
   * When the value of this property is not `null`, Authlete always processes requests to this service based
   * on the specified FAPI modes if the FAPI feature is enabled in Authlete and the FAPI profile is supported
   * by this service.
   *
   * For instance, when this property is set to an array containing `FAPI1_ADVANCED` only, Authlete always
   * processes requests to this service based on "Financial-grade API Security Profile 1.0 - Part 2:
   * Advanced" if the FAPI feature is enabled in Authlete and the FAPI profile is supported by this service.
   */
  fapiModes?: Array<ServiceCreateApiFapiModeRequest> | undefined;
  /**
   * The default duration of verifiable credentials in seconds.
   *
   * @remarks
   */
  credentialDuration?: number | undefined;
  credentialIssuerMetadata?:
    | ServiceCreateApiCredentialIssuerMetadataRequest
    | undefined;
  /**
   * The type of the `aud` claim in ID tokens.
   *
   * @remarks
   */
  idTokenAudType?: string | undefined;
};

export type ServiceCreateApiMetadatumResponse = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export const ServiceCreateApiSupportedGrantTypeResponse = {
  AuthorizationCode: "AUTHORIZATION_CODE",
  Implicit: "IMPLICIT",
  Password: "PASSWORD",
  ClientCredentials: "CLIENT_CREDENTIALS",
  RefreshToken: "REFRESH_TOKEN",
  Ciba: "CIBA",
  DeviceCode: "DEVICE_CODE",
  TokenExchange: "TOKEN_EXCHANGE",
  JwtBearer: "JWT_BEARER",
} as const;
/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export type ServiceCreateApiSupportedGrantTypeResponse = ClosedEnum<
  typeof ServiceCreateApiSupportedGrantTypeResponse
>;

export const ServiceCreateApiSupportedResponseTypeResponse = {
  None: "NONE",
  Code: "CODE",
  Token: "TOKEN",
  IdToken: "ID_TOKEN",
  CodeToken: "CODE_TOKEN",
  CodeIdToken: "CODE_ID_TOKEN",
  IdTokenToken: "ID_TOKEN_TOKEN",
  CodeIdTokenToken: "CODE_ID_TOKEN_TOKEN",
} as const;
export type ServiceCreateApiSupportedResponseTypeResponse = ClosedEnum<
  typeof ServiceCreateApiSupportedResponseTypeResponse
>;

export const ServiceCreateApiSupportedServiceProfileResponse = {
  Fapi: "FAPI",
  OpenBanking: "OPEN_BANKING",
} as const;
export type ServiceCreateApiSupportedServiceProfileResponse = ClosedEnum<
  typeof ServiceCreateApiSupportedServiceProfileResponse
>;

/**
 * The display mode which the client application requests by `display` request parameter.
 *
 * @remarks
 * When the authorization request does not have `display` request parameter, `PAGE` is set as the default value.
 *
 * It is ensured that the value of `display` is one of the supported display modes which are specified
 * by `supportedDisplays` configuration parameter of the service. If the display mode specified by the
 * authorization request is not supported, an error is raised.
 *
 * Values for this property correspond to the values listed in
 * "[OpenID Connect Core 1.0, 3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest), display".
 */
export const ServiceCreateApiSupportedDisplayResponse = {
  Page: "PAGE",
  Popup: "POPUP",
  Touch: "TOUCH",
  Wap: "WAP",
} as const;
/**
 * The display mode which the client application requests by `display` request parameter.
 *
 * @remarks
 * When the authorization request does not have `display` request parameter, `PAGE` is set as the default value.
 *
 * It is ensured that the value of `display` is one of the supported display modes which are specified
 * by `supportedDisplays` configuration parameter of the service. If the display mode specified by the
 * authorization request is not supported, an error is raised.
 *
 * Values for this property correspond to the values listed in
 * "[OpenID Connect Core 1.0, 3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest), display".
 */
export type ServiceCreateApiSupportedDisplayResponse = ClosedEnum<
  typeof ServiceCreateApiSupportedDisplayResponse
>;

/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export const ServiceCreateApiSupportedTokenAuthMethodResponse = {
  None: "NONE",
  ClientSecretBasic: "CLIENT_SECRET_BASIC",
  ClientSecretPost: "CLIENT_SECRET_POST",
  ClientSecretJwt: "CLIENT_SECRET_JWT",
  PrivateKeyJwt: "PRIVATE_KEY_JWT",
  TlsClientAuth: "TLS_CLIENT_AUTH",
  SelfSignedTlsClientAuth: "SELF_SIGNED_TLS_CLIENT_AUTH",
} as const;
/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export type ServiceCreateApiSupportedTokenAuthMethodResponse = ClosedEnum<
  typeof ServiceCreateApiSupportedTokenAuthMethodResponse
>;

/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export const ServiceCreateApiSupportedRevocationAuthMethodResponse = {
  None: "NONE",
  ClientSecretBasic: "CLIENT_SECRET_BASIC",
  ClientSecretPost: "CLIENT_SECRET_POST",
  ClientSecretJwt: "CLIENT_SECRET_JWT",
  PrivateKeyJwt: "PRIVATE_KEY_JWT",
  TlsClientAuth: "TLS_CLIENT_AUTH",
  SelfSignedTlsClientAuth: "SELF_SIGNED_TLS_CLIENT_AUTH",
} as const;
/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export type ServiceCreateApiSupportedRevocationAuthMethodResponse = ClosedEnum<
  typeof ServiceCreateApiSupportedRevocationAuthMethodResponse
>;

/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export const ServiceCreateApiSupportedIntrospectionAuthMethodResponse = {
  None: "NONE",
  ClientSecretBasic: "CLIENT_SECRET_BASIC",
  ClientSecretPost: "CLIENT_SECRET_POST",
  ClientSecretJwt: "CLIENT_SECRET_JWT",
  PrivateKeyJwt: "PRIVATE_KEY_JWT",
  TlsClientAuth: "TLS_CLIENT_AUTH",
  SelfSignedTlsClientAuth: "SELF_SIGNED_TLS_CLIENT_AUTH",
} as const;
/**
 * The client authentication method that the client application declares that it uses at the token
 *
 * @remarks
 * endpoint. This property corresponds to `token_endpoint_auth_method` in [OpenID Connect Dynamic
 * Client Registration 1.0, 2. Client Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
 */
export type ServiceCreateApiSupportedIntrospectionAuthMethodResponse =
  ClosedEnum<typeof ServiceCreateApiSupportedIntrospectionAuthMethodResponse>;

export type ServiceCreateApiMtlsEndpointAliasResponse = {
  name?: string | undefined;
  uri?: string | undefined;
};

/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export const ServiceCreateApiAccessTokenSignAlgResponse = {
  None: "NONE",
  Hs256: "HS256",
  Hs384: "HS384",
  Hs512: "HS512",
  Rs256: "RS256",
  Rs384: "RS384",
  Rs512: "RS512",
  Es256: "ES256",
  Es384: "ES384",
  Es512: "ES512",
  Ps256: "PS256",
  Ps384: "PS384",
  Ps512: "PS512",
  Es256K: "ES256K",
  EdDSA: "EdDSA",
} as const;
/**
 * The signature algorithm for JWT. This value is represented on 'alg' attribute
 *
 * @remarks
 * of the header of JWT.
 *
 * it's semantics depends upon where is this defined, for instance:
 *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
 *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
 *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
 */
export type ServiceCreateApiAccessTokenSignAlgResponse = ClosedEnum<
  typeof ServiceCreateApiAccessTokenSignAlgResponse
>;

export type ServiceCreateApiDescriptionResponse = {
  /**
   * The language tag part.
   */
  tag?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ServiceCreateApiSupportedScopeAttributeResponse = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type ServiceCreateApiSupportedScopeResponse = {
  /**
   * The name of the scope.
   */
  name?: string | undefined;
  /**
   * `true` to mark the scope as default. Scopes marked as default are regarded as requested when an authorization request from a client application does not contain scope request parameter.
   */
  defaultEntry?: boolean | undefined;
  /**
   * The description about the scope.
   */
  description?: string | undefined;
  /**
   * The descriptions about this scope in multiple languages.
   */
  descriptions?: Array<ServiceCreateApiDescriptionResponse> | undefined;
  /**
   * The attributes of the scope.
   */
  attributes?:
    | Array<ServiceCreateApiSupportedScopeAttributeResponse>
    | undefined;
};

export const ServiceCreateApiSupportedClaimTypeResponse = {
  Normal: "NORMAL",
  Aggregated: "AGGREGATED",
  Distributed: "DISTRIBUTED",
} as const;
export type ServiceCreateApiSupportedClaimTypeResponse = ClosedEnum<
  typeof ServiceCreateApiSupportedClaimTypeResponse
>;

export const ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse = {
  Ping: "PING",
  Poll: "POLL",
  Push: "PUSH",
} as const;
export type ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse =
  ClosedEnum<
    typeof ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse
  >;

/**
 * The character set for end-user verification codes (`user_code`) for Device Flow.
 *
 * @remarks
 */
export const ServiceCreateApiUserCodeCharsetResponse = {
  Base20: "BASE20",
  Numeric: "NUMERIC",
} as const;
/**
 * The character set for end-user verification codes (`user_code`) for Device Flow.
 *
 * @remarks
 */
export type ServiceCreateApiUserCodeCharsetResponse = ClosedEnum<
  typeof ServiceCreateApiUserCodeCharsetResponse
>;

/**
 * OIDC4IDA / verifiedClaimsValidationSchemaSet
 *
 * @remarks
 */
export const ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse = {
  Standard: "standard",
  StandardPlusIdDocument: "standard+id_document",
} as const;
/**
 * OIDC4IDA / verifiedClaimsValidationSchemaSet
 *
 * @remarks
 */
export type ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse =
  ClosedEnum<typeof ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse>;

export type ServiceCreateApiAttributeResponse = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * Holds information about a key managed in an HSM (Hardware Security Module)
 *
 * @remarks
 */
export type ServiceCreateApiHskResponse = {
  /**
   * The key type (EC or RSA)
   *
   * @remarks
   */
  kty?: string | undefined;
  /**
   * Get the use of the key on the HSM.
   *
   * @remarks
   * When the key use is "sig" (signature), the private key on the HSM is used to sign data and the corresponding public key is used to verify the signature.
   * When the key use is "enc" (encryption), the private key on the HSM is used to decrypt encrypted data which have been encrypted with the corresponding public key
   */
  use?: string | undefined;
  /**
   * Key ID for the key on the HSM.
   *
   * @remarks
   */
  kid?: string | undefined;
  /**
   * The name of the HSM.
   *
   * @remarks
   * The identifier for the HSM that sits behind the Authlete server. For example, "google".
   */
  hsmName?: string | undefined;
  /**
   * The handle for the key on the HSM.
   *
   * @remarks
   * A handle is a base64url-encoded 256-bit random value (43 letters) which is assigned by Authlete on the call of the /api/hsk/create API
   */
  handle?: string | undefined;
  /**
   * The public key that corresponds to the key on the HSM.
   *
   * @remarks
   */
  publicKey?: string | undefined;
};

/**
 * Supported attachment types. This property corresponds to the `attachments_supported`
 *
 * @remarks
 *  server metadata which was added by the third implementer's draft of OpenID Connect
 *  for Identity Assurance 1.0.
 */
export const ServiceCreateApiSupportedAttachmentResponse = {
  Embedded: "EMBEDDED",
  External: "EXTERNAL",
} as const;
/**
 * Supported attachment types. This property corresponds to the `attachments_supported`
 *
 * @remarks
 *  server metadata which was added by the third implementer's draft of OpenID Connect
 *  for Identity Assurance 1.0.
 */
export type ServiceCreateApiSupportedAttachmentResponse = ClosedEnum<
  typeof ServiceCreateApiSupportedAttachmentResponse
>;

/**
 * Values for the `client_registration_types` RP metadata and the
 *
 * @remarks
 *  `client_registration_types_supported` OP metadata that are defined in
 *  [OpenID Connect Federation 1.0](https://openid.net/specs/openid-connect-federation-1_0.html).
 */
export const ServiceCreateApiSupportedClientRegistrationTypeResponse = {
  Automatic: "AUTOMATIC",
  Explicit: "EXPLICIT",
} as const;
/**
 * Values for the `client_registration_types` RP metadata and the
 *
 * @remarks
 *  `client_registration_types_supported` OP metadata that are defined in
 *  [OpenID Connect Federation 1.0](https://openid.net/specs/openid-connect-federation-1_0.html).
 */
export type ServiceCreateApiSupportedClientRegistrationTypeResponse =
  ClosedEnum<typeof ServiceCreateApiSupportedClientRegistrationTypeResponse>;

export type ServiceCreateApiTrustAnchorResponse = {
  /**
   * the entity ID of the trust anchor
   *
   * @remarks
   */
  entityId?: string | undefined;
  /**
   * the JWK Set document containing public keys of the trust anchor
   *
   * @remarks
   */
  jwks?: string | undefined;
};

/**
 * The prompt that the UI displayed to the end-user must satisfy as the minimum level. This value comes from `prompt` request parameter.
 *
 * @remarks
 *
 * When the authorization request does not contain `prompt` request parameter, `CONSENT` is used as the default value.
 *
 * See "[OpenID Connect Core 1.0, 3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest), prompt" for `prompt` request parameter.
 */
export const ServiceCreateApiSupportedPromptValueResponse = {
  None: "NONE",
  Login: "LOGIN",
  Consent: "CONSENT",
  SelectAccount: "SELECT_ACCOUNT",
} as const;
/**
 * The prompt that the UI displayed to the end-user must satisfy as the minimum level. This value comes from `prompt` request parameter.
 *
 * @remarks
 *
 * When the authorization request does not contain `prompt` request parameter, `CONSENT` is used as the default value.
 *
 * See "[OpenID Connect Core 1.0, 3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest), prompt" for `prompt` request parameter.
 */
export type ServiceCreateApiSupportedPromptValueResponse = ClosedEnum<
  typeof ServiceCreateApiSupportedPromptValueResponse
>;

export const ServiceCreateApiFapiModeResponse = {
  Fapi1Advanced: "FAPI1_ADVANCED",
  Fapi1Baseline: "FAPI1_BASELINE",
  Fapi2MessageSigningAuthReq: "FAPI2_MESSAGE_SIGNING_AUTH_REQ",
  Fapi2MessageSigningAuthRes: "FAPI2_MESSAGE_SIGNING_AUTH_RES",
  Fapi2MessageSigningIntrospectionRes:
    "FAPI2_MESSAGE_SIGNING_INTROSPECTION_RES",
  Fapi2Security: "FAPI2_SECURITY",
} as const;
export type ServiceCreateApiFapiModeResponse = ClosedEnum<
  typeof ServiceCreateApiFapiModeResponse
>;

export type ServiceCreateApiCredentialIssuerMetadataResponse = {
  /**
   * The identifier of a credential request.
   */
  credentialIssuer?: string | undefined;
  /**
   * The identifier of the authorization server that the credential issuer
   *
   * @remarks
   * relies on for authorization.
   */
  authorizationServer?: string | undefined;
  /**
   * The URL of the credential endpoint of the credential issuer.
   */
  credentialEndpoint?: boolean | undefined;
  /**
   * The URL of the batch credential endpoint of the credential issuer.
   */
  batchCredentialEndpoint?: number | undefined;
  /**
   * The URL of the deferred credential endpoint of the credential issuer.
   */
  deferredCredentialEndpoint?: string | undefined;
  /**
   * A JSON array describing supported credentials.
   */
  credentialsSupported?: boolean | undefined;
};

export type ServiceCreateApiResponse = {
  /**
   * The sequential number of the service. The value of this property is assigned by Authlete.
   */
  number?: number | undefined;
  /**
   * The name of this service.
   */
  serviceName?: string | undefined;
  /**
   * The issuer identifier of the service.
   *
   * @remarks
   *
   * A URL that starts with  https:// and has no query or fragment component.
   *
   * The value of this property is used as `iss` claim in an [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)
   * and `issuer` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  issuer?: string | undefined;
  /**
   * The description about the service.
   */
  description?: string | undefined;
  /**
   * The service ID used in Authlete API calls. The value of this property is assigned by Authlete.
   */
  apiKey?: number | undefined;
  /**
   * Deprecated. Always `true`.
   */
  clientIdAliasEnabled?: boolean | undefined;
  /**
   * The `metadata` of the service. The content of the returned array depends on contexts.
   *
   * @remarks
   * The predefined service metadata is listed in the following table.
   *
   *   | Key | Description |
   *   | --- | --- |
   *   | `clientCount` | The number of client applications which belong to this service.  |
   */
  metadata?: Array<ServiceCreateApiMetadatumResponse> | undefined;
  /**
   * The time at which this service was created. The value is represented as milliseconds since the
   *
   * @remarks
   * UNIX epoch (`1970-01-01`).
   */
  createdAt?: number | undefined;
  /**
   * The time at which this service was last modified. The value is represented as milliseconds since
   *
   * @remarks
   * the UNIX epoch (1970-01-01).
   */
  modifiedAt?: number | undefined;
  /**
   * A Web API endpoint for user authentication which is to be prepared on the service side.
   *
   * @remarks
   *
   * The endpoint must be implemented if you do not implement the UI at the authorization endpoint
   * but use the one provided by Authlete.
   *
   * The user authentication at the authorization endpoint provided by Authlete is performed by making
   * a `POST` request to this endpoint.
   */
  authenticationCallbackEndpoint?: string | undefined;
  /**
   * API key for basic authentication at the authentication callback endpoint.
   *
   * @remarks
   *
   * If the value is not empty, Authlete generates Authorization header for Basic authentication when
   * making a request to the authentication callback endpoint.
   */
  authenticationCallbackApiKey?: string | undefined;
  /**
   * API secret for `basic` authentication at the authentication callback endpoint.
   */
  authenticationCallbackApiSecret?: string | undefined;
  /**
   * Values of acrs (authentication context class references) that the service supports.
   *
   * @remarks
   *
   * The value of this property is used as `acr_values_supported`
   * property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedAcrs?: Array<string> | undefined;
  /**
   * Values of `grant_type` request parameter that the service supports.
   *
   * @remarks
   *
   * The value of this property is used as `grant_types_supported property` in the
   * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedGrantTypes?:
    | Array<ServiceCreateApiSupportedGrantTypeResponse>
    | undefined;
  /**
   * Values of `response_type` request parameter that
   *
   * @remarks
   * the service supports. Valid values are listed in Response Type.
   *
   * The value of this property is used as `response_types_supported` property in the
   * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedResponseTypes?:
    | Array<ServiceCreateApiSupportedResponseTypeResponse>
    | undefined;
  /**
   * The supported data types that can be used as values of the type field in `authorization_details`.
   *
   * @remarks
   *
   * This property corresponds to the `authorization_details_types_supported` metadata. See "OAuth 2.0
   * Rich Authorization Requests" (RAR) for details.
   */
  supportedAuthorizationDetailsTypes?: Array<string> | undefined;
  /**
   * The profiles that this service supports.
   *
   * @remarks
   */
  supportedServiceProfiles?:
    | Array<ServiceCreateApiSupportedServiceProfileResponse>
    | undefined;
  /**
   * The flag to indicate whether the `error_description` response parameter is omitted.
   *
   * @remarks
   *
   * According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include
   * the `error_description` response parameter in error responses.
   *
   * If `true`, Authlete does not embed the `error_description` response parameter in error responses.
   */
  errorDescriptionOmitted?: boolean | undefined;
  /**
   * The flag to indicate whether the `error_uri` response parameter is omitted.
   *
   * @remarks
   *
   * According to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include the `error_uri` response parameter in error responses.
   *
   * If `true`, Authlete does not embed the
   * `error_uri` response parameter in error responses.
   */
  errorUriOmitted?: boolean | undefined;
  /**
   * The authorization endpoint of the service.
   *
   * @remarks
   *
   * A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/authorization`.
   *
   * The value of this property is used as `authorization_endpoint` property in the [OpenID Provider
   * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  authorizationEndpoint?: string | undefined;
  /**
   * The flag to indicate whether the direct authorization endpoint is enabled or not.
   *
   * @remarks
   *
   * The path of the endpoint is `/api/auth/authorization/direct/service-api-key`.
   */
  directAuthorizationEndpointEnabled?: boolean | undefined;
  /**
   * UI locales that the service supports.
   *
   * @remarks
   *
   * Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646). For example, `en-US` and `ja-JP`.
   *
   * The value of this property is used as `ui_locales_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedUiLocales?: Array<string> | undefined;
  /**
   * Values of `display` request parameter that service supports.
   *
   * @remarks
   *
   * The value of this property is used as `display_values_supported` property in the Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedDisplays?:
    | Array<ServiceCreateApiSupportedDisplayResponse>
    | undefined;
  /**
   * The flag to indicate whether the use of Proof Key for Code Exchange (PKCE) is always required for authorization requests by Authorization Code Flow.
   *
   * @remarks
   *
   * If `true`, `code_challenge` request parameter is always required for authorization requests using Authorization Code Flow.
   *
   * See [RFC 7636](https://tools.ietf.org/html/rfc7636) (Proof Key for Code Exchange by OAuth Public Clients) for details about `code_challenge` request parameter.
   */
  pkceRequired?: boolean | undefined;
  /**
   * The flag to indicate whether `S256` is always required as the code challenge method whenever [PKCE (RFC 7636)](https://tools.ietf.org/html/rfc7636) is used.
   *
   * @remarks
   *
   * If this flag is set to `true`, `code_challenge_method=S256` must be included in the authorization request
   * whenever it includes the `code_challenge` request parameter.
   * Neither omission of the `code_challenge_method` request parameter nor use of plain (`code_challenge_method=plain`) is allowed.
   */
  pkceS256Required?: boolean | undefined;
  /**
   * The duration of authorization response JWTs in seconds.
   *
   * @remarks
   *
   * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
   * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
   * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
   * from the authorization endpoint will be packed into a JWT. This property is used to compute the
   * value of the `exp` claim of the JWT.
   */
  authorizationResponseDuration?: number | undefined;
  /**
   * The [token endpoint](https://tools.ietf.org/html/rfc6749#section-3.2) of the service.
   *
   * @remarks
   *
   * A URL that starts with `https://` and has not fragment component. For example, `https://example.com/auth/token`.
   *
   * The value of this property is used as `token_endpoint` property in the
   * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  tokenEndpoint?: string | undefined;
  /**
   * The flag to indicate whether the direct token endpoint is enabled or not. The path of the endpoint
   *
   * @remarks
   * is `/api/auth/token/direct/service-api-key`.
   */
  directTokenEndpointEnabled?: boolean | undefined;
  /**
   * Client authentication methods supported by the token endpoint of the service.
   *
   * @remarks
   *
   * The value of this property is used as `token_endpoint_auth_methods_supports` property in the
   * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedTokenAuthMethods?:
    | Array<ServiceCreateApiSupportedTokenAuthMethodResponse>
    | undefined;
  /**
   * The flag to indicate token requests from public clients without the `client_id` request parameter are allowed when the client can be guessed from `authorization_code` or `refresh_token`.
   *
   * @remarks
   *
   * This flag should not be set unless you have special reasons.
   */
  missingClientIdAllowed?: boolean | undefined;
  /**
   * The [revocation endpoint](https://tools.ietf.org/html/rfc7009) of the service.
   *
   * @remarks
   *
   * A URL that starts with `https://`. For example, `https://example.com/auth/revocation`.
   */
  revocationEndpoint?: string | undefined;
  /**
   * The flag to indicate whether the direct revocation endpoint is enabled or not. The URL of the endpoint is `/api/auth/revocation/direct/service-api-key`.
   */
  directRevocationEndpointEnabled?: boolean | undefined;
  /**
   * Client authentication methods supported at the revocation endpoint.
   *
   * @remarks
   */
  supportedRevocationAuthMethods?:
    | Array<ServiceCreateApiSupportedRevocationAuthMethodResponse>
    | undefined;
  /**
   * The URI of the introspection endpoint.
   */
  introspectionEndpoint?: string | undefined;
  /**
   * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path of the endpoint is `/api/auth/userinfo/direct/{serviceApiKey}`.
   */
  directIntrospectionEndpointEnabled?: boolean | undefined;
  /**
   * Client authentication methods supported at the introspection endpoint.
   *
   * @remarks
   */
  supportedIntrospectionAuthMethods?:
    | Array<ServiceCreateApiSupportedIntrospectionAuthMethodResponse>
    | undefined;
  /**
   * The URI of the pushed authorization request endpoint.
   *
   * @remarks
   *
   * This property corresponds to the `pushed_authorization_request_endpoint` metadata defined in "[5. Authorization Server Metadata](https://tools.ietf.org/html/draft-lodderstedt-oauth-par#section-5)" of OAuth 2.0 Pushed Authorization Requests.
   */
  pushedAuthReqEndpoint?: string | undefined;
  /**
   * The duration of pushed authorization requests in seconds.
   *
   * @remarks
   *
   * [OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par)
   * defines an endpoint (called "pushed authorization request endpoint") which client applications
   * can register authorization requests into and get corresponding URIs (called "request URIs") from.
   * The issued URIs represent the registered authorization requests. The client applications can use
   * the URIs as the value of the `request_uri` request parameter in an authorization request.
   *
   * The property represents the duration of registered authorization requests and is used as the value
   * of the `expires_in` parameter in responses from the pushed authorization request endpoint.
   */
  pushedAuthReqDuration?: number | undefined;
  /**
   * The flag to indicate whether this service requires that clients use the pushed authorization
   *
   * @remarks
   * request endpoint.
   *
   * This property corresponds to the `require_pushed_authorization_requests` server metadata defined
   * in [OAuth 2.0 Pushed Authorization Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par).
   */
  parRequired?: boolean | undefined;
  /**
   * The flag to indicate whether this service requires that authorization requests always utilize
   *
   * @remarks
   * a request object by using either request or `request_uri` request parameter.
   *
   * If this flag is set to `true` and the value of `traditionalRequestObjectProcessingApplied` is
   * `false`, the value of `require_signed_request_object` server metadata of this service is reported
   * as `true` in the discovery document. The metadata is defined in JAR (JWT Secured Authorization Request).
   * That `require_signed_request_object` is `true` means that authorization requests which don't
   * conform to the JAR specification are rejected.
   */
  requestObjectRequired?: boolean | undefined;
  /**
   * The flag to indicate whether a request object is processed based on rules defined in
   *
   * @remarks
   * [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) or JAR (JWT
   * Secured Authorization Request).
   *
   * Differences between rules in OpenID Connect Core 1.0 and ones in JAR are as follows.
   *   - JAR requires that a request object be always -signed.
   *   - JAR does not allow request parameters outside a request object to be referred to.
   *   - OIDC Core 1.0 requires that response_type request parameter exist outside a request object even if the request object includes the request parameter.
   *   - OIDC Core 1.0 requires that scope request parameter exist outside a request object if the authorization request is an
   *   - OIDC request even if the request object includes the request parameter.
   *
   * If this flag is set to `false` and the value of `requestObjectRequired` is `true`, the value of
   * `require_signed_request_object` server metadata of this service
   * is reported as `true` in the discovery document. The metadata is defined in JAR (JWT Secured
   * Authorization Request). That `require_signed_request_object` is `true` means that authorization
   * requests which don't conform to the JAR specification are rejected.
   */
  traditionalRequestObjectProcessingApplied?: boolean | undefined;
  /**
   * The flag to indicate whether this service validates certificate chains during PKI-based client mutual TLS authentication.
   *
   * @remarks
   */
  mutualTlsValidatePkiCertChain?: boolean | undefined;
  /**
   * The list of root certificates trusted by this service for PKI-based client mutual TLS authentication.
   *
   * @remarks
   */
  trustedRootCertificates?: Array<string> | undefined;
  /**
   * The MTLS endpoint aliases.
   *
   * @remarks
   *
   * This property corresponds to the mtls_endpoint_aliases metadata defined in "5. Metadata for Mutual TLS Endpoint Aliases" of [OAuth 2.0 Mutual TLS Client Authentication and Certificate-Bound Access Tokens](https://datatracker.ietf.org/doc/rfc8705/).
   *
   * The aliases will be embedded in the response from the discovery endpoint like the following.
   *
   * ```json
   * {
   *   ......,
   *   "mtls_endpoint_aliases": {
   *     "token_endpoint":         "https://mtls.example.com/token",
   *     "revocation_endpoint":    "https://mtls.example.com/revo",
   *     "introspection_endpoint": "https://mtls.example.com/introspect"
   *   }
   * }
   * ```
   */
  mtlsEndpointAliases?:
    | Array<ServiceCreateApiMtlsEndpointAliasResponse>
    | undefined;
  /**
   * The access token type.
   *
   * @remarks
   *
   * This value is used as the value of `token_type` property in access token responses. If this service
   * complies with [RFC 6750](https://tools.ietf.org/html/rfc6750), the value of this property should
   * be `Bearer`.
   *
   * See [RFC 6749 (OAuth 2.0), 7.1. Access Token Types](https://tools.ietf.org/html/rfc6749#section-7.1) for details.
   */
  accessTokenType?: string | undefined;
  /**
   * The flag to indicate whether this service supports issuing TLS client certificate bound access tokens.
   *
   * @remarks
   */
  tlsClientCertificateBoundAccessTokens?: boolean | undefined;
  /**
   * The duration of access tokens in seconds. This value is used as the value of `expires_in` property
   *
   * @remarks
   * in access token responses. `expires_in` is defined [RFC 6749, 5.1. Successful Response](https://tools.ietf.org/html/rfc6749#section-5.1).
   */
  accessTokenDuration?: number | undefined;
  /**
   * The flag to indicate whether the number of access tokens per subject (and per client) is at most one or can be more.
   *
   * @remarks
   *
   * If `true`, an attempt to issue a new access token invalidates existing access tokens that are associated with the same subject and the same client.
   *
   * Note that, however, attempts by [Client Credentials Flow](https://tools.ietf.org/html/rfc6749#section-4.4) do not invalidate existing access tokens because access tokens issued by Client Credentials Flow are not associated with any end-user's subject. Also note that an attempt by [Refresh Token Flow](https://tools.ietf.org/html/rfc6749#section-6) invalidates the coupled access token only and this invalidation is always performed regardless of whether the value of this setting item is `true` or `false`.
   */
  singleAccessTokenPerSubject?: boolean | undefined;
  /**
   * The signature algorithm for JWT. This value is represented on 'alg' attribute
   *
   * @remarks
   * of the header of JWT.
   *
   * it's semantics depends upon where is this defined, for instance:
   *   - as service accessTokenSignAlg value, it defines that access token are JWT and the algorithm used to sign it. Check your [KB article](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/jwt-based-access-token).
   *   - as client authorizationSignAlg value, it represents the signature algorithm used when [creating a JARM response](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/enabling-jarm).
   *   - or as client requestSignAlg value, it specifies which is the expected signature used by [client on a Request Object](https://kb.authlete.com/en/s/oauth-and-openid-connect/a/request-objects).
   */
  accessTokenSignAlg?: ServiceCreateApiAccessTokenSignAlgResponse | undefined;
  /**
   * The key ID to identify a JWK used for signing access tokens.
   *
   * @remarks
   *
   * A JWK Set can be registered as a property of a service. A JWK Set can contain 0 or more JWKs.
   * Authlete Server has to pick up one JWK for signing from the JWK Set when it generates a JWT-based
   * access token. Authlete Server searches the registered JWK Set for a JWK which satisfies conditions
   * for access token signature. If the number of JWK candidates which satisfy the conditions is 1,
   * there is no problem. On the other hand, if there exist multiple candidates, a Key ID is needed
   * to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
   */
  accessTokenSignatureKeyId?: string | undefined;
  /**
   * The duration of refresh tokens in seconds. The related specifications have no requirements on refresh token duration, but Authlete sets expiration for refresh tokens.
   */
  refreshTokenDuration?: number | undefined;
  /**
   * The flag to indicate whether the remaining duration of the used refresh token is taken over to
   *
   * @remarks
   * the newly issued refresh token.
   */
  refreshTokenDurationKept?: boolean | undefined;
  /**
   * The flag which indicates whether duration of refresh tokens are reset when they are used even
   *
   * @remarks
   * if the `refreshTokenKept` property of this service set to is `true` (= even if "Refresh Token
   * Continuous Use" is "Kept").
   *
   * This flag has no effect when the `refreshTokenKept` property is set to `false`. In other words,
   * if this service issues a new refresh token on every refresh token request, the refresh token
   * will have fresh duration (unless `refreshTokenDurationKept` is set to `true`) and this
   * `refreshTokenDurationReset` property is not referenced.
   */
  refreshTokenDurationReset?: boolean | undefined;
  /**
   * The flag to indicate whether a refresh token remains unchanged or gets renewed after its use.
   *
   * @remarks
   *
   * If `true`, a refresh token used to get a new access token remains valid after its use. Otherwise, if `false`, a refresh token is invalidated after its use and a new refresh token is issued.
   *
   * See [RFC 6749 6. Refreshing an Access Token](https://tools.ietf.org/html/rfc6749#section-6), as to how to get a new access token using a refresh token.
   */
  refreshTokenKept?: boolean | undefined;
  /**
   * Scopes supported by the service.
   *
   * @remarks
   *
   * Authlete strongly recommends that the service register at least the following scopes.
   *
   * | Name | Description |
   * | --- | --- |
   * | openid | A permission to get an ID token of an end-user. The `openid` scope appears in [OpenID Connect Core 1.0, 3.1.2.1. Authentication Request, scope](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest). Without this scope, Authlete does not allow `response_type` request parameter to have values other than code and token. |
   * | profile | A permission to get information about `name`, `family_name`, `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`, `website`, `gender`, `birthdate`, `zoneinfo`, `locale` and `updated_at` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
   * | email | A permission to get information about `email` and `email_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
   * | address | A permission to get information about address from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) and [5.1.1. Address Claim](https://openid.net/specs/openid-connect-core-1_0.html#AddressClaim) for details. |
   * | phone | A permission to get information about `phone_number` and `phone_number_verified` from the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. |
   * | offline_access | A permission to get information from the user info endpoint even when the end-user is not present. See [OpenID Connect Core 1.0, 11. Offline Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess) for details. |
   *
   * The value of this property is used as `scopes_supported` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedScopes?: Array<ServiceCreateApiSupportedScopeResponse> | undefined;
  /**
   * The flag to indicate whether requests that request no scope are rejected or not.
   *
   * @remarks
   *
   * When a request has no explicit `scope` parameter and the service's pre-defined default scope set is empty,
   * the authorization server regards the request requests no scope. When this flag is set to `true`,
   * requests that request no scope are rejected.
   *
   * The requirement below excerpted from [RFC 6749 Section 3.3](https://tools.ietf.org/html/rfc6749#section-3.3)
   * does not explicitly mention the case where the default scope set is empty.
   *
   * > If the client omits the scope parameter when requesting authorization, the authorization server
   * MUST either process the request using a pre-defined default value or fail the request indicating an invalid scope.
   *
   * However, if you interpret *"the default scope set exists but is empty"* as *"the default scope set does not exist"*
   * and want to strictly conform to the requirement above, this flag has to be `true`.
   */
  scopeRequired?: boolean | undefined;
  /**
   * 'The duration of [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)s
   *
   * @remarks
   * in seconds. This value is used to calculate the value of `exp` claim in an ID token.'
   */
  idTokenDuration?: number | undefined;
  /**
   * The allowable clock skew between the server and clients in seconds.
   *
   * @remarks
   *
   * The clock skew is taken into consideration when time-related claims in a JWT (e.g. `exp`, `iat`, `nbf`) are verified.
   */
  allowableClockSkew?: number | undefined;
  /**
   * Claim types supported by the service. Valid values are listed in Claim Type. Note that Authlete
   *
   * @remarks
   * currently doesn't provide any API to help implementations for `AGGREGATED` and `DISTRIBUTED`.
   *
   * The value of this property is used as `claim_types_supported` property in the [OpenID Provider
   * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedClaimTypes?:
    | Array<ServiceCreateApiSupportedClaimTypeResponse>
    | undefined;
  /**
   * Claim locales that the service supports. Each element is a language tag defined in [RFC 5646](https://tools.ietf.org/html/rfc5646).
   *
   * @remarks
   * For example, `en-US` and `ja-JP`. See [OpenID Connect Core 1.0, 5.2. Languages and Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts)
   * for details.
   *
   * The value of this property is used as `claims_locales_supported` property in the
   * [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  supportedClaimLocales?: Array<string> | undefined;
  /**
   * Claim names that the service supports. The standard claim names listed in [OpenID Connect Core 1.0,
   *
   * @remarks
   * 5.1. Standard Claim](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) should
   * be supported. The following is the list of standard claims.
   *
   * - `sub`
   * - `name`
   * - `given_name`
   * - `family_name`
   * - `middle_name`
   * - `nickname`
   * - `preferred_username`
   * - `profile`
   * - `picture`
   * - `website`
   * - `email`
   * - `email_verified`
   * - `gender`
   * - `birthdate`
   * - `zoneinfo`
   * - `locale`
   * - `phone_number`
   * - `phone_number_verified`
   * - `address`
   * - `updated_at`
   *
   * The value of this property is used as `claims_supported` property in the [OpenID Provider
   * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   *
   * The service may support its original claim names. See [OpenID Connect Core 1.0, 5.1.2. Additional
   * Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims).
   */
  supportedClaims?: Array<string> | undefined;
  /**
   * The flag indicating whether claims specified by shortcut scopes (e.g. `profile`) are included
   *
   * @remarks
   * in the issued ID token only when no access token is issued.
   *
   * To strictly conform to the description below excerpted from [OpenID Connect Core 1.0 Section
   * 5.4](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims), this flag has to be `true`.
   *
   * > The Claims requested by the profile, email, address, and phone scope values are returned from
   * the UserInfo Endpoint, as described in Section 5.3.2, when a response_type value is used that
   * results in an Access Token being issued. However, when no Access Token is issued (which is the
   * case for the response_type value id_token), the resulting Claims are returned in the ID Token.
   */
  claimShortcutRestrictive?: boolean | undefined;
  /**
   * The URL of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document. For
   *
   * @remarks
   * example, `http://example.com/auth/jwks`.
   *
   * Client applications accesses this URL (1) to get the public key of the service to validate the
   * signature of an ID token issued by the service and (2) to get the public key of the service to
   * encrypt an request object of the client application. See [OpenID Connect Core 1.0, 10. Signatures
   * and Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
   *
   * The value of this property is used as `jwks_uri` property in the [OpenID Provider Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  jwksUri?: string | undefined;
  /**
   * 'The flag to indicate whether the direct jwks endpoint is enabled or not. The path of the endpoint
   *
   * @remarks
   * is `/api/service/jwks/get/direct/service-api-key`. '
   */
  directJwksEndpointEnabled?: boolean | undefined;
  /**
   * The content of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document.
   *
   * @remarks
   *
   * If this property is not `null` in a `/service/create` request or a `/service/update` request,
   * Authlete hosts the content in the database. This property must not be `null` and must contain
   * pairs of public/private keys if the service wants to support asymmetric signatures for ID tokens
   * and asymmetric encryption for request objects. See [OpenID Connect Core 1.0, 10. Signatures and
   * Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details.
   */
  jwks?: string | undefined;
  /**
   * The key ID to identify a JWK used for ID token signature using an asymmetric key.
   *
   * @remarks
   *
   * A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
   * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
   * to pick up one JWK for signature from the JWK Set when it generates an ID token and signature
   * using an asymmetric key is required. Authlete Server searches the registered JWK Set for a JWK
   * which satisfies conditions for ID token signature. If the number of JWK candidates which satisfy
   * the conditions is 1, there is no problem. On the other hand, if there exist multiple candidates,
   * a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5) is needed to be specified so that
   * Authlete Server can pick up one JWK from among the JWK candidates.
   *
   * This `idTokenSignatureKeyId` property exists for the purpose described above. For key rotation
   * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
   * this mechanism is needed.
   */
  idTokenSignatureKeyId?: string | undefined;
  /**
   * The key ID to identify a JWK used for user info signature using an asymmetric key.
   *
   * @remarks
   *
   * A JWK Set can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs
   * (See [RFC 7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has
   * to pick up one JWK for signature from the JWK Set when it is required to sign user info (which
   * is returned from [userinfo endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo))
   * using an asymmetric key. Authlete Server searches the registered JWK Set for a JWK which satisfies
   * conditions for user info signature. If the number of JWK candidates which satisfy the conditions
   * is 1, there is no problem. On the other hand, if there exist multiple candidates, a [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5)
   * is needed to be specified so that Authlete Server can pick up one JWK from among the JWK candidates.
   *
   * This `userInfoSignatureKeyId` property exists for the purpose described above. For key rotation
   * (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)),
   * this mechanism is needed.
   */
  userInfoSignatureKeyId?: string | undefined;
  /**
   * The key ID to identify a JWK used for signing authorization responses using an asymmetric key.
   *
   * @remarks
   *
   * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
   * defines new values for the `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`,
   * `form_post.jwt` and `jwt`. If one of them is specified as the response mode, response parameters
   * from the authorization endpoint will be packed into a JWT. This property is used to compute the
   * value of the `exp` claim of the JWT.
   *
   * Authlete Server searches the JWK Set for a JWK which satisfies conditions for authorization response
   * signature. If the number of JWK candidates which satisfy the conditions is 1, there is no problem.
   * On the other hand, if there exist multiple candidates, a Key ID is needed to be specified so that
   * Authlete Server can pick up one JWK from among the JWK candidates. This property exists to specify
   * the key ID.
   */
  authorizationSignatureKeyId?: string | undefined;
  /**
   * The [user info endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo) of the
   *
   * @remarks
   * service. A URL that starts with `https://`. For example, `https://example.com/auth/userinfo`.
   *
   * The value of this property is used as `userinfo_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  userInfoEndpoint?: string | undefined;
  /**
   * The flag to indicate whether the direct userinfo endpoint is enabled or not. The path
   *
   * @remarks
   * of the endpoint is `/api/auth/userinfo/direct/service-api-key`.
   */
  directUserInfoEndpointEnabled?: boolean | undefined;
  /**
   * The boolean flag which indicates whether the [OAuth 2.0 Dynamic Client Registration Protocol](https://tools.ietf.org/html/rfc7591)
   *
   * @remarks
   * is supported.
   */
  dynamicRegistrationSupported?: boolean | undefined;
  /**
   * The [registration endpoint](http://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration)
   *
   * @remarks
   * of the service. A URL that starts with `https://`. For example, `https://example.com/auth/registration`.
   *
   * The value of this property is used as `registration_endpoint` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  registrationEndpoint?: string | undefined;
  /**
   * The URI of the registration management endpoint. If dynamic client registration is supported,
   *
   * @remarks
   * and this is set, this URI will be used as the basis of the client's management endpoint by appending
   * `/clientid}/` to it as a path element. If this is unset, the value of `registrationEndpoint` will
   * be used as the URI base instead.
   */
  registrationManagementEndpoint?: string | undefined;
  /**
   * The URL of the "Policy" of the service.
   *
   * @remarks
   *
   * The value of this property is used as `op_policy_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  policyUri?: string | undefined;
  /**
   * The URL of the "Terms Of Service" of the service.
   *
   * @remarks
   *
   * The value of this property is used as `op_tos_uri` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  tosUri?: string | undefined;
  /**
   * The URL of a page where documents for developers can be found.
   *
   * @remarks
   *
   * The value of this property is used as `service_documentation` property in the [OpenID Provider Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  serviceDocumentation?: string | undefined;
  /**
   * The URI of backchannel authentication endpoint, which is defined in the specification of [CIBA
   *
   * @remarks
   * (Client Initiated Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
   */
  backchannelAuthenticationEndpoint?: string | undefined;
  /**
   * The supported backchannel token delivery modes. This property corresponds to the `backchannel_token_delivery_modes_supported`
   *
   * @remarks
   * metadata.
   *
   * Backchannel token delivery modes are defined in the specification of [CIBA (Client Initiated
   * Backchannel Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
   */
  supportedBackchannelTokenDeliveryModes?:
    | Array<ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse>
    | undefined;
  /**
   * The duration of backchannel authentication request IDs issued from the backchannel authentication
   *
   * @remarks
   * endpoint in seconds. This is used as the value of the `expires_in` property in responses from
   * the backchannel authentication endpoint.
   */
  backchannelAuthReqIdDuration?: number | undefined;
  /**
   * The minimum interval between polling requests to the token endpoint from client applications in
   *
   * @remarks
   * seconds. This is used as the value of the `interval` property in responses from the backchannel
   * authentication endpoint.
   */
  backchannelPollingInterval?: number | undefined;
  /**
   * The boolean flag which indicates whether the `user_code` request parameter is supported at the
   *
   * @remarks
   * backchannel authentication endpoint. This property corresponds to the `backchannel_user_code_parameter_supported`
   * metadata.
   */
  backchannelUserCodeParameterSupported?: boolean | undefined;
  /**
   * The flag to indicate whether the `binding_message` request parameter is always required whenever
   *
   * @remarks
   * a backchannel authentication request is judged as a request for Financial-grade API.
   *
   * The FAPI-CIBA profile requires that the authorization server _"shall ensure unique authorization
   * context exists in the authorization request or require a `binding_message` in the authorization
   * request"_ (FAPI-CIBA, 5.2.2, 2). The simplest way to fulfill this requirement is to set this property
   * to `true`.
   *
   * If this property is set to `false`, the `binding_message` request parameter remains optional
   * even in FAPI context, but in exchange, your authorization server must implement a custom mechanism
   * that ensures each backchannel authentication request has unique context.
   */
  backchannelBindingMessageRequiredInFapi?: boolean | undefined;
  /**
   * The URI of the device authorization endpoint.
   *
   * @remarks
   *
   * Device authorization endpoint is defined in the specification of OAuth 2.0 Device Authorization Grant.
   */
  deviceAuthorizationEndpoint?: string | undefined;
  /**
   * The verification URI for the device flow. This URI is used as the value of the `verification_uri`
   *
   * @remarks
   * parameter in responses from the device authorization endpoint.
   */
  deviceVerificationUri?: string | undefined;
  /**
   * The verification URI for the device flow with a placeholder for a user code. This URI is used
   *
   * @remarks
   * to build the value of the `verification_uri_complete` parameter in responses from the device
   * authorization endpoint.
   *
   * It is expected that the URI contains a fixed string `USER_CODE` somewhere as a placeholder for
   * a user code. For example, like the following.
   *
   * `https://example.com/device?user\_code=USER\_CODE`
   *
   * The fixed string is replaced with an actual user code when Authlete builds a verification URI
   * with a user code for the `verification_uri_complete` parameter.
   *
   * If this URI is not set, the `verification_uri_complete` parameter won't appear in device authorization
   * responses.
   */
  deviceVerificationUriComplete?: string | undefined;
  /**
   * The duration of device verification codes and end-user verification codes issued from the device
   *
   * @remarks
   * authorization endpoint in seconds. This is used as the value of the `expires_in` property in responses
   * from the device authorization endpoint.
   */
  deviceFlowCodeDuration?: number | undefined;
  /**
   * The minimum interval between polling requests to the token endpoint from client applications in
   *
   * @remarks
   * seconds in device flow. This is used as the value of the `interval` property in responses from
   * the device authorization endpoint.
   */
  deviceFlowPollingInterval?: number | undefined;
  /**
   * The character set for end-user verification codes (`user_code`) for Device Flow.
   *
   * @remarks
   */
  userCodeCharset?: ServiceCreateApiUserCodeCharsetResponse | undefined;
  /**
   * The length of end-user verification codes (`user_code`) for Device Flow.
   *
   * @remarks
   */
  userCodeLength?: number | undefined;
  /**
   * Trust frameworks supported by this service. This corresponds to the `trust_frameworks_supported`
   *
   * @remarks
   * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
   */
  supportedTrustFrameworks?: Array<string> | undefined;
  /**
   * Evidence supported by this service. This corresponds to the `evidence_supported` [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
   *
   * @remarks
   */
  supportedEvidence?: Array<string> | undefined;
  /**
   * Identity documents supported by this service. This corresponds to the `id_documents_supported`
   *
   * @remarks
   * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
   */
  supportedIdentityDocuments?: Array<string> | undefined;
  /**
   * Verification methods supported by this service. This corresponds to the `id_documents_verification_methods_supported`
   *
   * @remarks
   * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
   */
  supportedVerificationMethods?: Array<string> | undefined;
  /**
   * Verified claims supported by this service. This corresponds to the `claims_in_verified_claims_supported`
   *
   * @remarks
   * [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
   */
  supportedVerifiedClaims?: Array<string> | undefined;
  /**
   * OIDC4IDA / verifiedClaimsValidationSchemaSet
   *
   * @remarks
   */
  verifiedClaimsValidationSchemaSet?:
    | ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse
    | undefined;
  /**
   * The attributes of this service.
   *
   * @remarks
   */
  attributes?: Array<ServiceCreateApiAttributeResponse> | undefined;
  /**
   * The flag indicating whether the nbf claim in the request object is optional even when the authorization
   *
   * @remarks
   * request is regarded as a FAPI-Part2 request.
   *
   * The final version of Financial-grade API was approved in January, 2021. The Part 2 of the final
   * version has new requirements on lifetime of request objects. They require that request objects
   * contain an `nbf` claim and the lifetime computed by `exp` - `nbf` be no longer than 60 minutes.
   *
   * Therefore, when an authorization request is regarded as a FAPI-Part2 request, the request object
   * used in the authorization request must contain an nbf claim. Otherwise, the authorization server
   * rejects the authorization request.
   *
   * When this flag is `true`, the `nbf` claim is treated as an optional claim even when the authorization
   * request is regarded as a FAPI-Part2 request. That is, the authorization server does not perform
   * the validation on lifetime of the request object.
   *
   * Skipping the validation is a violation of the FAPI specification. The reason why this flag has
   * been prepared nevertheless is that the new requirements (which do not exist in the Implementer's
   * Draft 2 released in October, 2018) have big impacts on deployed implementations of client
   * applications and Authlete thinks there should be a mechanism whereby to make the migration
   * from ID2 to Final smooth without breaking live systems.
   */
  nbfOptional?: boolean | undefined;
  /**
   * The flag indicating whether generation of the iss response parameter is suppressed.
   *
   * @remarks
   *
   * "OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response" has defined a new
   * authorization response parameter, `iss`, as a countermeasure for a certain type of mix-up attacks.
   *
   * The specification requires that the `iss` response parameter always be included in authorization
   * responses unless JARM (JWT Secured Authorization Response Mode) is used.
   *
   * When this flag is `true`, the authorization server does not include the `iss` response parameter
   * in authorization responses. By turning this flag on and off, developers of client applications
   * can experiment the mix-up attack and the effect of the `iss` response parameter.
   *
   * Note that this flag should not be `true` in production environment unless there are special
   * reasons for it.
   */
  issSuppressed?: boolean | undefined;
  /**
   * custom client metadata supported by this service.
   *
   * @remarks
   *
   * Standard specifications define client metadata as necessary. The following are such examples.
   *
   * * [OpenID Connect Dynamic Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html)
   * * [RFC 7591 OAuth 2.0 Dynamic Client Registration Protocol](https://www.rfc-editor.org/rfc/rfc7591.html)
   * * [RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens](https://www.rfc-editor.org/rfc/rfc8705.html)
   * * [OpenID Connect Client-Initiated Backchannel Authentication Flow - Core 1.0](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html)
   * * [The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request (JAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-jwsreq/)
   * * [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0 (JARM)](https://openid.net/specs/openid-financial-api-jarm.html)
   * * [OAuth 2.0 Pushed Authorization Requests (PAR)](https://datatracker.ietf.org/doc/rfc9126/)
   * * [OAuth 2.0 Rich Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/)
   *
   * Standard client metadata included in Client Registration Request and Client Update Request (cf.
   * [OIDC DynReg](https://openid.net/specs/openid-connect-registration-1_0.html), [RFC 7591](https://www.rfc-editor.org/rfc/rfc7591.html)
   * and [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)) are, if supported by Authlete, stored
   * into Authlete database. On the other hand, unrecognized client metadata are discarded.
   *
   * By listing up custom client metadata in advance by using this property (`supportedCustomClientMetadata`),
   * Authlete can recognize them and stores their values into the database. The stored custom client
   * metadata values can be referenced by `customMetadata`.
   */
  supportedCustomClientMetadata?: Array<string> | undefined;
  /**
   * The flag indicating whether the expiration date of an access token never exceeds that of the
   *
   * @remarks
   * corresponding refresh token.
   *
   * When a new access token is issued by a refresh token request (= a token request with `grant_type=refresh_token`),
   * the expiration date of the access token may exceed the expiration date of the corresponding
   * refresh token. This behavior itself is not wrong and may happen when `refreshTokenKept` is
   * `true` and/or when `refreshTokenDurationKept` is `true`.
   *
   * When this flag is `true`, the expiration date of an access token never exceeds that of the corresponding
   * refresh token regardless of the calculated duration based on other settings such as `accessTokenDuration`,
   * `accessTokenDuration` in `extension` and `access_token.duration` scope attribute.
   *
   * It is technically possible to set a value which is bigger than the duration of refresh tokens
   * as the duration of access tokens although it is strange. In the case, the duration of an access
   * token becomes longer than the duration of the refresh token which is issued together with the
   * access token. Even if the duration values are configured so, if this flag is `true`, the expiration
   * date of the access token does not exceed that of the refresh token. That is, the duration of
   * the access token will be shortened, and as a result, the access token and the refresh token
   * will have the same expiration date.
   */
  tokenExpirationLinked?: boolean | undefined;
  /**
   * The flag indicating whether encryption of request object is required when the request object
   *
   * @remarks
   * is passed through the front channel.
   *
   * This flag does not affect the processing of request objects at the Pushed Authorization Request
   * Endpoint, which is defined in [OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/).
   * Unecrypted request objects are accepted at the endpoint even if this flag is `true`.
   *
   * This flag does not indicate whether a request object is always required. There is a different
   * flag, `requestObjectRequired`, for the purpose. See the description of `requestObjectRequired`
   * for details.
   *
   * Even if this flag is `false`, encryption of request object is required if the `frontChannelRequestObjectEncryptionRequired`
   * flag of the client is `true`.
   */
  frontChannelRequestObjectEncryptionRequired?: boolean | undefined;
  /**
   * The flag indicating whether the JWE alg of encrypted request object must match the `request_object_encryption_alg`
   *
   * @remarks
   * client metadata of the client that has sent the request object.
   *
   * The request_object_encryption_alg client metadata itself is defined in [OpenID Connect Dynamic
   * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
   *
   * > request_object_encryption_alg
   * >
   * > OPTIONAL. JWE [JWE] alg algorithm [JWA] the RP is declaring that it may use for encrypting
   * Request Objects sent to the OP. This parameter SHOULD be included when symmetric encryption
   * will be used, since this signals to the OP that a client_secret value needs to be returned
   * from which the symmetric key will be derived, that might not otherwise be returned. The RP
   * MAY still use other supported encryption algorithms or send unencrypted Request Objects, even
   * when this parameter is present. If both signing and encryption are requested, the Request Object
   * will be signed then encrypted, with the result being a Nested JWT, as defined in [JWT]. The
   * default, if omitted, is that the RP is not declaring whether it might encrypt any Request Objects.
   *
   * The point here is "The RP MAY still use other supported encryption algorithms or send unencrypted
   * Request Objects, even when this parameter is present."
   *
   * The Client's property that represents the client metadata is `requestEncryptionAlg`. See the
   * description of `requestEncryptionAlg` for details.
   *
   * Even if this flag is `false`, the match is required if the `requestObjectEncryptionAlgMatchRequired`
   * flag of the client is `true`.
   */
  requestObjectEncryptionAlgMatchRequired?: boolean | undefined;
  /**
   * The flag indicating whether the JWE `enc` of encrypted request object must match the `request_object_encryption_enc`
   *
   * @remarks
   * client metadata of the client that has sent the request object.
   *
   * The `request_object_encryption_enc` client metadata itself is defined in [OpenID Connect Dynamic
   * Client Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows.
   *
   * > request_object_encryption_enc
   * >
   * > OPTIONAL. JWE enc algorithm [JWA] the RP is declaring that it may use for encrypting Request
   * Objects sent to the OP. If request_object_encryption_alg is specified, the default for this
   * value is A128CBC-HS256. When request_object_encryption_enc is included, request_object_encryption_alg
   * MUST also be provided.
   *
   * The Client's property that represents the client metadata is `requestEncryptionEnc`. See the
   * description of `requestEncryptionEnc` for details.
   *
   * Even if this flag is false, the match is required if the `requestObjectEncryptionEncMatchRequired`
   * flag is `true`.
   */
  requestObjectEncryptionEncMatchRequired?: boolean | undefined;
  /**
   * The flag indicating whether HSM (Hardware Security Module) support is enabled for this service.
   *
   * @remarks
   *
   * When this flag is `false`, keys managed in HSMs are not used even if they exist. In addition,
   * `/api/hsk/*` APIs reject all requests.
   *
   * Even if this flag is `true`, HSM-related features do not work if the configuration of the Authlete
   * server you are using does not support HSM.
   */
  hsmEnabled?: boolean | undefined;
  /**
   * The information about keys managed on HSMs (Hardware Security Modules).
   *
   * @remarks
   *
   * This `hsks` property is output only, meaning that `hsks` in requests to `/api/service/create`
   * API and `/api/service/update` API do not have any effect. The contents of this property is controlled
   * only by `/api/hsk/*` APIs.
   */
  hsks?: Array<ServiceCreateApiHskResponse> | undefined;
  /**
   * The URL of the grant management endpoint.
   *
   * @remarks
   */
  grantManagementEndpoint?: string | undefined;
  /**
   * The flag indicating whether every authorization request (and any request serving as an authorization
   *
   * @remarks
   * request such as CIBA backchannel authentication request and device authorization request) must
   * include the `grant_management_action` request parameter.
   *
   * This property corresponds to the `grant_management_action_required` server metadata defined
   * in [Grant Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html).
   *
   * Note that setting true to this property will result in blocking all public clients because
   * the specification requires that grant management be usable only by confidential clients for
   * security reasons.
   */
  grantManagementActionRequired?: boolean | undefined;
  /**
   * The flag indicating whether Authlete's `/api/client/registration` API uses `UNAUTHORIZED` as
   *
   * @remarks
   * a value of the `action` response parameter when appropriate.
   *
   * The `UNAUTHORIZED` enum value was initially not defined as a possible value of the `action`
   * parameter in an `/api/client/registration` API response. This means that implementations of
   * client `configuration` endpoint were not able to conform to [RFC 7592](https://www.rfc-editor.org/rfc/rfc7592.html)
   * strictly.
   *
   * For backward compatibility (to avoid breaking running systems), Authlete's `/api/client/registration`
   * API does not return the `UNAUTHORIZED` enum value if this flag is not turned on.
   *
   * The steps an existing implementation of client configuration endpoint has to do in order to
   * conform to the requirement related to "401 Unauthorized" are as follows.
   *
   * 1. Update the Authlete library (e.g. authlete-java-common) your system is using.
   * 2. Update your implementation of client configuration endpoint so that it can handle the
   * `UNAUTHORIZED` action.
   * 3. Turn on this `unauthorizedOnClientConfigSupported` flag.
   */
  unauthorizedOnClientConfigSupported?: boolean | undefined;
  /**
   * The flag indicating whether the `scope` request parameter in dynamic client registration and
   *
   * @remarks
   * update requests (RFC 7591 and RFC 7592) is used as scopes that the client can request.
   *
   * Limiting the range of scopes that a client can request is achieved by listing scopes in the
   * `client.extension.requestableScopes` property and setting the `client.extension.requestableScopesEnabled`
   * property to `true`. This feature is called "requestable scopes".
   *
   * This property affects behaviors of `/api/client/registration` and other family APIs.
   */
  dcrScopeUsedAsRequestable?: boolean | undefined;
  /**
   * The endpoint for clients ending the sessions.
   *
   * @remarks
   *
   * A URL that starts with `https://` and has no fragment component. For example, `https://example.com/auth/endSession`.
   *
   * The value of this property is used as `end_session_endpoint` property in the [OpenID Provider
   * Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
   */
  endSessionEndpoint?: string | undefined;
  /**
   * The flag indicating whether the port number component of redirection URIs can be variable when
   *
   * @remarks
   * the host component indicates loopback.
   *
   * When this flag is `true`, if the host component of a redirection URI specified in an authorization
   * request indicates loopback (to be precise, when the host component is localhost, `127.0.0.1`
   * or `::1`), the port number component is ignored when the specified redirection URI is compared
   * to pre-registered ones. This behavior is described in [7.3. Loopback Interface Redirection](
   * https://www.rfc-editor.org/rfc/rfc8252.html#section-7.3) of [RFC 8252 OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8252.html)
   * for Native Apps.
   *
   * [3.1.2.3. Dynamic Configuration](https://www.rfc-editor.org/rfc/rfc6749.html#section-3.1.2.3)
   * of [RFC 6749](https://www.rfc-editor.org/rfc/rfc6749.html) states _"If the client registration
   * included the full redirection URI, the authorization server MUST compare the two URIs using
   * simple string comparison as defined in [RFC3986] Section 6.2.1."_ Also, the description of
   * `redirect_uri` in [3.1.2.1. Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest)
   * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) states
   * _"This URI MUST exactly match one of the Redirection URI values for the Client pre-registered
   * at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [RFC3986]
   * (**Simple String Comparison**)."_ These "Simple String Comparison" requirements are preceded
   * by this flag. That is, even when the conditions described in RFC 6749 and OpenID Connect Core 1.0
   * are satisfied, the port number component of loopback redirection URIs can be variable when this
   * flag is `true`.
   *
   * [8.3. Loopback Redirect Considerations](https://www.rfc-editor.org/rfc/rfc8252.html#section-8.3)
   * of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) states as follows.
   *
   * > While redirect URIs using localhost (i.e., `"http://localhost:{port}/{path}"`) function
   * similarly to loopback IP redirects described in Section 7.3, the use of localhost is NOT RECOMMENDED.
   * Specifying a redirect URI with the loopback IP literal rather than localhost avoids inadvertently
   * listening on network interfaces other than the loopback interface. It is also less susceptible
   * to client-side firewalls and misconfigured host name resolution on the user's device.
   *
   * However, Authlete allows the port number component to be variable in the case of `localhost`,
   * too. It is left to client applications whether they use `localhost` or a literal loopback IP
   * address (`127.0.0.1` for IPv4 or `::1` for IPv6).
   *
   * Section 7.3 and Section 8.3 of [RFC 8252](https://www.rfc-editor.org/rfc/rfc8252.html) state
   * that loopback redirection URIs use the `"http"` scheme, but Authlete allows the port number
   * component to be variable in other cases (e.g. in the case of the `"https"` scheme), too.
   */
  loopbackRedirectionUriVariable?: boolean | undefined;
  /**
   * The flag indicating whether Authlete checks whether the `aud` claim of request objects matches
   *
   * @remarks
   * the issuer identifier of this service.
   *
   * [Section 6.1. Passing a Request Object by Value](https://openid.net/specs/openid-connect-core-1_0.html#JWTRequests)
   * of [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) has the following
   * statement.
   *
   * > The `aud` value SHOULD be or include the OP's Issuer Identifier URL.
   *
   * Likewise, [Section 4. Request Object](https://www.rfc-editor.org/rfc/rfc9101.html#section-4) of
   * [RFC 9101](https://www.rfc-editor.org/rfc/rfc9101.html) (The OAuth 2.0 Authorization Framework:
   * JWT-Secured Authorization Request (JAR)) has the following statement.
   *
   * > The value of aud should be the value of the authorization server (AS) issuer, as defined in
   * [RFC 8414](https://www.rfc-editor.org/rfc/rfc8414.html).
   *
   * As excerpted above, validation on the `aud` claim of request objects is optional. However, if
   * this flag is turned on, Authlete checks whether the `aud` claim of request objects matches the issuer
   * identifier of this service and raises an error if they are different.
   */
  requestObjectAudienceChecked?: boolean | undefined;
  /**
   * The flag indicating whether Authlete generates access tokens for
   *
   * @remarks
   * external attachments and embeds them in ID tokens and userinfo
   * responses.
   */
  accessTokenForExternalAttachmentEmbedded?: boolean | undefined;
  /**
   * Identifiers of entities that can issue entity statements for this
   *
   * @remarks
   * service. This property corresponds to the `authority_hints`
   * property that appears in a self-signed entity statement that is
   * defined in OpenID Connect Federation 1.0.
   */
  authorityHints?: Array<string> | undefined;
  /**
   * flag indicating whether this service supports OpenID Connect Federation 1
   *
   * @remarks
   */
  federationEnabled?: boolean | undefined;
  /**
   * JWK Set document containing keys that are used to sign (1) self-signed
   *
   * @remarks
   * entity statement of this service and (2) the response from
   * `signed_jwks_uri`.
   */
  federationJwks?: string | undefined;
  /**
   * A key ID to identify a JWK used to sign the entity configuration and
   *
   * @remarks
   * the signed JWK Set.
   */
  federationSignatureKeyId?: string | undefined;
  /**
   * The duration of the entity configuration in seconds.
   *
   * @remarks
   */
  federationConfigurationDuration?: number | undefined;
  /**
   * The URI of the federation registration endpoint. This property corresponds
   *
   * @remarks
   * to the `federation_registration_endpoint` server metadata that is
   * defined in OpenID Connect Federation 1.0.
   */
  federationRegistrationEndpoint?: string | undefined;
  /**
   * The human-readable name representing the organization that operates
   *
   * @remarks
   * this service. This property corresponds to the `organization_name`
   * server metadata that is defined in OpenID Connect Federation 1.0.
   */
  organizationName?: string | undefined;
  /**
   * The transformed claims predefined by this service in JSON format.
   *
   * @remarks
   * This property corresponds to the `transformed_claims_predefined`
   * server metadata.
   */
  predefinedTransformedClaims?: string | undefined;
  /**
   * flag indicating whether refresh token requests with the same
   *
   * @remarks
   * refresh token can be made multiple times in quick succession and
   * they can obtain the same renewed refresh token within the short
   * period.
   */
  refreshTokenIdempotent?: boolean | undefined;
  /**
   * The URI of the endpoint that returns this service's JWK Set document in
   *
   * @remarks
   * the JWT format. This property corresponds to the `signed_jwks_uri`
   * server metadata defined in OpenID Connect Federation 1.0.
   */
  signedJwksUri?: string | undefined;
  /**
   * Supported attachment types. This property corresponds to the {@code
   *
   * @remarks
   * attachments_supported} server metadata which was added by the third
   * implementer's draft of OpenID Connect for Identity Assurance 1.0.
   */
  supportedAttachments?:
    | Array<ServiceCreateApiSupportedAttachmentResponse>
    | undefined;
  /**
   * Supported algorithms used to compute digest values of external
   *
   * @remarks
   * attachments. This property corresponds to the
   * `digest_algorithms_supported` server metadata which was added
   * by the third implementer's draft of OpenID Connect for Identity
   * Assurance 1.0.
   */
  supportedDigestAlgorithms?: Array<string> | undefined;
  /**
   * Document types supported by this service. This property corresponds
   *
   * @remarks
   * to the `documents_supported` server metadata.
   */
  supportedDocuments?: Array<string> | undefined;
  /**
   * validation and verification processes supported by this service.
   *
   * @remarks
   * This property corresponds to the `documents_methods_supported`
   * server metadata.
   *
   * The third implementer's draft of [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
   * renamed the
   * `id_documents_verification_methods_supported` server metadata to
   * `documents_methods_supported`.
   */
  supportedDocumentsMethods?: Array<string> | undefined;
  /**
   * Document validation methods supported by this service. This property
   *
   * @remarks
   * corresponds to the `documents_validation_methods_supported` server
   * metadata which was added by the third implementer's draft of <a href=
   * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
   */
  supportedDocumentsValidationMethods?: Array<string> | undefined;
  /**
   * Document verification methods supported by this service. This property
   *
   * @remarks
   * corresponds to the `documents_verification_methods_supported` server
   * metadata which was added by the third implementer's draft of
   * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
   */
  supportedDocumentsVerificationMethods?: Array<string> | undefined;
  /**
   * Electronic record types supported by this service. This property
   *
   * @remarks
   * corresponds to the `electronic_records_supported` server metadata
   * which was added by the third implementer's draft of
   * [OpenID Connect for Identity Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
   */
  supportedElectronicRecords?: Array<string> | undefined;
  supportedClientRegistrationTypes?:
    | Array<ServiceCreateApiSupportedClientRegistrationTypeResponse>
    | undefined;
  /**
   * The flag indicating whether to prohibit unidentifiable clients from
   *
   * @remarks
   * making token exchange requests.
   */
  tokenExchangeByIdentifiableClientsOnly?: boolean | undefined;
  /**
   * The flag indicating whether to prohibit public clients from making
   *
   * @remarks
   * token exchange requests.
   */
  tokenExchangeByConfidentialClientsOnly?: boolean | undefined;
  /**
   * The flag indicating whether to prohibit clients that have no explicit
   *
   * @remarks
   * permission from making token exchange requests.
   */
  tokenExchangeByPermittedClientsOnly?: boolean | undefined;
  /**
   * The flag indicating whether to reject token exchange requests which
   *
   * @remarks
   * use encrypted JWTs as input tokens.
   */
  tokenExchangeEncryptedJwtRejected?: boolean | undefined;
  /**
   * The flag indicating whether to reject token exchange requests which
   *
   * @remarks
   * use unsigned JWTs as input tokens.
   */
  tokenExchangeUnsignedJwtRejected?: boolean | undefined;
  /**
   * The flag indicating whether to prohibit unidentifiable clients from
   *
   * @remarks
   * using the grant type "urn:ietf:params:oauth:grant-type:jwt-bearer".
   */
  jwtGrantByIdentifiableClientsOnly?: boolean | undefined;
  /**
   * The flag indicating whether to reject token requests that use an
   *
   * @remarks
   * encrypted JWT as an authorization grant with the grant type
   * "urn:ietf:params:oauth:grant-type:jwt-bearer".
   */
  jwtGrantEncryptedJwtRejected?: boolean | undefined;
  /**
   * The flag indicating whether to reject token requests that use an
   *
   * @remarks
   * unsigned JWT as an authorization grant with the grant type
   * "urn:ietf:params:oauth:grant-type:jwt-bearer".
   */
  jwtGrantUnsignedJwtRejected?: boolean | undefined;
  /**
   * The flag indicating whether to block DCR (Dynamic Client Registration)
   *
   * @remarks
   * requests whose "software_id" has already been used previously.
   */
  dcrDuplicateSoftwareIdBlocked?: boolean | undefined;
  /**
   * The trust anchors that are referenced when this service resolves
   *
   * @remarks
   * trust chains of relying parties.
   *
   * If this property is empty, client registration fails regardless of
   * whether its type is `automatic` or `explicit`. It means
   * that OpenID Connect Federation 1.0 does not work.
   */
  trustAnchors?: Array<ServiceCreateApiTrustAnchorResponse> | undefined;
  /**
   * The flag indicating whether the openid scope should be dropped from
   *
   * @remarks
   * scopes list assigned to access token issued when a refresh token grant
   * is used.
   */
  openidDroppedOnRefreshWithoutOfflineAccess?: boolean | undefined;
  /**
   * Supported document check methods. This property corresponds to the `documents_check_methods_supported`
   *
   * @remarks
   * server metadata which was added by the fourth implementer's draft of OpenID Connect for Identity
   * Assurance 1.0.
   */
  supportedDocumentsCheckMethods?: Array<string> | undefined;
  /**
   * The flag indicating whether this service signs responses from the resource server.
   *
   * @remarks
   */
  rsResponseSigned?: boolean | undefined;
  /**
   * The duration of `c_nonce`.
   *
   * @remarks
   */
  cnonceDuration?: number | undefined;
  /**
   * Whether to require DPoP proof JWTs to include the `nonce` claim
   *
   * @remarks
   * whenever they are presented.
   */
  dpopNonceRequired?: boolean | undefined;
  /**
   * Get the flag indicating whether the feature of Verifiable Credentials
   *
   * @remarks
   * for this service is enabled or not.
   */
  verifiableCredentialsEnabled?: boolean | undefined;
  /**
   * The URL at which the JWK Set document of the credential issuer is
   *
   * @remarks
   * exposed.
   */
  credentialJwksUri?: string | undefined;
  /**
   * The default duration of credential offers in seconds.
   *
   * @remarks
   */
  credentialOfferDuration?: number | undefined;
  /**
   * The duration of nonce values for DPoP proof JWTs in seconds.
   *
   * @remarks
   */
  dpopNonceDuration?: number | undefined;
  /**
   * The flag indicating whether token requests using the pre-authorized
   *
   * @remarks
   * code grant flow by unidentifiable clients are allowed.
   */
  preAuthorizedGrantAnonymousAccessSupported?: boolean | undefined;
  /**
   * The duration of transaction ID in seconds that may be issued as a
   *
   * @remarks
   * result of a credential request or a batch credential request.
   */
  credentialTransactionDuration?: number | undefined;
  /**
   * The key ID of the key for signing introspection responses.
   *
   * @remarks
   */
  introspectionSignatureKeyId?: string | undefined;
  /**
   * The key ID of the key for signing introspection responses.
   *
   * @remarks
   */
  resourceSignatureKeyId?: string | undefined;
  /**
   * The default length of user PINs.
   *
   * @remarks
   */
  userPinLength?: number | undefined;
  /**
   * The supported `prompt` values.
   *
   * @remarks
   */
  supportedPromptValues?:
    | Array<ServiceCreateApiSupportedPromptValueResponse>
    | undefined;
  /**
   * The flag indicating whether to enable the feature of ID token
   *
   * @remarks
   * reissuance in the refresh token flow.
   */
  idTokenReissuable?: boolean | undefined;
  /**
   * The JWK Set document containing private keys that are used to sign
   *
   * @remarks
   * verifiable credentials.
   */
  credentialJwks?: string | undefined;
  /**
   * FAPI modes for this service.
   *
   * @remarks
   *
   * When the value of this property is not `null`, Authlete always processes requests to this service based
   * on the specified FAPI modes if the FAPI feature is enabled in Authlete and the FAPI profile is supported
   * by this service.
   *
   * For instance, when this property is set to an array containing `FAPI1_ADVANCED` only, Authlete always
   * processes requests to this service based on "Financial-grade API Security Profile 1.0 - Part 2:
   * Advanced" if the FAPI feature is enabled in Authlete and the FAPI profile is supported by this service.
   */
  fapiModes?: Array<ServiceCreateApiFapiModeResponse> | undefined;
  /**
   * The default duration of verifiable credentials in seconds.
   *
   * @remarks
   */
  credentialDuration?: number | undefined;
  credentialIssuerMetadata?:
    | ServiceCreateApiCredentialIssuerMetadataResponse
    | undefined;
  /**
   * The type of the `aud` claim in ID tokens.
   *
   * @remarks
   */
  idTokenAudType?: string | undefined;
};

/** @internal */
export const ServiceCreateApiMetadatumRequest$inboundSchema: z.ZodType<
  ServiceCreateApiMetadatumRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiMetadatumRequest$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ServiceCreateApiMetadatumRequest$outboundSchema: z.ZodType<
  ServiceCreateApiMetadatumRequest$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiMetadatumRequest
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiMetadatumRequest$ {
  /** @deprecated use `ServiceCreateApiMetadatumRequest$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiMetadatumRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiMetadatumRequest$outboundSchema` instead. */
  export const outboundSchema = ServiceCreateApiMetadatumRequest$outboundSchema;
  /** @deprecated use `ServiceCreateApiMetadatumRequest$Outbound` instead. */
  export type Outbound = ServiceCreateApiMetadatumRequest$Outbound;
}

export function serviceCreateApiMetadatumRequestToJSON(
  serviceCreateApiMetadatumRequest: ServiceCreateApiMetadatumRequest,
): string {
  return JSON.stringify(
    ServiceCreateApiMetadatumRequest$outboundSchema.parse(
      serviceCreateApiMetadatumRequest,
    ),
  );
}

export function serviceCreateApiMetadatumRequestFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiMetadatumRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ServiceCreateApiMetadatumRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiMetadatumRequest' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedGrantTypeRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedGrantTypeRequest> = z
    .nativeEnum(ServiceCreateApiSupportedGrantTypeRequest);

/** @internal */
export const ServiceCreateApiSupportedGrantTypeRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedGrantTypeRequest> =
    ServiceCreateApiSupportedGrantTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedGrantTypeRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedGrantTypeRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedGrantTypeRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedGrantTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedGrantTypeRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedResponseTypeRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedResponseTypeRequest> = z
    .nativeEnum(ServiceCreateApiSupportedResponseTypeRequest);

/** @internal */
export const ServiceCreateApiSupportedResponseTypeRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedResponseTypeRequest> =
    ServiceCreateApiSupportedResponseTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedResponseTypeRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedResponseTypeRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedResponseTypeRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedResponseTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedResponseTypeRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedServiceProfileRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedServiceProfileRequest> = z
    .nativeEnum(ServiceCreateApiSupportedServiceProfileRequest);

/** @internal */
export const ServiceCreateApiSupportedServiceProfileRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedServiceProfileRequest> =
    ServiceCreateApiSupportedServiceProfileRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedServiceProfileRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedServiceProfileRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedServiceProfileRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedServiceProfileRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedServiceProfileRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedDisplayRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedDisplayRequest> = z
    .nativeEnum(ServiceCreateApiSupportedDisplayRequest);

/** @internal */
export const ServiceCreateApiSupportedDisplayRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedDisplayRequest> =
    ServiceCreateApiSupportedDisplayRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedDisplayRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedDisplayRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedDisplayRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedDisplayRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedDisplayRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedTokenAuthMethodRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedTokenAuthMethodRequest> = z
    .nativeEnum(ServiceCreateApiSupportedTokenAuthMethodRequest);

/** @internal */
export const ServiceCreateApiSupportedTokenAuthMethodRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedTokenAuthMethodRequest> =
    ServiceCreateApiSupportedTokenAuthMethodRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedTokenAuthMethodRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedTokenAuthMethodRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedTokenAuthMethodRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedTokenAuthMethodRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedTokenAuthMethodRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedRevocationAuthMethodRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedRevocationAuthMethodRequest> =
    z.nativeEnum(ServiceCreateApiSupportedRevocationAuthMethodRequest);

/** @internal */
export const ServiceCreateApiSupportedRevocationAuthMethodRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedRevocationAuthMethodRequest> =
    ServiceCreateApiSupportedRevocationAuthMethodRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedRevocationAuthMethodRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedRevocationAuthMethodRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedRevocationAuthMethodRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedRevocationAuthMethodRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedRevocationAuthMethodRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedIntrospectionAuthMethodRequest$inboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedIntrospectionAuthMethodRequest
  > = z.nativeEnum(ServiceCreateApiSupportedIntrospectionAuthMethodRequest);

/** @internal */
export const ServiceCreateApiSupportedIntrospectionAuthMethodRequest$outboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedIntrospectionAuthMethodRequest
  > = ServiceCreateApiSupportedIntrospectionAuthMethodRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedIntrospectionAuthMethodRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedIntrospectionAuthMethodRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedIntrospectionAuthMethodRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedIntrospectionAuthMethodRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedIntrospectionAuthMethodRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiMtlsEndpointAliasRequest$inboundSchema: z.ZodType<
  ServiceCreateApiMtlsEndpointAliasRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  uri: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiMtlsEndpointAliasRequest$Outbound = {
  name?: string | undefined;
  uri?: string | undefined;
};

/** @internal */
export const ServiceCreateApiMtlsEndpointAliasRequest$outboundSchema: z.ZodType<
  ServiceCreateApiMtlsEndpointAliasRequest$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiMtlsEndpointAliasRequest
> = z.object({
  name: z.string().optional(),
  uri: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiMtlsEndpointAliasRequest$ {
  /** @deprecated use `ServiceCreateApiMtlsEndpointAliasRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiMtlsEndpointAliasRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiMtlsEndpointAliasRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiMtlsEndpointAliasRequest$outboundSchema;
  /** @deprecated use `ServiceCreateApiMtlsEndpointAliasRequest$Outbound` instead. */
  export type Outbound = ServiceCreateApiMtlsEndpointAliasRequest$Outbound;
}

export function serviceCreateApiMtlsEndpointAliasRequestToJSON(
  serviceCreateApiMtlsEndpointAliasRequest:
    ServiceCreateApiMtlsEndpointAliasRequest,
): string {
  return JSON.stringify(
    ServiceCreateApiMtlsEndpointAliasRequest$outboundSchema.parse(
      serviceCreateApiMtlsEndpointAliasRequest,
    ),
  );
}

export function serviceCreateApiMtlsEndpointAliasRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  ServiceCreateApiMtlsEndpointAliasRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiMtlsEndpointAliasRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ServiceCreateApiMtlsEndpointAliasRequest' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiAccessTokenSignAlgRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiAccessTokenSignAlgRequest> = z
    .nativeEnum(ServiceCreateApiAccessTokenSignAlgRequest);

/** @internal */
export const ServiceCreateApiAccessTokenSignAlgRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiAccessTokenSignAlgRequest> =
    ServiceCreateApiAccessTokenSignAlgRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiAccessTokenSignAlgRequest$ {
  /** @deprecated use `ServiceCreateApiAccessTokenSignAlgRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiAccessTokenSignAlgRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiAccessTokenSignAlgRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiAccessTokenSignAlgRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiDescriptionRequest$inboundSchema: z.ZodType<
  ServiceCreateApiDescriptionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiDescriptionRequest$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ServiceCreateApiDescriptionRequest$outboundSchema: z.ZodType<
  ServiceCreateApiDescriptionRequest$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiDescriptionRequest
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiDescriptionRequest$ {
  /** @deprecated use `ServiceCreateApiDescriptionRequest$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiDescriptionRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiDescriptionRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiDescriptionRequest$outboundSchema;
  /** @deprecated use `ServiceCreateApiDescriptionRequest$Outbound` instead. */
  export type Outbound = ServiceCreateApiDescriptionRequest$Outbound;
}

export function serviceCreateApiDescriptionRequestToJSON(
  serviceCreateApiDescriptionRequest: ServiceCreateApiDescriptionRequest,
): string {
  return JSON.stringify(
    ServiceCreateApiDescriptionRequest$outboundSchema.parse(
      serviceCreateApiDescriptionRequest,
    ),
  );
}

export function serviceCreateApiDescriptionRequestFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiDescriptionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiDescriptionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiDescriptionRequest' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedScopeAttributeRequest$inboundSchema:
  z.ZodType<
    ServiceCreateApiSupportedScopeAttributeRequest,
    z.ZodTypeDef,
    unknown
  > = z.object({
    key: z.string().optional(),
    value: z.string().optional(),
  });

/** @internal */
export type ServiceCreateApiSupportedScopeAttributeRequest$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ServiceCreateApiSupportedScopeAttributeRequest$outboundSchema:
  z.ZodType<
    ServiceCreateApiSupportedScopeAttributeRequest$Outbound,
    z.ZodTypeDef,
    ServiceCreateApiSupportedScopeAttributeRequest
  > = z.object({
    key: z.string().optional(),
    value: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedScopeAttributeRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedScopeAttributeRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedScopeAttributeRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedScopeAttributeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedScopeAttributeRequest$outboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedScopeAttributeRequest$Outbound` instead. */
  export type Outbound =
    ServiceCreateApiSupportedScopeAttributeRequest$Outbound;
}

export function serviceCreateApiSupportedScopeAttributeRequestToJSON(
  serviceCreateApiSupportedScopeAttributeRequest:
    ServiceCreateApiSupportedScopeAttributeRequest,
): string {
  return JSON.stringify(
    ServiceCreateApiSupportedScopeAttributeRequest$outboundSchema.parse(
      serviceCreateApiSupportedScopeAttributeRequest,
    ),
  );
}

export function serviceCreateApiSupportedScopeAttributeRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  ServiceCreateApiSupportedScopeAttributeRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiSupportedScopeAttributeRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ServiceCreateApiSupportedScopeAttributeRequest' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedScopeRequest$inboundSchema: z.ZodType<
  ServiceCreateApiSupportedScopeRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  defaultEntry: z.boolean().optional(),
  description: z.string().optional(),
  descriptions: z.array(
    z.lazy(() => ServiceCreateApiDescriptionRequest$inboundSchema),
  ).optional(),
  attributes: z.array(
    z.lazy(() => ServiceCreateApiSupportedScopeAttributeRequest$inboundSchema),
  ).optional(),
});

/** @internal */
export type ServiceCreateApiSupportedScopeRequest$Outbound = {
  name?: string | undefined;
  defaultEntry?: boolean | undefined;
  description?: string | undefined;
  descriptions?: Array<ServiceCreateApiDescriptionRequest$Outbound> | undefined;
  attributes?:
    | Array<ServiceCreateApiSupportedScopeAttributeRequest$Outbound>
    | undefined;
};

/** @internal */
export const ServiceCreateApiSupportedScopeRequest$outboundSchema: z.ZodType<
  ServiceCreateApiSupportedScopeRequest$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiSupportedScopeRequest
> = z.object({
  name: z.string().optional(),
  defaultEntry: z.boolean().optional(),
  description: z.string().optional(),
  descriptions: z.array(
    z.lazy(() => ServiceCreateApiDescriptionRequest$outboundSchema),
  ).optional(),
  attributes: z.array(
    z.lazy(() => ServiceCreateApiSupportedScopeAttributeRequest$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedScopeRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedScopeRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedScopeRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedScopeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedScopeRequest$outboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedScopeRequest$Outbound` instead. */
  export type Outbound = ServiceCreateApiSupportedScopeRequest$Outbound;
}

export function serviceCreateApiSupportedScopeRequestToJSON(
  serviceCreateApiSupportedScopeRequest: ServiceCreateApiSupportedScopeRequest,
): string {
  return JSON.stringify(
    ServiceCreateApiSupportedScopeRequest$outboundSchema.parse(
      serviceCreateApiSupportedScopeRequest,
    ),
  );
}

export function serviceCreateApiSupportedScopeRequestFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiSupportedScopeRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiSupportedScopeRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiSupportedScopeRequest' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedClaimTypeRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedClaimTypeRequest> = z
    .nativeEnum(ServiceCreateApiSupportedClaimTypeRequest);

/** @internal */
export const ServiceCreateApiSupportedClaimTypeRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedClaimTypeRequest> =
    ServiceCreateApiSupportedClaimTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedClaimTypeRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedClaimTypeRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedClaimTypeRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedClaimTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedClaimTypeRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest$inboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest
  > = z.nativeEnum(
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest,
  );

/** @internal */
export const ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest$outboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest
  > =
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiUserCodeCharsetRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiUserCodeCharsetRequest> = z.nativeEnum(
    ServiceCreateApiUserCodeCharsetRequest,
  );

/** @internal */
export const ServiceCreateApiUserCodeCharsetRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiUserCodeCharsetRequest> =
    ServiceCreateApiUserCodeCharsetRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiUserCodeCharsetRequest$ {
  /** @deprecated use `ServiceCreateApiUserCodeCharsetRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiUserCodeCharsetRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiUserCodeCharsetRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiUserCodeCharsetRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest$inboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest
  > = z.nativeEnum(ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest);

/** @internal */
export const ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest$outboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest
  > = ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest$ {
  /** @deprecated use `ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiAttributeRequest$inboundSchema: z.ZodType<
  ServiceCreateApiAttributeRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiAttributeRequest$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ServiceCreateApiAttributeRequest$outboundSchema: z.ZodType<
  ServiceCreateApiAttributeRequest$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiAttributeRequest
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiAttributeRequest$ {
  /** @deprecated use `ServiceCreateApiAttributeRequest$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiAttributeRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiAttributeRequest$outboundSchema` instead. */
  export const outboundSchema = ServiceCreateApiAttributeRequest$outboundSchema;
  /** @deprecated use `ServiceCreateApiAttributeRequest$Outbound` instead. */
  export type Outbound = ServiceCreateApiAttributeRequest$Outbound;
}

export function serviceCreateApiAttributeRequestToJSON(
  serviceCreateApiAttributeRequest: ServiceCreateApiAttributeRequest,
): string {
  return JSON.stringify(
    ServiceCreateApiAttributeRequest$outboundSchema.parse(
      serviceCreateApiAttributeRequest,
    ),
  );
}

export function serviceCreateApiAttributeRequestFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiAttributeRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ServiceCreateApiAttributeRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiAttributeRequest' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiHskRequest$inboundSchema: z.ZodType<
  ServiceCreateApiHskRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  kty: z.string().optional(),
  use: z.string().optional(),
  kid: z.string().optional(),
  hsmName: z.string().optional(),
  handle: z.string().optional(),
  publicKey: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiHskRequest$Outbound = {
  kty?: string | undefined;
  use?: string | undefined;
  kid?: string | undefined;
  hsmName?: string | undefined;
  handle?: string | undefined;
  publicKey?: string | undefined;
};

/** @internal */
export const ServiceCreateApiHskRequest$outboundSchema: z.ZodType<
  ServiceCreateApiHskRequest$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiHskRequest
> = z.object({
  kty: z.string().optional(),
  use: z.string().optional(),
  kid: z.string().optional(),
  hsmName: z.string().optional(),
  handle: z.string().optional(),
  publicKey: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiHskRequest$ {
  /** @deprecated use `ServiceCreateApiHskRequest$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiHskRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiHskRequest$outboundSchema` instead. */
  export const outboundSchema = ServiceCreateApiHskRequest$outboundSchema;
  /** @deprecated use `ServiceCreateApiHskRequest$Outbound` instead. */
  export type Outbound = ServiceCreateApiHskRequest$Outbound;
}

export function serviceCreateApiHskRequestToJSON(
  serviceCreateApiHskRequest: ServiceCreateApiHskRequest,
): string {
  return JSON.stringify(
    ServiceCreateApiHskRequest$outboundSchema.parse(serviceCreateApiHskRequest),
  );
}

export function serviceCreateApiHskRequestFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiHskRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ServiceCreateApiHskRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiHskRequest' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedAttachmentRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedAttachmentRequest> = z
    .nativeEnum(ServiceCreateApiSupportedAttachmentRequest);

/** @internal */
export const ServiceCreateApiSupportedAttachmentRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedAttachmentRequest> =
    ServiceCreateApiSupportedAttachmentRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedAttachmentRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedAttachmentRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedAttachmentRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedAttachmentRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedAttachmentRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedClientRegistrationTypeRequest$inboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedClientRegistrationTypeRequest
  > = z.nativeEnum(ServiceCreateApiSupportedClientRegistrationTypeRequest);

/** @internal */
export const ServiceCreateApiSupportedClientRegistrationTypeRequest$outboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedClientRegistrationTypeRequest
  > = ServiceCreateApiSupportedClientRegistrationTypeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedClientRegistrationTypeRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedClientRegistrationTypeRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedClientRegistrationTypeRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedClientRegistrationTypeRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedClientRegistrationTypeRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiTrustAnchorRequest$inboundSchema: z.ZodType<
  ServiceCreateApiTrustAnchorRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  entityId: z.string().optional(),
  jwks: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiTrustAnchorRequest$Outbound = {
  entityId?: string | undefined;
  jwks?: string | undefined;
};

/** @internal */
export const ServiceCreateApiTrustAnchorRequest$outboundSchema: z.ZodType<
  ServiceCreateApiTrustAnchorRequest$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiTrustAnchorRequest
> = z.object({
  entityId: z.string().optional(),
  jwks: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiTrustAnchorRequest$ {
  /** @deprecated use `ServiceCreateApiTrustAnchorRequest$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiTrustAnchorRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiTrustAnchorRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiTrustAnchorRequest$outboundSchema;
  /** @deprecated use `ServiceCreateApiTrustAnchorRequest$Outbound` instead. */
  export type Outbound = ServiceCreateApiTrustAnchorRequest$Outbound;
}

export function serviceCreateApiTrustAnchorRequestToJSON(
  serviceCreateApiTrustAnchorRequest: ServiceCreateApiTrustAnchorRequest,
): string {
  return JSON.stringify(
    ServiceCreateApiTrustAnchorRequest$outboundSchema.parse(
      serviceCreateApiTrustAnchorRequest,
    ),
  );
}

export function serviceCreateApiTrustAnchorRequestFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiTrustAnchorRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiTrustAnchorRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiTrustAnchorRequest' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedPromptValueRequest$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedPromptValueRequest> = z
    .nativeEnum(ServiceCreateApiSupportedPromptValueRequest);

/** @internal */
export const ServiceCreateApiSupportedPromptValueRequest$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedPromptValueRequest> =
    ServiceCreateApiSupportedPromptValueRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedPromptValueRequest$ {
  /** @deprecated use `ServiceCreateApiSupportedPromptValueRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedPromptValueRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedPromptValueRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedPromptValueRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiFapiModeRequest$inboundSchema: z.ZodNativeEnum<
  typeof ServiceCreateApiFapiModeRequest
> = z.nativeEnum(ServiceCreateApiFapiModeRequest);

/** @internal */
export const ServiceCreateApiFapiModeRequest$outboundSchema: z.ZodNativeEnum<
  typeof ServiceCreateApiFapiModeRequest
> = ServiceCreateApiFapiModeRequest$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiFapiModeRequest$ {
  /** @deprecated use `ServiceCreateApiFapiModeRequest$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiFapiModeRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiFapiModeRequest$outboundSchema` instead. */
  export const outboundSchema = ServiceCreateApiFapiModeRequest$outboundSchema;
}

/** @internal */
export const ServiceCreateApiCredentialIssuerMetadataRequest$inboundSchema:
  z.ZodType<
    ServiceCreateApiCredentialIssuerMetadataRequest,
    z.ZodTypeDef,
    unknown
  > = z.object({
    credentialIssuer: z.string().optional(),
    authorizationServer: z.string().optional(),
    credentialEndpoint: z.boolean().optional(),
    batchCredentialEndpoint: z.number().int().optional(),
    deferredCredentialEndpoint: z.string().optional(),
    credentialsSupported: z.boolean().optional(),
  });

/** @internal */
export type ServiceCreateApiCredentialIssuerMetadataRequest$Outbound = {
  credentialIssuer?: string | undefined;
  authorizationServer?: string | undefined;
  credentialEndpoint?: boolean | undefined;
  batchCredentialEndpoint?: number | undefined;
  deferredCredentialEndpoint?: string | undefined;
  credentialsSupported?: boolean | undefined;
};

/** @internal */
export const ServiceCreateApiCredentialIssuerMetadataRequest$outboundSchema:
  z.ZodType<
    ServiceCreateApiCredentialIssuerMetadataRequest$Outbound,
    z.ZodTypeDef,
    ServiceCreateApiCredentialIssuerMetadataRequest
  > = z.object({
    credentialIssuer: z.string().optional(),
    authorizationServer: z.string().optional(),
    credentialEndpoint: z.boolean().optional(),
    batchCredentialEndpoint: z.number().int().optional(),
    deferredCredentialEndpoint: z.string().optional(),
    credentialsSupported: z.boolean().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiCredentialIssuerMetadataRequest$ {
  /** @deprecated use `ServiceCreateApiCredentialIssuerMetadataRequest$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiCredentialIssuerMetadataRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiCredentialIssuerMetadataRequest$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiCredentialIssuerMetadataRequest$outboundSchema;
  /** @deprecated use `ServiceCreateApiCredentialIssuerMetadataRequest$Outbound` instead. */
  export type Outbound =
    ServiceCreateApiCredentialIssuerMetadataRequest$Outbound;
}

export function serviceCreateApiCredentialIssuerMetadataRequestToJSON(
  serviceCreateApiCredentialIssuerMetadataRequest:
    ServiceCreateApiCredentialIssuerMetadataRequest,
): string {
  return JSON.stringify(
    ServiceCreateApiCredentialIssuerMetadataRequest$outboundSchema.parse(
      serviceCreateApiCredentialIssuerMetadataRequest,
    ),
  );
}

export function serviceCreateApiCredentialIssuerMetadataRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  ServiceCreateApiCredentialIssuerMetadataRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiCredentialIssuerMetadataRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ServiceCreateApiCredentialIssuerMetadataRequest' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiRequest$inboundSchema: z.ZodType<
  ServiceCreateApiRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  serviceName: z.string().optional(),
  issuer: z.string().optional(),
  description: z.string().optional(),
  clientIdAliasEnabled: z.boolean().optional(),
  metadata: z.array(
    z.lazy(() => ServiceCreateApiMetadatumRequest$inboundSchema),
  ).optional(),
  authenticationCallbackEndpoint: z.string().optional(),
  authenticationCallbackApiKey: z.string().optional(),
  authenticationCallbackApiSecret: z.string().optional(),
  supportedGrantTypes: z.array(
    ServiceCreateApiSupportedGrantTypeRequest$inboundSchema,
  ).optional(),
  supportedResponseTypes: z.array(
    ServiceCreateApiSupportedResponseTypeRequest$inboundSchema,
  ).optional(),
  supportedAuthorizationDetailsTypes: z.array(z.string()).optional(),
  supportedServiceProfiles: z.array(
    ServiceCreateApiSupportedServiceProfileRequest$inboundSchema,
  ).optional(),
  errorDescriptionOmitted: z.boolean().optional(),
  errorUriOmitted: z.boolean().optional(),
  authorizationEndpoint: z.string().optional(),
  directAuthorizationEndpointEnabled: z.boolean().optional(),
  supportedUiLocales: z.array(z.string()).optional(),
  supportedDisplays: z.array(
    ServiceCreateApiSupportedDisplayRequest$inboundSchema,
  ).optional(),
  pkceRequired: z.boolean().optional(),
  pkceS256Required: z.boolean().optional(),
  authorizationResponseDuration: z.number().int().optional(),
  tokenEndpoint: z.string().optional(),
  directTokenEndpointEnabled: z.boolean().optional(),
  supportedTokenAuthMethods: z.array(
    ServiceCreateApiSupportedTokenAuthMethodRequest$inboundSchema,
  ).optional(),
  missingClientIdAllowed: z.boolean().optional(),
  revocationEndpoint: z.string().optional(),
  directRevocationEndpointEnabled: z.boolean().optional(),
  supportedRevocationAuthMethods: z.array(
    ServiceCreateApiSupportedRevocationAuthMethodRequest$inboundSchema,
  ).optional(),
  introspectionEndpoint: z.string().optional(),
  directIntrospectionEndpointEnabled: z.boolean().optional(),
  supportedIntrospectionAuthMethods: z.array(
    ServiceCreateApiSupportedIntrospectionAuthMethodRequest$inboundSchema,
  ).optional(),
  pushedAuthReqEndpoint: z.string().optional(),
  pushedAuthReqDuration: z.number().int().optional(),
  parRequired: z.boolean().optional(),
  requestObjectRequired: z.boolean().optional(),
  traditionalRequestObjectProcessingApplied: z.boolean().optional(),
  mutualTlsValidatePkiCertChain: z.boolean().optional(),
  trustedRootCertificates: z.array(z.string()).optional(),
  mtlsEndpointAliases: z.array(
    z.lazy(() => ServiceCreateApiMtlsEndpointAliasRequest$inboundSchema),
  ).optional(),
  accessTokenType: z.string().optional(),
  tlsClientCertificateBoundAccessTokens: z.boolean().optional(),
  accessTokenDuration: z.number().int().optional(),
  singleAccessTokenPerSubject: z.boolean().optional(),
  accessTokenSignAlg: ServiceCreateApiAccessTokenSignAlgRequest$inboundSchema
    .optional(),
  accessTokenSignatureKeyId: z.string().optional(),
  refreshTokenDuration: z.number().int().optional(),
  refreshTokenDurationKept: z.boolean().optional(),
  refreshTokenDurationReset: z.boolean().optional(),
  refreshTokenKept: z.boolean().optional(),
  supportedScopes: z.array(
    z.lazy(() => ServiceCreateApiSupportedScopeRequest$inboundSchema),
  ).optional(),
  scopeRequired: z.boolean().optional(),
  idTokenDuration: z.number().int().optional(),
  allowableClockSkew: z.number().int().optional(),
  supportedClaimTypes: z.array(
    ServiceCreateApiSupportedClaimTypeRequest$inboundSchema,
  ).optional(),
  supportedClaimLocales: z.array(z.string()).optional(),
  supportedClaims: z.array(z.string()).optional(),
  claimShortcutRestrictive: z.boolean().optional(),
  jwksUri: z.string().optional(),
  directJwksEndpointEnabled: z.boolean().optional(),
  jwks: z.string().optional(),
  idTokenSignatureKeyId: z.string().optional(),
  userInfoSignatureKeyId: z.string().optional(),
  authorizationSignatureKeyId: z.string().optional(),
  userInfoEndpoint: z.string().optional(),
  directUserInfoEndpointEnabled: z.boolean().optional(),
  dynamicRegistrationSupported: z.boolean().optional(),
  registrationEndpoint: z.string().optional(),
  registrationManagementEndpoint: z.string().optional(),
  policyUri: z.string().optional(),
  tosUri: z.string().optional(),
  serviceDocumentation: z.string().optional(),
  backchannelAuthenticationEndpoint: z.string().optional(),
  supportedBackchannelTokenDeliveryModes: z.array(
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest$inboundSchema,
  ).optional(),
  backchannelAuthReqIdDuration: z.number().int().optional(),
  backchannelPollingInterval: z.number().int().optional(),
  backchannelUserCodeParameterSupported: z.boolean().optional(),
  backchannelBindingMessageRequiredInFapi: z.boolean().optional(),
  deviceAuthorizationEndpoint: z.string().optional(),
  deviceVerificationUri: z.string().optional(),
  deviceVerificationUriComplete: z.string().optional(),
  deviceFlowCodeDuration: z.number().int().optional(),
  deviceFlowPollingInterval: z.number().int().optional(),
  userCodeCharset: ServiceCreateApiUserCodeCharsetRequest$inboundSchema
    .optional(),
  userCodeLength: z.number().int().optional(),
  supportedTrustFrameworks: z.array(z.string()).optional(),
  supportedEvidence: z.array(z.string()).optional(),
  supportedIdentityDocuments: z.array(z.string()).optional(),
  supportedVerificationMethods: z.array(z.string()).optional(),
  supportedVerifiedClaims: z.array(z.string()).optional(),
  verifiedClaimsValidationSchemaSet:
    ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest$inboundSchema
      .optional(),
  attributes: z.array(
    z.lazy(() => ServiceCreateApiAttributeRequest$inboundSchema),
  ).optional(),
  nbfOptional: z.boolean().optional(),
  issSuppressed: z.boolean().optional(),
  supportedCustomClientMetadata: z.array(z.string()).optional(),
  tokenExpirationLinked: z.boolean().optional(),
  frontChannelRequestObjectEncryptionRequired: z.boolean().optional(),
  requestObjectEncryptionAlgMatchRequired: z.boolean().optional(),
  requestObjectEncryptionEncMatchRequired: z.boolean().optional(),
  hsmEnabled: z.boolean().optional(),
  hsks: z.array(z.lazy(() => ServiceCreateApiHskRequest$inboundSchema))
    .optional(),
  grantManagementEndpoint: z.string().optional(),
  grantManagementActionRequired: z.boolean().optional(),
  unauthorizedOnClientConfigSupported: z.boolean().optional(),
  dcrScopeUsedAsRequestable: z.boolean().optional(),
  endSessionEndpoint: z.string().optional(),
  loopbackRedirectionUriVariable: z.boolean().optional(),
  requestObjectAudienceChecked: z.boolean().optional(),
  accessTokenForExternalAttachmentEmbedded: z.boolean().optional(),
  authorityHints: z.array(z.string()).optional(),
  federationEnabled: z.boolean().optional(),
  federationJwks: z.string().optional(),
  federationSignatureKeyId: z.string().optional(),
  federationConfigurationDuration: z.number().int().optional(),
  federationRegistrationEndpoint: z.string().optional(),
  organizationName: z.string().optional(),
  predefinedTransformedClaims: z.string().optional(),
  refreshTokenIdempotent: z.boolean().optional(),
  signedJwksUri: z.string().optional(),
  supportedAttachments: z.array(
    ServiceCreateApiSupportedAttachmentRequest$inboundSchema,
  ).optional(),
  supportedDigestAlgorithms: z.array(z.string()).optional(),
  supportedDocuments: z.array(z.string()).optional(),
  supportedDocumentsMethods: z.array(z.string()).optional(),
  supportedDocumentsValidationMethods: z.array(z.string()).optional(),
  supportedDocumentsVerificationMethods: z.array(z.string()).optional(),
  supportedElectronicRecords: z.array(z.string()).optional(),
  supportedClientRegistrationTypes: z.array(
    ServiceCreateApiSupportedClientRegistrationTypeRequest$inboundSchema,
  ).optional(),
  tokenExchangeByIdentifiableClientsOnly: z.boolean().optional(),
  tokenExchangeByConfidentialClientsOnly: z.boolean().optional(),
  tokenExchangeByPermittedClientsOnly: z.boolean().optional(),
  tokenExchangeEncryptedJwtRejected: z.boolean().optional(),
  tokenExchangeUnsignedJwtRejected: z.boolean().optional(),
  jwtGrantByIdentifiableClientsOnly: z.boolean().optional(),
  jwtGrantEncryptedJwtRejected: z.boolean().optional(),
  jwtGrantUnsignedJwtRejected: z.boolean().optional(),
  dcrDuplicateSoftwareIdBlocked: z.boolean().optional(),
  trustAnchors: z.array(
    z.lazy(() => ServiceCreateApiTrustAnchorRequest$inboundSchema),
  ).optional(),
  openidDroppedOnRefreshWithoutOfflineAccess: z.boolean().optional(),
  supportedDocumentsCheckMethods: z.array(z.string()).optional(),
  rsResponseSigned: z.boolean().optional(),
  cnonceDuration: z.number().int().optional(),
  dpopNonceRequired: z.boolean().optional(),
  verifiableCredentialsEnabled: z.boolean().optional(),
  credentialJwksUri: z.string().optional(),
  credentialOfferDuration: z.number().int().optional(),
  dpopNonceDuration: z.number().int().optional(),
  preAuthorizedGrantAnonymousAccessSupported: z.boolean().optional(),
  credentialTransactionDuration: z.number().int().optional(),
  introspectionSignatureKeyId: z.string().optional(),
  resourceSignatureKeyId: z.string().optional(),
  userPinLength: z.number().int().optional(),
  supportedPromptValues: z.array(
    ServiceCreateApiSupportedPromptValueRequest$inboundSchema,
  ).optional(),
  idTokenReissuable: z.boolean().optional(),
  credentialJwks: z.string().optional(),
  fapiModes: z.array(ServiceCreateApiFapiModeRequest$inboundSchema).optional(),
  credentialDuration: z.number().int().optional(),
  credentialIssuerMetadata: z.lazy(() =>
    ServiceCreateApiCredentialIssuerMetadataRequest$inboundSchema
  ).optional(),
  idTokenAudType: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiRequest$Outbound = {
  serviceName?: string | undefined;
  issuer?: string | undefined;
  description?: string | undefined;
  clientIdAliasEnabled?: boolean | undefined;
  metadata?: Array<ServiceCreateApiMetadatumRequest$Outbound> | undefined;
  authenticationCallbackEndpoint?: string | undefined;
  authenticationCallbackApiKey?: string | undefined;
  authenticationCallbackApiSecret?: string | undefined;
  supportedGrantTypes?: Array<string> | undefined;
  supportedResponseTypes?: Array<string> | undefined;
  supportedAuthorizationDetailsTypes?: Array<string> | undefined;
  supportedServiceProfiles?: Array<string> | undefined;
  errorDescriptionOmitted?: boolean | undefined;
  errorUriOmitted?: boolean | undefined;
  authorizationEndpoint?: string | undefined;
  directAuthorizationEndpointEnabled?: boolean | undefined;
  supportedUiLocales?: Array<string> | undefined;
  supportedDisplays?: Array<string> | undefined;
  pkceRequired?: boolean | undefined;
  pkceS256Required?: boolean | undefined;
  authorizationResponseDuration?: number | undefined;
  tokenEndpoint?: string | undefined;
  directTokenEndpointEnabled?: boolean | undefined;
  supportedTokenAuthMethods?: Array<string> | undefined;
  missingClientIdAllowed?: boolean | undefined;
  revocationEndpoint?: string | undefined;
  directRevocationEndpointEnabled?: boolean | undefined;
  supportedRevocationAuthMethods?: Array<string> | undefined;
  introspectionEndpoint?: string | undefined;
  directIntrospectionEndpointEnabled?: boolean | undefined;
  supportedIntrospectionAuthMethods?: Array<string> | undefined;
  pushedAuthReqEndpoint?: string | undefined;
  pushedAuthReqDuration?: number | undefined;
  parRequired?: boolean | undefined;
  requestObjectRequired?: boolean | undefined;
  traditionalRequestObjectProcessingApplied?: boolean | undefined;
  mutualTlsValidatePkiCertChain?: boolean | undefined;
  trustedRootCertificates?: Array<string> | undefined;
  mtlsEndpointAliases?:
    | Array<ServiceCreateApiMtlsEndpointAliasRequest$Outbound>
    | undefined;
  accessTokenType?: string | undefined;
  tlsClientCertificateBoundAccessTokens?: boolean | undefined;
  accessTokenDuration?: number | undefined;
  singleAccessTokenPerSubject?: boolean | undefined;
  accessTokenSignAlg?: string | undefined;
  accessTokenSignatureKeyId?: string | undefined;
  refreshTokenDuration?: number | undefined;
  refreshTokenDurationKept?: boolean | undefined;
  refreshTokenDurationReset?: boolean | undefined;
  refreshTokenKept?: boolean | undefined;
  supportedScopes?:
    | Array<ServiceCreateApiSupportedScopeRequest$Outbound>
    | undefined;
  scopeRequired?: boolean | undefined;
  idTokenDuration?: number | undefined;
  allowableClockSkew?: number | undefined;
  supportedClaimTypes?: Array<string> | undefined;
  supportedClaimLocales?: Array<string> | undefined;
  supportedClaims?: Array<string> | undefined;
  claimShortcutRestrictive?: boolean | undefined;
  jwksUri?: string | undefined;
  directJwksEndpointEnabled?: boolean | undefined;
  jwks?: string | undefined;
  idTokenSignatureKeyId?: string | undefined;
  userInfoSignatureKeyId?: string | undefined;
  authorizationSignatureKeyId?: string | undefined;
  userInfoEndpoint?: string | undefined;
  directUserInfoEndpointEnabled?: boolean | undefined;
  dynamicRegistrationSupported?: boolean | undefined;
  registrationEndpoint?: string | undefined;
  registrationManagementEndpoint?: string | undefined;
  policyUri?: string | undefined;
  tosUri?: string | undefined;
  serviceDocumentation?: string | undefined;
  backchannelAuthenticationEndpoint?: string | undefined;
  supportedBackchannelTokenDeliveryModes?: Array<string> | undefined;
  backchannelAuthReqIdDuration?: number | undefined;
  backchannelPollingInterval?: number | undefined;
  backchannelUserCodeParameterSupported?: boolean | undefined;
  backchannelBindingMessageRequiredInFapi?: boolean | undefined;
  deviceAuthorizationEndpoint?: string | undefined;
  deviceVerificationUri?: string | undefined;
  deviceVerificationUriComplete?: string | undefined;
  deviceFlowCodeDuration?: number | undefined;
  deviceFlowPollingInterval?: number | undefined;
  userCodeCharset?: string | undefined;
  userCodeLength?: number | undefined;
  supportedTrustFrameworks?: Array<string> | undefined;
  supportedEvidence?: Array<string> | undefined;
  supportedIdentityDocuments?: Array<string> | undefined;
  supportedVerificationMethods?: Array<string> | undefined;
  supportedVerifiedClaims?: Array<string> | undefined;
  verifiedClaimsValidationSchemaSet?: string | undefined;
  attributes?: Array<ServiceCreateApiAttributeRequest$Outbound> | undefined;
  nbfOptional?: boolean | undefined;
  issSuppressed?: boolean | undefined;
  supportedCustomClientMetadata?: Array<string> | undefined;
  tokenExpirationLinked?: boolean | undefined;
  frontChannelRequestObjectEncryptionRequired?: boolean | undefined;
  requestObjectEncryptionAlgMatchRequired?: boolean | undefined;
  requestObjectEncryptionEncMatchRequired?: boolean | undefined;
  hsmEnabled?: boolean | undefined;
  hsks?: Array<ServiceCreateApiHskRequest$Outbound> | undefined;
  grantManagementEndpoint?: string | undefined;
  grantManagementActionRequired?: boolean | undefined;
  unauthorizedOnClientConfigSupported?: boolean | undefined;
  dcrScopeUsedAsRequestable?: boolean | undefined;
  endSessionEndpoint?: string | undefined;
  loopbackRedirectionUriVariable?: boolean | undefined;
  requestObjectAudienceChecked?: boolean | undefined;
  accessTokenForExternalAttachmentEmbedded?: boolean | undefined;
  authorityHints?: Array<string> | undefined;
  federationEnabled?: boolean | undefined;
  federationJwks?: string | undefined;
  federationSignatureKeyId?: string | undefined;
  federationConfigurationDuration?: number | undefined;
  federationRegistrationEndpoint?: string | undefined;
  organizationName?: string | undefined;
  predefinedTransformedClaims?: string | undefined;
  refreshTokenIdempotent?: boolean | undefined;
  signedJwksUri?: string | undefined;
  supportedAttachments?: Array<string> | undefined;
  supportedDigestAlgorithms?: Array<string> | undefined;
  supportedDocuments?: Array<string> | undefined;
  supportedDocumentsMethods?: Array<string> | undefined;
  supportedDocumentsValidationMethods?: Array<string> | undefined;
  supportedDocumentsVerificationMethods?: Array<string> | undefined;
  supportedElectronicRecords?: Array<string> | undefined;
  supportedClientRegistrationTypes?: Array<string> | undefined;
  tokenExchangeByIdentifiableClientsOnly?: boolean | undefined;
  tokenExchangeByConfidentialClientsOnly?: boolean | undefined;
  tokenExchangeByPermittedClientsOnly?: boolean | undefined;
  tokenExchangeEncryptedJwtRejected?: boolean | undefined;
  tokenExchangeUnsignedJwtRejected?: boolean | undefined;
  jwtGrantByIdentifiableClientsOnly?: boolean | undefined;
  jwtGrantEncryptedJwtRejected?: boolean | undefined;
  jwtGrantUnsignedJwtRejected?: boolean | undefined;
  dcrDuplicateSoftwareIdBlocked?: boolean | undefined;
  trustAnchors?: Array<ServiceCreateApiTrustAnchorRequest$Outbound> | undefined;
  openidDroppedOnRefreshWithoutOfflineAccess?: boolean | undefined;
  supportedDocumentsCheckMethods?: Array<string> | undefined;
  rsResponseSigned?: boolean | undefined;
  cnonceDuration?: number | undefined;
  dpopNonceRequired?: boolean | undefined;
  verifiableCredentialsEnabled?: boolean | undefined;
  credentialJwksUri?: string | undefined;
  credentialOfferDuration?: number | undefined;
  dpopNonceDuration?: number | undefined;
  preAuthorizedGrantAnonymousAccessSupported?: boolean | undefined;
  credentialTransactionDuration?: number | undefined;
  introspectionSignatureKeyId?: string | undefined;
  resourceSignatureKeyId?: string | undefined;
  userPinLength?: number | undefined;
  supportedPromptValues?: Array<string> | undefined;
  idTokenReissuable?: boolean | undefined;
  credentialJwks?: string | undefined;
  fapiModes?: Array<string> | undefined;
  credentialDuration?: number | undefined;
  credentialIssuerMetadata?:
    | ServiceCreateApiCredentialIssuerMetadataRequest$Outbound
    | undefined;
  idTokenAudType?: string | undefined;
};

/** @internal */
export const ServiceCreateApiRequest$outboundSchema: z.ZodType<
  ServiceCreateApiRequest$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiRequest
> = z.object({
  serviceName: z.string().optional(),
  issuer: z.string().optional(),
  description: z.string().optional(),
  clientIdAliasEnabled: z.boolean().optional(),
  metadata: z.array(
    z.lazy(() => ServiceCreateApiMetadatumRequest$outboundSchema),
  ).optional(),
  authenticationCallbackEndpoint: z.string().optional(),
  authenticationCallbackApiKey: z.string().optional(),
  authenticationCallbackApiSecret: z.string().optional(),
  supportedGrantTypes: z.array(
    ServiceCreateApiSupportedGrantTypeRequest$outboundSchema,
  ).optional(),
  supportedResponseTypes: z.array(
    ServiceCreateApiSupportedResponseTypeRequest$outboundSchema,
  ).optional(),
  supportedAuthorizationDetailsTypes: z.array(z.string()).optional(),
  supportedServiceProfiles: z.array(
    ServiceCreateApiSupportedServiceProfileRequest$outboundSchema,
  ).optional(),
  errorDescriptionOmitted: z.boolean().optional(),
  errorUriOmitted: z.boolean().optional(),
  authorizationEndpoint: z.string().optional(),
  directAuthorizationEndpointEnabled: z.boolean().optional(),
  supportedUiLocales: z.array(z.string()).optional(),
  supportedDisplays: z.array(
    ServiceCreateApiSupportedDisplayRequest$outboundSchema,
  ).optional(),
  pkceRequired: z.boolean().optional(),
  pkceS256Required: z.boolean().optional(),
  authorizationResponseDuration: z.number().int().optional(),
  tokenEndpoint: z.string().optional(),
  directTokenEndpointEnabled: z.boolean().optional(),
  supportedTokenAuthMethods: z.array(
    ServiceCreateApiSupportedTokenAuthMethodRequest$outboundSchema,
  ).optional(),
  missingClientIdAllowed: z.boolean().optional(),
  revocationEndpoint: z.string().optional(),
  directRevocationEndpointEnabled: z.boolean().optional(),
  supportedRevocationAuthMethods: z.array(
    ServiceCreateApiSupportedRevocationAuthMethodRequest$outboundSchema,
  ).optional(),
  introspectionEndpoint: z.string().optional(),
  directIntrospectionEndpointEnabled: z.boolean().optional(),
  supportedIntrospectionAuthMethods: z.array(
    ServiceCreateApiSupportedIntrospectionAuthMethodRequest$outboundSchema,
  ).optional(),
  pushedAuthReqEndpoint: z.string().optional(),
  pushedAuthReqDuration: z.number().int().optional(),
  parRequired: z.boolean().optional(),
  requestObjectRequired: z.boolean().optional(),
  traditionalRequestObjectProcessingApplied: z.boolean().optional(),
  mutualTlsValidatePkiCertChain: z.boolean().optional(),
  trustedRootCertificates: z.array(z.string()).optional(),
  mtlsEndpointAliases: z.array(
    z.lazy(() => ServiceCreateApiMtlsEndpointAliasRequest$outboundSchema),
  ).optional(),
  accessTokenType: z.string().optional(),
  tlsClientCertificateBoundAccessTokens: z.boolean().optional(),
  accessTokenDuration: z.number().int().optional(),
  singleAccessTokenPerSubject: z.boolean().optional(),
  accessTokenSignAlg: ServiceCreateApiAccessTokenSignAlgRequest$outboundSchema
    .optional(),
  accessTokenSignatureKeyId: z.string().optional(),
  refreshTokenDuration: z.number().int().optional(),
  refreshTokenDurationKept: z.boolean().optional(),
  refreshTokenDurationReset: z.boolean().optional(),
  refreshTokenKept: z.boolean().optional(),
  supportedScopes: z.array(
    z.lazy(() => ServiceCreateApiSupportedScopeRequest$outboundSchema),
  ).optional(),
  scopeRequired: z.boolean().optional(),
  idTokenDuration: z.number().int().optional(),
  allowableClockSkew: z.number().int().optional(),
  supportedClaimTypes: z.array(
    ServiceCreateApiSupportedClaimTypeRequest$outboundSchema,
  ).optional(),
  supportedClaimLocales: z.array(z.string()).optional(),
  supportedClaims: z.array(z.string()).optional(),
  claimShortcutRestrictive: z.boolean().optional(),
  jwksUri: z.string().optional(),
  directJwksEndpointEnabled: z.boolean().optional(),
  jwks: z.string().optional(),
  idTokenSignatureKeyId: z.string().optional(),
  userInfoSignatureKeyId: z.string().optional(),
  authorizationSignatureKeyId: z.string().optional(),
  userInfoEndpoint: z.string().optional(),
  directUserInfoEndpointEnabled: z.boolean().optional(),
  dynamicRegistrationSupported: z.boolean().optional(),
  registrationEndpoint: z.string().optional(),
  registrationManagementEndpoint: z.string().optional(),
  policyUri: z.string().optional(),
  tosUri: z.string().optional(),
  serviceDocumentation: z.string().optional(),
  backchannelAuthenticationEndpoint: z.string().optional(),
  supportedBackchannelTokenDeliveryModes: z.array(
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeRequest$outboundSchema,
  ).optional(),
  backchannelAuthReqIdDuration: z.number().int().optional(),
  backchannelPollingInterval: z.number().int().optional(),
  backchannelUserCodeParameterSupported: z.boolean().optional(),
  backchannelBindingMessageRequiredInFapi: z.boolean().optional(),
  deviceAuthorizationEndpoint: z.string().optional(),
  deviceVerificationUri: z.string().optional(),
  deviceVerificationUriComplete: z.string().optional(),
  deviceFlowCodeDuration: z.number().int().optional(),
  deviceFlowPollingInterval: z.number().int().optional(),
  userCodeCharset: ServiceCreateApiUserCodeCharsetRequest$outboundSchema
    .optional(),
  userCodeLength: z.number().int().optional(),
  supportedTrustFrameworks: z.array(z.string()).optional(),
  supportedEvidence: z.array(z.string()).optional(),
  supportedIdentityDocuments: z.array(z.string()).optional(),
  supportedVerificationMethods: z.array(z.string()).optional(),
  supportedVerifiedClaims: z.array(z.string()).optional(),
  verifiedClaimsValidationSchemaSet:
    ServiceCreateApiVerifiedClaimsValidationSchemaSetRequest$outboundSchema
      .optional(),
  attributes: z.array(
    z.lazy(() => ServiceCreateApiAttributeRequest$outboundSchema),
  ).optional(),
  nbfOptional: z.boolean().optional(),
  issSuppressed: z.boolean().optional(),
  supportedCustomClientMetadata: z.array(z.string()).optional(),
  tokenExpirationLinked: z.boolean().optional(),
  frontChannelRequestObjectEncryptionRequired: z.boolean().optional(),
  requestObjectEncryptionAlgMatchRequired: z.boolean().optional(),
  requestObjectEncryptionEncMatchRequired: z.boolean().optional(),
  hsmEnabled: z.boolean().optional(),
  hsks: z.array(z.lazy(() => ServiceCreateApiHskRequest$outboundSchema))
    .optional(),
  grantManagementEndpoint: z.string().optional(),
  grantManagementActionRequired: z.boolean().optional(),
  unauthorizedOnClientConfigSupported: z.boolean().optional(),
  dcrScopeUsedAsRequestable: z.boolean().optional(),
  endSessionEndpoint: z.string().optional(),
  loopbackRedirectionUriVariable: z.boolean().optional(),
  requestObjectAudienceChecked: z.boolean().optional(),
  accessTokenForExternalAttachmentEmbedded: z.boolean().optional(),
  authorityHints: z.array(z.string()).optional(),
  federationEnabled: z.boolean().optional(),
  federationJwks: z.string().optional(),
  federationSignatureKeyId: z.string().optional(),
  federationConfigurationDuration: z.number().int().optional(),
  federationRegistrationEndpoint: z.string().optional(),
  organizationName: z.string().optional(),
  predefinedTransformedClaims: z.string().optional(),
  refreshTokenIdempotent: z.boolean().optional(),
  signedJwksUri: z.string().optional(),
  supportedAttachments: z.array(
    ServiceCreateApiSupportedAttachmentRequest$outboundSchema,
  ).optional(),
  supportedDigestAlgorithms: z.array(z.string()).optional(),
  supportedDocuments: z.array(z.string()).optional(),
  supportedDocumentsMethods: z.array(z.string()).optional(),
  supportedDocumentsValidationMethods: z.array(z.string()).optional(),
  supportedDocumentsVerificationMethods: z.array(z.string()).optional(),
  supportedElectronicRecords: z.array(z.string()).optional(),
  supportedClientRegistrationTypes: z.array(
    ServiceCreateApiSupportedClientRegistrationTypeRequest$outboundSchema,
  ).optional(),
  tokenExchangeByIdentifiableClientsOnly: z.boolean().optional(),
  tokenExchangeByConfidentialClientsOnly: z.boolean().optional(),
  tokenExchangeByPermittedClientsOnly: z.boolean().optional(),
  tokenExchangeEncryptedJwtRejected: z.boolean().optional(),
  tokenExchangeUnsignedJwtRejected: z.boolean().optional(),
  jwtGrantByIdentifiableClientsOnly: z.boolean().optional(),
  jwtGrantEncryptedJwtRejected: z.boolean().optional(),
  jwtGrantUnsignedJwtRejected: z.boolean().optional(),
  dcrDuplicateSoftwareIdBlocked: z.boolean().optional(),
  trustAnchors: z.array(
    z.lazy(() => ServiceCreateApiTrustAnchorRequest$outboundSchema),
  ).optional(),
  openidDroppedOnRefreshWithoutOfflineAccess: z.boolean().optional(),
  supportedDocumentsCheckMethods: z.array(z.string()).optional(),
  rsResponseSigned: z.boolean().optional(),
  cnonceDuration: z.number().int().optional(),
  dpopNonceRequired: z.boolean().optional(),
  verifiableCredentialsEnabled: z.boolean().optional(),
  credentialJwksUri: z.string().optional(),
  credentialOfferDuration: z.number().int().optional(),
  dpopNonceDuration: z.number().int().optional(),
  preAuthorizedGrantAnonymousAccessSupported: z.boolean().optional(),
  credentialTransactionDuration: z.number().int().optional(),
  introspectionSignatureKeyId: z.string().optional(),
  resourceSignatureKeyId: z.string().optional(),
  userPinLength: z.number().int().optional(),
  supportedPromptValues: z.array(
    ServiceCreateApiSupportedPromptValueRequest$outboundSchema,
  ).optional(),
  idTokenReissuable: z.boolean().optional(),
  credentialJwks: z.string().optional(),
  fapiModes: z.array(ServiceCreateApiFapiModeRequest$outboundSchema).optional(),
  credentialDuration: z.number().int().optional(),
  credentialIssuerMetadata: z.lazy(() =>
    ServiceCreateApiCredentialIssuerMetadataRequest$outboundSchema
  ).optional(),
  idTokenAudType: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiRequest$ {
  /** @deprecated use `ServiceCreateApiRequest$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiRequest$inboundSchema;
  /** @deprecated use `ServiceCreateApiRequest$outboundSchema` instead. */
  export const outboundSchema = ServiceCreateApiRequest$outboundSchema;
  /** @deprecated use `ServiceCreateApiRequest$Outbound` instead. */
  export type Outbound = ServiceCreateApiRequest$Outbound;
}

export function serviceCreateApiRequestToJSON(
  serviceCreateApiRequest: ServiceCreateApiRequest,
): string {
  return JSON.stringify(
    ServiceCreateApiRequest$outboundSchema.parse(serviceCreateApiRequest),
  );
}

export function serviceCreateApiRequestFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ServiceCreateApiRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiRequest' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiMetadatumResponse$inboundSchema: z.ZodType<
  ServiceCreateApiMetadatumResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiMetadatumResponse$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ServiceCreateApiMetadatumResponse$outboundSchema: z.ZodType<
  ServiceCreateApiMetadatumResponse$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiMetadatumResponse
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiMetadatumResponse$ {
  /** @deprecated use `ServiceCreateApiMetadatumResponse$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiMetadatumResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiMetadatumResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiMetadatumResponse$outboundSchema;
  /** @deprecated use `ServiceCreateApiMetadatumResponse$Outbound` instead. */
  export type Outbound = ServiceCreateApiMetadatumResponse$Outbound;
}

export function serviceCreateApiMetadatumResponseToJSON(
  serviceCreateApiMetadatumResponse: ServiceCreateApiMetadatumResponse,
): string {
  return JSON.stringify(
    ServiceCreateApiMetadatumResponse$outboundSchema.parse(
      serviceCreateApiMetadatumResponse,
    ),
  );
}

export function serviceCreateApiMetadatumResponseFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiMetadatumResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ServiceCreateApiMetadatumResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiMetadatumResponse' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedGrantTypeResponse$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedGrantTypeResponse> = z
    .nativeEnum(ServiceCreateApiSupportedGrantTypeResponse);

/** @internal */
export const ServiceCreateApiSupportedGrantTypeResponse$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedGrantTypeResponse> =
    ServiceCreateApiSupportedGrantTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedGrantTypeResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedGrantTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedGrantTypeResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedGrantTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedGrantTypeResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedResponseTypeResponse$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedResponseTypeResponse> = z
    .nativeEnum(ServiceCreateApiSupportedResponseTypeResponse);

/** @internal */
export const ServiceCreateApiSupportedResponseTypeResponse$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedResponseTypeResponse> =
    ServiceCreateApiSupportedResponseTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedResponseTypeResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedResponseTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedResponseTypeResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedResponseTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedResponseTypeResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedServiceProfileResponse$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedServiceProfileResponse> = z
    .nativeEnum(ServiceCreateApiSupportedServiceProfileResponse);

/** @internal */
export const ServiceCreateApiSupportedServiceProfileResponse$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedServiceProfileResponse> =
    ServiceCreateApiSupportedServiceProfileResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedServiceProfileResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedServiceProfileResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedServiceProfileResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedServiceProfileResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedServiceProfileResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedDisplayResponse$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedDisplayResponse> = z
    .nativeEnum(ServiceCreateApiSupportedDisplayResponse);

/** @internal */
export const ServiceCreateApiSupportedDisplayResponse$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedDisplayResponse> =
    ServiceCreateApiSupportedDisplayResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedDisplayResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedDisplayResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedDisplayResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedDisplayResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedDisplayResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedTokenAuthMethodResponse$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedTokenAuthMethodResponse> = z
    .nativeEnum(ServiceCreateApiSupportedTokenAuthMethodResponse);

/** @internal */
export const ServiceCreateApiSupportedTokenAuthMethodResponse$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedTokenAuthMethodResponse> =
    ServiceCreateApiSupportedTokenAuthMethodResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedTokenAuthMethodResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedTokenAuthMethodResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedTokenAuthMethodResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedTokenAuthMethodResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedTokenAuthMethodResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedRevocationAuthMethodResponse$inboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedRevocationAuthMethodResponse
  > = z.nativeEnum(ServiceCreateApiSupportedRevocationAuthMethodResponse);

/** @internal */
export const ServiceCreateApiSupportedRevocationAuthMethodResponse$outboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedRevocationAuthMethodResponse
  > = ServiceCreateApiSupportedRevocationAuthMethodResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedRevocationAuthMethodResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedRevocationAuthMethodResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedRevocationAuthMethodResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedRevocationAuthMethodResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedRevocationAuthMethodResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedIntrospectionAuthMethodResponse$inboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedIntrospectionAuthMethodResponse
  > = z.nativeEnum(ServiceCreateApiSupportedIntrospectionAuthMethodResponse);

/** @internal */
export const ServiceCreateApiSupportedIntrospectionAuthMethodResponse$outboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedIntrospectionAuthMethodResponse
  > = ServiceCreateApiSupportedIntrospectionAuthMethodResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedIntrospectionAuthMethodResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedIntrospectionAuthMethodResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedIntrospectionAuthMethodResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedIntrospectionAuthMethodResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedIntrospectionAuthMethodResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiMtlsEndpointAliasResponse$inboundSchema: z.ZodType<
  ServiceCreateApiMtlsEndpointAliasResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  uri: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiMtlsEndpointAliasResponse$Outbound = {
  name?: string | undefined;
  uri?: string | undefined;
};

/** @internal */
export const ServiceCreateApiMtlsEndpointAliasResponse$outboundSchema:
  z.ZodType<
    ServiceCreateApiMtlsEndpointAliasResponse$Outbound,
    z.ZodTypeDef,
    ServiceCreateApiMtlsEndpointAliasResponse
  > = z.object({
    name: z.string().optional(),
    uri: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiMtlsEndpointAliasResponse$ {
  /** @deprecated use `ServiceCreateApiMtlsEndpointAliasResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiMtlsEndpointAliasResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiMtlsEndpointAliasResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiMtlsEndpointAliasResponse$outboundSchema;
  /** @deprecated use `ServiceCreateApiMtlsEndpointAliasResponse$Outbound` instead. */
  export type Outbound = ServiceCreateApiMtlsEndpointAliasResponse$Outbound;
}

export function serviceCreateApiMtlsEndpointAliasResponseToJSON(
  serviceCreateApiMtlsEndpointAliasResponse:
    ServiceCreateApiMtlsEndpointAliasResponse,
): string {
  return JSON.stringify(
    ServiceCreateApiMtlsEndpointAliasResponse$outboundSchema.parse(
      serviceCreateApiMtlsEndpointAliasResponse,
    ),
  );
}

export function serviceCreateApiMtlsEndpointAliasResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ServiceCreateApiMtlsEndpointAliasResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiMtlsEndpointAliasResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ServiceCreateApiMtlsEndpointAliasResponse' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiAccessTokenSignAlgResponse$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiAccessTokenSignAlgResponse> = z
    .nativeEnum(ServiceCreateApiAccessTokenSignAlgResponse);

/** @internal */
export const ServiceCreateApiAccessTokenSignAlgResponse$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiAccessTokenSignAlgResponse> =
    ServiceCreateApiAccessTokenSignAlgResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiAccessTokenSignAlgResponse$ {
  /** @deprecated use `ServiceCreateApiAccessTokenSignAlgResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiAccessTokenSignAlgResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiAccessTokenSignAlgResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiAccessTokenSignAlgResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiDescriptionResponse$inboundSchema: z.ZodType<
  ServiceCreateApiDescriptionResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiDescriptionResponse$Outbound = {
  tag?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ServiceCreateApiDescriptionResponse$outboundSchema: z.ZodType<
  ServiceCreateApiDescriptionResponse$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiDescriptionResponse
> = z.object({
  tag: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiDescriptionResponse$ {
  /** @deprecated use `ServiceCreateApiDescriptionResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiDescriptionResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiDescriptionResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiDescriptionResponse$outboundSchema;
  /** @deprecated use `ServiceCreateApiDescriptionResponse$Outbound` instead. */
  export type Outbound = ServiceCreateApiDescriptionResponse$Outbound;
}

export function serviceCreateApiDescriptionResponseToJSON(
  serviceCreateApiDescriptionResponse: ServiceCreateApiDescriptionResponse,
): string {
  return JSON.stringify(
    ServiceCreateApiDescriptionResponse$outboundSchema.parse(
      serviceCreateApiDescriptionResponse,
    ),
  );
}

export function serviceCreateApiDescriptionResponseFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiDescriptionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiDescriptionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiDescriptionResponse' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedScopeAttributeResponse$inboundSchema:
  z.ZodType<
    ServiceCreateApiSupportedScopeAttributeResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    key: z.string().optional(),
    value: z.string().optional(),
  });

/** @internal */
export type ServiceCreateApiSupportedScopeAttributeResponse$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ServiceCreateApiSupportedScopeAttributeResponse$outboundSchema:
  z.ZodType<
    ServiceCreateApiSupportedScopeAttributeResponse$Outbound,
    z.ZodTypeDef,
    ServiceCreateApiSupportedScopeAttributeResponse
  > = z.object({
    key: z.string().optional(),
    value: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedScopeAttributeResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedScopeAttributeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedScopeAttributeResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedScopeAttributeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedScopeAttributeResponse$outboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedScopeAttributeResponse$Outbound` instead. */
  export type Outbound =
    ServiceCreateApiSupportedScopeAttributeResponse$Outbound;
}

export function serviceCreateApiSupportedScopeAttributeResponseToJSON(
  serviceCreateApiSupportedScopeAttributeResponse:
    ServiceCreateApiSupportedScopeAttributeResponse,
): string {
  return JSON.stringify(
    ServiceCreateApiSupportedScopeAttributeResponse$outboundSchema.parse(
      serviceCreateApiSupportedScopeAttributeResponse,
    ),
  );
}

export function serviceCreateApiSupportedScopeAttributeResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ServiceCreateApiSupportedScopeAttributeResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiSupportedScopeAttributeResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ServiceCreateApiSupportedScopeAttributeResponse' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedScopeResponse$inboundSchema: z.ZodType<
  ServiceCreateApiSupportedScopeResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  defaultEntry: z.boolean().optional(),
  description: z.string().optional(),
  descriptions: z.array(
    z.lazy(() => ServiceCreateApiDescriptionResponse$inboundSchema),
  ).optional(),
  attributes: z.array(
    z.lazy(() => ServiceCreateApiSupportedScopeAttributeResponse$inboundSchema),
  ).optional(),
});

/** @internal */
export type ServiceCreateApiSupportedScopeResponse$Outbound = {
  name?: string | undefined;
  defaultEntry?: boolean | undefined;
  description?: string | undefined;
  descriptions?:
    | Array<ServiceCreateApiDescriptionResponse$Outbound>
    | undefined;
  attributes?:
    | Array<ServiceCreateApiSupportedScopeAttributeResponse$Outbound>
    | undefined;
};

/** @internal */
export const ServiceCreateApiSupportedScopeResponse$outboundSchema: z.ZodType<
  ServiceCreateApiSupportedScopeResponse$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiSupportedScopeResponse
> = z.object({
  name: z.string().optional(),
  defaultEntry: z.boolean().optional(),
  description: z.string().optional(),
  descriptions: z.array(
    z.lazy(() => ServiceCreateApiDescriptionResponse$outboundSchema),
  ).optional(),
  attributes: z.array(
    z.lazy(() =>
      ServiceCreateApiSupportedScopeAttributeResponse$outboundSchema
    ),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedScopeResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedScopeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedScopeResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedScopeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedScopeResponse$outboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedScopeResponse$Outbound` instead. */
  export type Outbound = ServiceCreateApiSupportedScopeResponse$Outbound;
}

export function serviceCreateApiSupportedScopeResponseToJSON(
  serviceCreateApiSupportedScopeResponse:
    ServiceCreateApiSupportedScopeResponse,
): string {
  return JSON.stringify(
    ServiceCreateApiSupportedScopeResponse$outboundSchema.parse(
      serviceCreateApiSupportedScopeResponse,
    ),
  );
}

export function serviceCreateApiSupportedScopeResponseFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiSupportedScopeResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiSupportedScopeResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiSupportedScopeResponse' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedClaimTypeResponse$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedClaimTypeResponse> = z
    .nativeEnum(ServiceCreateApiSupportedClaimTypeResponse);

/** @internal */
export const ServiceCreateApiSupportedClaimTypeResponse$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedClaimTypeResponse> =
    ServiceCreateApiSupportedClaimTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedClaimTypeResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedClaimTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedClaimTypeResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedClaimTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedClaimTypeResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse$inboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse
  > = z.nativeEnum(
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse,
  );

/** @internal */
export const ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse$outboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse
  > =
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiUserCodeCharsetResponse$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiUserCodeCharsetResponse> = z
    .nativeEnum(ServiceCreateApiUserCodeCharsetResponse);

/** @internal */
export const ServiceCreateApiUserCodeCharsetResponse$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiUserCodeCharsetResponse> =
    ServiceCreateApiUserCodeCharsetResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiUserCodeCharsetResponse$ {
  /** @deprecated use `ServiceCreateApiUserCodeCharsetResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiUserCodeCharsetResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiUserCodeCharsetResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiUserCodeCharsetResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse$inboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse
  > = z.nativeEnum(ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse);

/** @internal */
export const ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse$outboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse
  > = ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse$ {
  /** @deprecated use `ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiAttributeResponse$inboundSchema: z.ZodType<
  ServiceCreateApiAttributeResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiAttributeResponse$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const ServiceCreateApiAttributeResponse$outboundSchema: z.ZodType<
  ServiceCreateApiAttributeResponse$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiAttributeResponse
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiAttributeResponse$ {
  /** @deprecated use `ServiceCreateApiAttributeResponse$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiAttributeResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiAttributeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiAttributeResponse$outboundSchema;
  /** @deprecated use `ServiceCreateApiAttributeResponse$Outbound` instead. */
  export type Outbound = ServiceCreateApiAttributeResponse$Outbound;
}

export function serviceCreateApiAttributeResponseToJSON(
  serviceCreateApiAttributeResponse: ServiceCreateApiAttributeResponse,
): string {
  return JSON.stringify(
    ServiceCreateApiAttributeResponse$outboundSchema.parse(
      serviceCreateApiAttributeResponse,
    ),
  );
}

export function serviceCreateApiAttributeResponseFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiAttributeResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ServiceCreateApiAttributeResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiAttributeResponse' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiHskResponse$inboundSchema: z.ZodType<
  ServiceCreateApiHskResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  kty: z.string().optional(),
  use: z.string().optional(),
  kid: z.string().optional(),
  hsmName: z.string().optional(),
  handle: z.string().optional(),
  publicKey: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiHskResponse$Outbound = {
  kty?: string | undefined;
  use?: string | undefined;
  kid?: string | undefined;
  hsmName?: string | undefined;
  handle?: string | undefined;
  publicKey?: string | undefined;
};

/** @internal */
export const ServiceCreateApiHskResponse$outboundSchema: z.ZodType<
  ServiceCreateApiHskResponse$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiHskResponse
> = z.object({
  kty: z.string().optional(),
  use: z.string().optional(),
  kid: z.string().optional(),
  hsmName: z.string().optional(),
  handle: z.string().optional(),
  publicKey: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiHskResponse$ {
  /** @deprecated use `ServiceCreateApiHskResponse$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiHskResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiHskResponse$outboundSchema` instead. */
  export const outboundSchema = ServiceCreateApiHskResponse$outboundSchema;
  /** @deprecated use `ServiceCreateApiHskResponse$Outbound` instead. */
  export type Outbound = ServiceCreateApiHskResponse$Outbound;
}

export function serviceCreateApiHskResponseToJSON(
  serviceCreateApiHskResponse: ServiceCreateApiHskResponse,
): string {
  return JSON.stringify(
    ServiceCreateApiHskResponse$outboundSchema.parse(
      serviceCreateApiHskResponse,
    ),
  );
}

export function serviceCreateApiHskResponseFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiHskResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ServiceCreateApiHskResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiHskResponse' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedAttachmentResponse$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedAttachmentResponse> = z
    .nativeEnum(ServiceCreateApiSupportedAttachmentResponse);

/** @internal */
export const ServiceCreateApiSupportedAttachmentResponse$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedAttachmentResponse> =
    ServiceCreateApiSupportedAttachmentResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedAttachmentResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedAttachmentResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedAttachmentResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedAttachmentResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedAttachmentResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiSupportedClientRegistrationTypeResponse$inboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedClientRegistrationTypeResponse
  > = z.nativeEnum(ServiceCreateApiSupportedClientRegistrationTypeResponse);

/** @internal */
export const ServiceCreateApiSupportedClientRegistrationTypeResponse$outboundSchema:
  z.ZodNativeEnum<
    typeof ServiceCreateApiSupportedClientRegistrationTypeResponse
  > = ServiceCreateApiSupportedClientRegistrationTypeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedClientRegistrationTypeResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedClientRegistrationTypeResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedClientRegistrationTypeResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedClientRegistrationTypeResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedClientRegistrationTypeResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiTrustAnchorResponse$inboundSchema: z.ZodType<
  ServiceCreateApiTrustAnchorResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  entityId: z.string().optional(),
  jwks: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiTrustAnchorResponse$Outbound = {
  entityId?: string | undefined;
  jwks?: string | undefined;
};

/** @internal */
export const ServiceCreateApiTrustAnchorResponse$outboundSchema: z.ZodType<
  ServiceCreateApiTrustAnchorResponse$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiTrustAnchorResponse
> = z.object({
  entityId: z.string().optional(),
  jwks: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiTrustAnchorResponse$ {
  /** @deprecated use `ServiceCreateApiTrustAnchorResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiTrustAnchorResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiTrustAnchorResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiTrustAnchorResponse$outboundSchema;
  /** @deprecated use `ServiceCreateApiTrustAnchorResponse$Outbound` instead. */
  export type Outbound = ServiceCreateApiTrustAnchorResponse$Outbound;
}

export function serviceCreateApiTrustAnchorResponseToJSON(
  serviceCreateApiTrustAnchorResponse: ServiceCreateApiTrustAnchorResponse,
): string {
  return JSON.stringify(
    ServiceCreateApiTrustAnchorResponse$outboundSchema.parse(
      serviceCreateApiTrustAnchorResponse,
    ),
  );
}

export function serviceCreateApiTrustAnchorResponseFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiTrustAnchorResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiTrustAnchorResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiTrustAnchorResponse' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiSupportedPromptValueResponse$inboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedPromptValueResponse> = z
    .nativeEnum(ServiceCreateApiSupportedPromptValueResponse);

/** @internal */
export const ServiceCreateApiSupportedPromptValueResponse$outboundSchema:
  z.ZodNativeEnum<typeof ServiceCreateApiSupportedPromptValueResponse> =
    ServiceCreateApiSupportedPromptValueResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiSupportedPromptValueResponse$ {
  /** @deprecated use `ServiceCreateApiSupportedPromptValueResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiSupportedPromptValueResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiSupportedPromptValueResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiSupportedPromptValueResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiFapiModeResponse$inboundSchema: z.ZodNativeEnum<
  typeof ServiceCreateApiFapiModeResponse
> = z.nativeEnum(ServiceCreateApiFapiModeResponse);

/** @internal */
export const ServiceCreateApiFapiModeResponse$outboundSchema: z.ZodNativeEnum<
  typeof ServiceCreateApiFapiModeResponse
> = ServiceCreateApiFapiModeResponse$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiFapiModeResponse$ {
  /** @deprecated use `ServiceCreateApiFapiModeResponse$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiFapiModeResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiFapiModeResponse$outboundSchema` instead. */
  export const outboundSchema = ServiceCreateApiFapiModeResponse$outboundSchema;
}

/** @internal */
export const ServiceCreateApiCredentialIssuerMetadataResponse$inboundSchema:
  z.ZodType<
    ServiceCreateApiCredentialIssuerMetadataResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    credentialIssuer: z.string().optional(),
    authorizationServer: z.string().optional(),
    credentialEndpoint: z.boolean().optional(),
    batchCredentialEndpoint: z.number().int().optional(),
    deferredCredentialEndpoint: z.string().optional(),
    credentialsSupported: z.boolean().optional(),
  });

/** @internal */
export type ServiceCreateApiCredentialIssuerMetadataResponse$Outbound = {
  credentialIssuer?: string | undefined;
  authorizationServer?: string | undefined;
  credentialEndpoint?: boolean | undefined;
  batchCredentialEndpoint?: number | undefined;
  deferredCredentialEndpoint?: string | undefined;
  credentialsSupported?: boolean | undefined;
};

/** @internal */
export const ServiceCreateApiCredentialIssuerMetadataResponse$outboundSchema:
  z.ZodType<
    ServiceCreateApiCredentialIssuerMetadataResponse$Outbound,
    z.ZodTypeDef,
    ServiceCreateApiCredentialIssuerMetadataResponse
  > = z.object({
    credentialIssuer: z.string().optional(),
    authorizationServer: z.string().optional(),
    credentialEndpoint: z.boolean().optional(),
    batchCredentialEndpoint: z.number().int().optional(),
    deferredCredentialEndpoint: z.string().optional(),
    credentialsSupported: z.boolean().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiCredentialIssuerMetadataResponse$ {
  /** @deprecated use `ServiceCreateApiCredentialIssuerMetadataResponse$inboundSchema` instead. */
  export const inboundSchema =
    ServiceCreateApiCredentialIssuerMetadataResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiCredentialIssuerMetadataResponse$outboundSchema` instead. */
  export const outboundSchema =
    ServiceCreateApiCredentialIssuerMetadataResponse$outboundSchema;
  /** @deprecated use `ServiceCreateApiCredentialIssuerMetadataResponse$Outbound` instead. */
  export type Outbound =
    ServiceCreateApiCredentialIssuerMetadataResponse$Outbound;
}

export function serviceCreateApiCredentialIssuerMetadataResponseToJSON(
  serviceCreateApiCredentialIssuerMetadataResponse:
    ServiceCreateApiCredentialIssuerMetadataResponse,
): string {
  return JSON.stringify(
    ServiceCreateApiCredentialIssuerMetadataResponse$outboundSchema.parse(
      serviceCreateApiCredentialIssuerMetadataResponse,
    ),
  );
}

export function serviceCreateApiCredentialIssuerMetadataResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ServiceCreateApiCredentialIssuerMetadataResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ServiceCreateApiCredentialIssuerMetadataResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ServiceCreateApiCredentialIssuerMetadataResponse' from JSON`,
  );
}

/** @internal */
export const ServiceCreateApiResponse$inboundSchema: z.ZodType<
  ServiceCreateApiResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  number: z.number().int().optional(),
  serviceName: z.string().optional(),
  issuer: z.string().optional(),
  description: z.string().optional(),
  apiKey: z.number().int().optional(),
  clientIdAliasEnabled: z.boolean().optional(),
  metadata: z.array(
    z.lazy(() => ServiceCreateApiMetadatumResponse$inboundSchema),
  ).optional(),
  createdAt: z.number().int().optional(),
  modifiedAt: z.number().int().optional(),
  authenticationCallbackEndpoint: z.string().optional(),
  authenticationCallbackApiKey: z.string().optional(),
  authenticationCallbackApiSecret: z.string().optional(),
  supportedAcrs: z.array(z.string()).optional(),
  supportedGrantTypes: z.array(
    ServiceCreateApiSupportedGrantTypeResponse$inboundSchema,
  ).optional(),
  supportedResponseTypes: z.array(
    ServiceCreateApiSupportedResponseTypeResponse$inboundSchema,
  ).optional(),
  supportedAuthorizationDetailsTypes: z.array(z.string()).optional(),
  supportedServiceProfiles: z.array(
    ServiceCreateApiSupportedServiceProfileResponse$inboundSchema,
  ).optional(),
  errorDescriptionOmitted: z.boolean().optional(),
  errorUriOmitted: z.boolean().optional(),
  authorizationEndpoint: z.string().optional(),
  directAuthorizationEndpointEnabled: z.boolean().optional(),
  supportedUiLocales: z.array(z.string()).optional(),
  supportedDisplays: z.array(
    ServiceCreateApiSupportedDisplayResponse$inboundSchema,
  ).optional(),
  pkceRequired: z.boolean().optional(),
  pkceS256Required: z.boolean().optional(),
  authorizationResponseDuration: z.number().int().optional(),
  tokenEndpoint: z.string().optional(),
  directTokenEndpointEnabled: z.boolean().optional(),
  supportedTokenAuthMethods: z.array(
    ServiceCreateApiSupportedTokenAuthMethodResponse$inboundSchema,
  ).optional(),
  missingClientIdAllowed: z.boolean().optional(),
  revocationEndpoint: z.string().optional(),
  directRevocationEndpointEnabled: z.boolean().optional(),
  supportedRevocationAuthMethods: z.array(
    ServiceCreateApiSupportedRevocationAuthMethodResponse$inboundSchema,
  ).optional(),
  introspectionEndpoint: z.string().optional(),
  directIntrospectionEndpointEnabled: z.boolean().optional(),
  supportedIntrospectionAuthMethods: z.array(
    ServiceCreateApiSupportedIntrospectionAuthMethodResponse$inboundSchema,
  ).optional(),
  pushedAuthReqEndpoint: z.string().optional(),
  pushedAuthReqDuration: z.number().int().optional(),
  parRequired: z.boolean().optional(),
  requestObjectRequired: z.boolean().optional(),
  traditionalRequestObjectProcessingApplied: z.boolean().optional(),
  mutualTlsValidatePkiCertChain: z.boolean().optional(),
  trustedRootCertificates: z.array(z.string()).optional(),
  mtlsEndpointAliases: z.array(
    z.lazy(() => ServiceCreateApiMtlsEndpointAliasResponse$inboundSchema),
  ).optional(),
  accessTokenType: z.string().optional(),
  tlsClientCertificateBoundAccessTokens: z.boolean().optional(),
  accessTokenDuration: z.number().int().optional(),
  singleAccessTokenPerSubject: z.boolean().optional(),
  accessTokenSignAlg: ServiceCreateApiAccessTokenSignAlgResponse$inboundSchema
    .optional(),
  accessTokenSignatureKeyId: z.string().optional(),
  refreshTokenDuration: z.number().int().optional(),
  refreshTokenDurationKept: z.boolean().optional(),
  refreshTokenDurationReset: z.boolean().optional(),
  refreshTokenKept: z.boolean().optional(),
  supportedScopes: z.array(
    z.lazy(() => ServiceCreateApiSupportedScopeResponse$inboundSchema),
  ).optional(),
  scopeRequired: z.boolean().optional(),
  idTokenDuration: z.number().int().optional(),
  allowableClockSkew: z.number().int().optional(),
  supportedClaimTypes: z.array(
    ServiceCreateApiSupportedClaimTypeResponse$inboundSchema,
  ).optional(),
  supportedClaimLocales: z.array(z.string()).optional(),
  supportedClaims: z.array(z.string()).optional(),
  claimShortcutRestrictive: z.boolean().optional(),
  jwksUri: z.string().optional(),
  directJwksEndpointEnabled: z.boolean().optional(),
  jwks: z.string().optional(),
  idTokenSignatureKeyId: z.string().optional(),
  userInfoSignatureKeyId: z.string().optional(),
  authorizationSignatureKeyId: z.string().optional(),
  userInfoEndpoint: z.string().optional(),
  directUserInfoEndpointEnabled: z.boolean().optional(),
  dynamicRegistrationSupported: z.boolean().optional(),
  registrationEndpoint: z.string().optional(),
  registrationManagementEndpoint: z.string().optional(),
  policyUri: z.string().optional(),
  tosUri: z.string().optional(),
  serviceDocumentation: z.string().optional(),
  backchannelAuthenticationEndpoint: z.string().optional(),
  supportedBackchannelTokenDeliveryModes: z.array(
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse$inboundSchema,
  ).optional(),
  backchannelAuthReqIdDuration: z.number().int().optional(),
  backchannelPollingInterval: z.number().int().optional(),
  backchannelUserCodeParameterSupported: z.boolean().optional(),
  backchannelBindingMessageRequiredInFapi: z.boolean().optional(),
  deviceAuthorizationEndpoint: z.string().optional(),
  deviceVerificationUri: z.string().optional(),
  deviceVerificationUriComplete: z.string().optional(),
  deviceFlowCodeDuration: z.number().int().optional(),
  deviceFlowPollingInterval: z.number().int().optional(),
  userCodeCharset: ServiceCreateApiUserCodeCharsetResponse$inboundSchema
    .optional(),
  userCodeLength: z.number().int().optional(),
  supportedTrustFrameworks: z.array(z.string()).optional(),
  supportedEvidence: z.array(z.string()).optional(),
  supportedIdentityDocuments: z.array(z.string()).optional(),
  supportedVerificationMethods: z.array(z.string()).optional(),
  supportedVerifiedClaims: z.array(z.string()).optional(),
  verifiedClaimsValidationSchemaSet:
    ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse$inboundSchema
      .optional(),
  attributes: z.array(
    z.lazy(() => ServiceCreateApiAttributeResponse$inboundSchema),
  ).optional(),
  nbfOptional: z.boolean().optional(),
  issSuppressed: z.boolean().optional(),
  supportedCustomClientMetadata: z.array(z.string()).optional(),
  tokenExpirationLinked: z.boolean().optional(),
  frontChannelRequestObjectEncryptionRequired: z.boolean().optional(),
  requestObjectEncryptionAlgMatchRequired: z.boolean().optional(),
  requestObjectEncryptionEncMatchRequired: z.boolean().optional(),
  hsmEnabled: z.boolean().optional(),
  hsks: z.array(z.lazy(() => ServiceCreateApiHskResponse$inboundSchema))
    .optional(),
  grantManagementEndpoint: z.string().optional(),
  grantManagementActionRequired: z.boolean().optional(),
  unauthorizedOnClientConfigSupported: z.boolean().optional(),
  dcrScopeUsedAsRequestable: z.boolean().optional(),
  endSessionEndpoint: z.string().optional(),
  loopbackRedirectionUriVariable: z.boolean().optional(),
  requestObjectAudienceChecked: z.boolean().optional(),
  accessTokenForExternalAttachmentEmbedded: z.boolean().optional(),
  authorityHints: z.array(z.string()).optional(),
  federationEnabled: z.boolean().optional(),
  federationJwks: z.string().optional(),
  federationSignatureKeyId: z.string().optional(),
  federationConfigurationDuration: z.number().int().optional(),
  federationRegistrationEndpoint: z.string().optional(),
  organizationName: z.string().optional(),
  predefinedTransformedClaims: z.string().optional(),
  refreshTokenIdempotent: z.boolean().optional(),
  signedJwksUri: z.string().optional(),
  supportedAttachments: z.array(
    ServiceCreateApiSupportedAttachmentResponse$inboundSchema,
  ).optional(),
  supportedDigestAlgorithms: z.array(z.string()).optional(),
  supportedDocuments: z.array(z.string()).optional(),
  supportedDocumentsMethods: z.array(z.string()).optional(),
  supportedDocumentsValidationMethods: z.array(z.string()).optional(),
  supportedDocumentsVerificationMethods: z.array(z.string()).optional(),
  supportedElectronicRecords: z.array(z.string()).optional(),
  supportedClientRegistrationTypes: z.array(
    ServiceCreateApiSupportedClientRegistrationTypeResponse$inboundSchema,
  ).optional(),
  tokenExchangeByIdentifiableClientsOnly: z.boolean().optional(),
  tokenExchangeByConfidentialClientsOnly: z.boolean().optional(),
  tokenExchangeByPermittedClientsOnly: z.boolean().optional(),
  tokenExchangeEncryptedJwtRejected: z.boolean().optional(),
  tokenExchangeUnsignedJwtRejected: z.boolean().optional(),
  jwtGrantByIdentifiableClientsOnly: z.boolean().optional(),
  jwtGrantEncryptedJwtRejected: z.boolean().optional(),
  jwtGrantUnsignedJwtRejected: z.boolean().optional(),
  dcrDuplicateSoftwareIdBlocked: z.boolean().optional(),
  trustAnchors: z.array(
    z.lazy(() => ServiceCreateApiTrustAnchorResponse$inboundSchema),
  ).optional(),
  openidDroppedOnRefreshWithoutOfflineAccess: z.boolean().optional(),
  supportedDocumentsCheckMethods: z.array(z.string()).optional(),
  rsResponseSigned: z.boolean().optional(),
  cnonceDuration: z.number().int().optional(),
  dpopNonceRequired: z.boolean().optional(),
  verifiableCredentialsEnabled: z.boolean().optional(),
  credentialJwksUri: z.string().optional(),
  credentialOfferDuration: z.number().int().optional(),
  dpopNonceDuration: z.number().int().optional(),
  preAuthorizedGrantAnonymousAccessSupported: z.boolean().optional(),
  credentialTransactionDuration: z.number().int().optional(),
  introspectionSignatureKeyId: z.string().optional(),
  resourceSignatureKeyId: z.string().optional(),
  userPinLength: z.number().int().optional(),
  supportedPromptValues: z.array(
    ServiceCreateApiSupportedPromptValueResponse$inboundSchema,
  ).optional(),
  idTokenReissuable: z.boolean().optional(),
  credentialJwks: z.string().optional(),
  fapiModes: z.array(ServiceCreateApiFapiModeResponse$inboundSchema).optional(),
  credentialDuration: z.number().int().optional(),
  credentialIssuerMetadata: z.lazy(() =>
    ServiceCreateApiCredentialIssuerMetadataResponse$inboundSchema
  ).optional(),
  idTokenAudType: z.string().optional(),
});

/** @internal */
export type ServiceCreateApiResponse$Outbound = {
  number?: number | undefined;
  serviceName?: string | undefined;
  issuer?: string | undefined;
  description?: string | undefined;
  apiKey?: number | undefined;
  clientIdAliasEnabled?: boolean | undefined;
  metadata?: Array<ServiceCreateApiMetadatumResponse$Outbound> | undefined;
  createdAt?: number | undefined;
  modifiedAt?: number | undefined;
  authenticationCallbackEndpoint?: string | undefined;
  authenticationCallbackApiKey?: string | undefined;
  authenticationCallbackApiSecret?: string | undefined;
  supportedAcrs?: Array<string> | undefined;
  supportedGrantTypes?: Array<string> | undefined;
  supportedResponseTypes?: Array<string> | undefined;
  supportedAuthorizationDetailsTypes?: Array<string> | undefined;
  supportedServiceProfiles?: Array<string> | undefined;
  errorDescriptionOmitted?: boolean | undefined;
  errorUriOmitted?: boolean | undefined;
  authorizationEndpoint?: string | undefined;
  directAuthorizationEndpointEnabled?: boolean | undefined;
  supportedUiLocales?: Array<string> | undefined;
  supportedDisplays?: Array<string> | undefined;
  pkceRequired?: boolean | undefined;
  pkceS256Required?: boolean | undefined;
  authorizationResponseDuration?: number | undefined;
  tokenEndpoint?: string | undefined;
  directTokenEndpointEnabled?: boolean | undefined;
  supportedTokenAuthMethods?: Array<string> | undefined;
  missingClientIdAllowed?: boolean | undefined;
  revocationEndpoint?: string | undefined;
  directRevocationEndpointEnabled?: boolean | undefined;
  supportedRevocationAuthMethods?: Array<string> | undefined;
  introspectionEndpoint?: string | undefined;
  directIntrospectionEndpointEnabled?: boolean | undefined;
  supportedIntrospectionAuthMethods?: Array<string> | undefined;
  pushedAuthReqEndpoint?: string | undefined;
  pushedAuthReqDuration?: number | undefined;
  parRequired?: boolean | undefined;
  requestObjectRequired?: boolean | undefined;
  traditionalRequestObjectProcessingApplied?: boolean | undefined;
  mutualTlsValidatePkiCertChain?: boolean | undefined;
  trustedRootCertificates?: Array<string> | undefined;
  mtlsEndpointAliases?:
    | Array<ServiceCreateApiMtlsEndpointAliasResponse$Outbound>
    | undefined;
  accessTokenType?: string | undefined;
  tlsClientCertificateBoundAccessTokens?: boolean | undefined;
  accessTokenDuration?: number | undefined;
  singleAccessTokenPerSubject?: boolean | undefined;
  accessTokenSignAlg?: string | undefined;
  accessTokenSignatureKeyId?: string | undefined;
  refreshTokenDuration?: number | undefined;
  refreshTokenDurationKept?: boolean | undefined;
  refreshTokenDurationReset?: boolean | undefined;
  refreshTokenKept?: boolean | undefined;
  supportedScopes?:
    | Array<ServiceCreateApiSupportedScopeResponse$Outbound>
    | undefined;
  scopeRequired?: boolean | undefined;
  idTokenDuration?: number | undefined;
  allowableClockSkew?: number | undefined;
  supportedClaimTypes?: Array<string> | undefined;
  supportedClaimLocales?: Array<string> | undefined;
  supportedClaims?: Array<string> | undefined;
  claimShortcutRestrictive?: boolean | undefined;
  jwksUri?: string | undefined;
  directJwksEndpointEnabled?: boolean | undefined;
  jwks?: string | undefined;
  idTokenSignatureKeyId?: string | undefined;
  userInfoSignatureKeyId?: string | undefined;
  authorizationSignatureKeyId?: string | undefined;
  userInfoEndpoint?: string | undefined;
  directUserInfoEndpointEnabled?: boolean | undefined;
  dynamicRegistrationSupported?: boolean | undefined;
  registrationEndpoint?: string | undefined;
  registrationManagementEndpoint?: string | undefined;
  policyUri?: string | undefined;
  tosUri?: string | undefined;
  serviceDocumentation?: string | undefined;
  backchannelAuthenticationEndpoint?: string | undefined;
  supportedBackchannelTokenDeliveryModes?: Array<string> | undefined;
  backchannelAuthReqIdDuration?: number | undefined;
  backchannelPollingInterval?: number | undefined;
  backchannelUserCodeParameterSupported?: boolean | undefined;
  backchannelBindingMessageRequiredInFapi?: boolean | undefined;
  deviceAuthorizationEndpoint?: string | undefined;
  deviceVerificationUri?: string | undefined;
  deviceVerificationUriComplete?: string | undefined;
  deviceFlowCodeDuration?: number | undefined;
  deviceFlowPollingInterval?: number | undefined;
  userCodeCharset?: string | undefined;
  userCodeLength?: number | undefined;
  supportedTrustFrameworks?: Array<string> | undefined;
  supportedEvidence?: Array<string> | undefined;
  supportedIdentityDocuments?: Array<string> | undefined;
  supportedVerificationMethods?: Array<string> | undefined;
  supportedVerifiedClaims?: Array<string> | undefined;
  verifiedClaimsValidationSchemaSet?: string | undefined;
  attributes?: Array<ServiceCreateApiAttributeResponse$Outbound> | undefined;
  nbfOptional?: boolean | undefined;
  issSuppressed?: boolean | undefined;
  supportedCustomClientMetadata?: Array<string> | undefined;
  tokenExpirationLinked?: boolean | undefined;
  frontChannelRequestObjectEncryptionRequired?: boolean | undefined;
  requestObjectEncryptionAlgMatchRequired?: boolean | undefined;
  requestObjectEncryptionEncMatchRequired?: boolean | undefined;
  hsmEnabled?: boolean | undefined;
  hsks?: Array<ServiceCreateApiHskResponse$Outbound> | undefined;
  grantManagementEndpoint?: string | undefined;
  grantManagementActionRequired?: boolean | undefined;
  unauthorizedOnClientConfigSupported?: boolean | undefined;
  dcrScopeUsedAsRequestable?: boolean | undefined;
  endSessionEndpoint?: string | undefined;
  loopbackRedirectionUriVariable?: boolean | undefined;
  requestObjectAudienceChecked?: boolean | undefined;
  accessTokenForExternalAttachmentEmbedded?: boolean | undefined;
  authorityHints?: Array<string> | undefined;
  federationEnabled?: boolean | undefined;
  federationJwks?: string | undefined;
  federationSignatureKeyId?: string | undefined;
  federationConfigurationDuration?: number | undefined;
  federationRegistrationEndpoint?: string | undefined;
  organizationName?: string | undefined;
  predefinedTransformedClaims?: string | undefined;
  refreshTokenIdempotent?: boolean | undefined;
  signedJwksUri?: string | undefined;
  supportedAttachments?: Array<string> | undefined;
  supportedDigestAlgorithms?: Array<string> | undefined;
  supportedDocuments?: Array<string> | undefined;
  supportedDocumentsMethods?: Array<string> | undefined;
  supportedDocumentsValidationMethods?: Array<string> | undefined;
  supportedDocumentsVerificationMethods?: Array<string> | undefined;
  supportedElectronicRecords?: Array<string> | undefined;
  supportedClientRegistrationTypes?: Array<string> | undefined;
  tokenExchangeByIdentifiableClientsOnly?: boolean | undefined;
  tokenExchangeByConfidentialClientsOnly?: boolean | undefined;
  tokenExchangeByPermittedClientsOnly?: boolean | undefined;
  tokenExchangeEncryptedJwtRejected?: boolean | undefined;
  tokenExchangeUnsignedJwtRejected?: boolean | undefined;
  jwtGrantByIdentifiableClientsOnly?: boolean | undefined;
  jwtGrantEncryptedJwtRejected?: boolean | undefined;
  jwtGrantUnsignedJwtRejected?: boolean | undefined;
  dcrDuplicateSoftwareIdBlocked?: boolean | undefined;
  trustAnchors?:
    | Array<ServiceCreateApiTrustAnchorResponse$Outbound>
    | undefined;
  openidDroppedOnRefreshWithoutOfflineAccess?: boolean | undefined;
  supportedDocumentsCheckMethods?: Array<string> | undefined;
  rsResponseSigned?: boolean | undefined;
  cnonceDuration?: number | undefined;
  dpopNonceRequired?: boolean | undefined;
  verifiableCredentialsEnabled?: boolean | undefined;
  credentialJwksUri?: string | undefined;
  credentialOfferDuration?: number | undefined;
  dpopNonceDuration?: number | undefined;
  preAuthorizedGrantAnonymousAccessSupported?: boolean | undefined;
  credentialTransactionDuration?: number | undefined;
  introspectionSignatureKeyId?: string | undefined;
  resourceSignatureKeyId?: string | undefined;
  userPinLength?: number | undefined;
  supportedPromptValues?: Array<string> | undefined;
  idTokenReissuable?: boolean | undefined;
  credentialJwks?: string | undefined;
  fapiModes?: Array<string> | undefined;
  credentialDuration?: number | undefined;
  credentialIssuerMetadata?:
    | ServiceCreateApiCredentialIssuerMetadataResponse$Outbound
    | undefined;
  idTokenAudType?: string | undefined;
};

/** @internal */
export const ServiceCreateApiResponse$outboundSchema: z.ZodType<
  ServiceCreateApiResponse$Outbound,
  z.ZodTypeDef,
  ServiceCreateApiResponse
> = z.object({
  number: z.number().int().optional(),
  serviceName: z.string().optional(),
  issuer: z.string().optional(),
  description: z.string().optional(),
  apiKey: z.number().int().optional(),
  clientIdAliasEnabled: z.boolean().optional(),
  metadata: z.array(
    z.lazy(() => ServiceCreateApiMetadatumResponse$outboundSchema),
  ).optional(),
  createdAt: z.number().int().optional(),
  modifiedAt: z.number().int().optional(),
  authenticationCallbackEndpoint: z.string().optional(),
  authenticationCallbackApiKey: z.string().optional(),
  authenticationCallbackApiSecret: z.string().optional(),
  supportedAcrs: z.array(z.string()).optional(),
  supportedGrantTypes: z.array(
    ServiceCreateApiSupportedGrantTypeResponse$outboundSchema,
  ).optional(),
  supportedResponseTypes: z.array(
    ServiceCreateApiSupportedResponseTypeResponse$outboundSchema,
  ).optional(),
  supportedAuthorizationDetailsTypes: z.array(z.string()).optional(),
  supportedServiceProfiles: z.array(
    ServiceCreateApiSupportedServiceProfileResponse$outboundSchema,
  ).optional(),
  errorDescriptionOmitted: z.boolean().optional(),
  errorUriOmitted: z.boolean().optional(),
  authorizationEndpoint: z.string().optional(),
  directAuthorizationEndpointEnabled: z.boolean().optional(),
  supportedUiLocales: z.array(z.string()).optional(),
  supportedDisplays: z.array(
    ServiceCreateApiSupportedDisplayResponse$outboundSchema,
  ).optional(),
  pkceRequired: z.boolean().optional(),
  pkceS256Required: z.boolean().optional(),
  authorizationResponseDuration: z.number().int().optional(),
  tokenEndpoint: z.string().optional(),
  directTokenEndpointEnabled: z.boolean().optional(),
  supportedTokenAuthMethods: z.array(
    ServiceCreateApiSupportedTokenAuthMethodResponse$outboundSchema,
  ).optional(),
  missingClientIdAllowed: z.boolean().optional(),
  revocationEndpoint: z.string().optional(),
  directRevocationEndpointEnabled: z.boolean().optional(),
  supportedRevocationAuthMethods: z.array(
    ServiceCreateApiSupportedRevocationAuthMethodResponse$outboundSchema,
  ).optional(),
  introspectionEndpoint: z.string().optional(),
  directIntrospectionEndpointEnabled: z.boolean().optional(),
  supportedIntrospectionAuthMethods: z.array(
    ServiceCreateApiSupportedIntrospectionAuthMethodResponse$outboundSchema,
  ).optional(),
  pushedAuthReqEndpoint: z.string().optional(),
  pushedAuthReqDuration: z.number().int().optional(),
  parRequired: z.boolean().optional(),
  requestObjectRequired: z.boolean().optional(),
  traditionalRequestObjectProcessingApplied: z.boolean().optional(),
  mutualTlsValidatePkiCertChain: z.boolean().optional(),
  trustedRootCertificates: z.array(z.string()).optional(),
  mtlsEndpointAliases: z.array(
    z.lazy(() => ServiceCreateApiMtlsEndpointAliasResponse$outboundSchema),
  ).optional(),
  accessTokenType: z.string().optional(),
  tlsClientCertificateBoundAccessTokens: z.boolean().optional(),
  accessTokenDuration: z.number().int().optional(),
  singleAccessTokenPerSubject: z.boolean().optional(),
  accessTokenSignAlg: ServiceCreateApiAccessTokenSignAlgResponse$outboundSchema
    .optional(),
  accessTokenSignatureKeyId: z.string().optional(),
  refreshTokenDuration: z.number().int().optional(),
  refreshTokenDurationKept: z.boolean().optional(),
  refreshTokenDurationReset: z.boolean().optional(),
  refreshTokenKept: z.boolean().optional(),
  supportedScopes: z.array(
    z.lazy(() => ServiceCreateApiSupportedScopeResponse$outboundSchema),
  ).optional(),
  scopeRequired: z.boolean().optional(),
  idTokenDuration: z.number().int().optional(),
  allowableClockSkew: z.number().int().optional(),
  supportedClaimTypes: z.array(
    ServiceCreateApiSupportedClaimTypeResponse$outboundSchema,
  ).optional(),
  supportedClaimLocales: z.array(z.string()).optional(),
  supportedClaims: z.array(z.string()).optional(),
  claimShortcutRestrictive: z.boolean().optional(),
  jwksUri: z.string().optional(),
  directJwksEndpointEnabled: z.boolean().optional(),
  jwks: z.string().optional(),
  idTokenSignatureKeyId: z.string().optional(),
  userInfoSignatureKeyId: z.string().optional(),
  authorizationSignatureKeyId: z.string().optional(),
  userInfoEndpoint: z.string().optional(),
  directUserInfoEndpointEnabled: z.boolean().optional(),
  dynamicRegistrationSupported: z.boolean().optional(),
  registrationEndpoint: z.string().optional(),
  registrationManagementEndpoint: z.string().optional(),
  policyUri: z.string().optional(),
  tosUri: z.string().optional(),
  serviceDocumentation: z.string().optional(),
  backchannelAuthenticationEndpoint: z.string().optional(),
  supportedBackchannelTokenDeliveryModes: z.array(
    ServiceCreateApiSupportedBackchannelTokenDeliveryModeResponse$outboundSchema,
  ).optional(),
  backchannelAuthReqIdDuration: z.number().int().optional(),
  backchannelPollingInterval: z.number().int().optional(),
  backchannelUserCodeParameterSupported: z.boolean().optional(),
  backchannelBindingMessageRequiredInFapi: z.boolean().optional(),
  deviceAuthorizationEndpoint: z.string().optional(),
  deviceVerificationUri: z.string().optional(),
  deviceVerificationUriComplete: z.string().optional(),
  deviceFlowCodeDuration: z.number().int().optional(),
  deviceFlowPollingInterval: z.number().int().optional(),
  userCodeCharset: ServiceCreateApiUserCodeCharsetResponse$outboundSchema
    .optional(),
  userCodeLength: z.number().int().optional(),
  supportedTrustFrameworks: z.array(z.string()).optional(),
  supportedEvidence: z.array(z.string()).optional(),
  supportedIdentityDocuments: z.array(z.string()).optional(),
  supportedVerificationMethods: z.array(z.string()).optional(),
  supportedVerifiedClaims: z.array(z.string()).optional(),
  verifiedClaimsValidationSchemaSet:
    ServiceCreateApiVerifiedClaimsValidationSchemaSetResponse$outboundSchema
      .optional(),
  attributes: z.array(
    z.lazy(() => ServiceCreateApiAttributeResponse$outboundSchema),
  ).optional(),
  nbfOptional: z.boolean().optional(),
  issSuppressed: z.boolean().optional(),
  supportedCustomClientMetadata: z.array(z.string()).optional(),
  tokenExpirationLinked: z.boolean().optional(),
  frontChannelRequestObjectEncryptionRequired: z.boolean().optional(),
  requestObjectEncryptionAlgMatchRequired: z.boolean().optional(),
  requestObjectEncryptionEncMatchRequired: z.boolean().optional(),
  hsmEnabled: z.boolean().optional(),
  hsks: z.array(z.lazy(() => ServiceCreateApiHskResponse$outboundSchema))
    .optional(),
  grantManagementEndpoint: z.string().optional(),
  grantManagementActionRequired: z.boolean().optional(),
  unauthorizedOnClientConfigSupported: z.boolean().optional(),
  dcrScopeUsedAsRequestable: z.boolean().optional(),
  endSessionEndpoint: z.string().optional(),
  loopbackRedirectionUriVariable: z.boolean().optional(),
  requestObjectAudienceChecked: z.boolean().optional(),
  accessTokenForExternalAttachmentEmbedded: z.boolean().optional(),
  authorityHints: z.array(z.string()).optional(),
  federationEnabled: z.boolean().optional(),
  federationJwks: z.string().optional(),
  federationSignatureKeyId: z.string().optional(),
  federationConfigurationDuration: z.number().int().optional(),
  federationRegistrationEndpoint: z.string().optional(),
  organizationName: z.string().optional(),
  predefinedTransformedClaims: z.string().optional(),
  refreshTokenIdempotent: z.boolean().optional(),
  signedJwksUri: z.string().optional(),
  supportedAttachments: z.array(
    ServiceCreateApiSupportedAttachmentResponse$outboundSchema,
  ).optional(),
  supportedDigestAlgorithms: z.array(z.string()).optional(),
  supportedDocuments: z.array(z.string()).optional(),
  supportedDocumentsMethods: z.array(z.string()).optional(),
  supportedDocumentsValidationMethods: z.array(z.string()).optional(),
  supportedDocumentsVerificationMethods: z.array(z.string()).optional(),
  supportedElectronicRecords: z.array(z.string()).optional(),
  supportedClientRegistrationTypes: z.array(
    ServiceCreateApiSupportedClientRegistrationTypeResponse$outboundSchema,
  ).optional(),
  tokenExchangeByIdentifiableClientsOnly: z.boolean().optional(),
  tokenExchangeByConfidentialClientsOnly: z.boolean().optional(),
  tokenExchangeByPermittedClientsOnly: z.boolean().optional(),
  tokenExchangeEncryptedJwtRejected: z.boolean().optional(),
  tokenExchangeUnsignedJwtRejected: z.boolean().optional(),
  jwtGrantByIdentifiableClientsOnly: z.boolean().optional(),
  jwtGrantEncryptedJwtRejected: z.boolean().optional(),
  jwtGrantUnsignedJwtRejected: z.boolean().optional(),
  dcrDuplicateSoftwareIdBlocked: z.boolean().optional(),
  trustAnchors: z.array(
    z.lazy(() => ServiceCreateApiTrustAnchorResponse$outboundSchema),
  ).optional(),
  openidDroppedOnRefreshWithoutOfflineAccess: z.boolean().optional(),
  supportedDocumentsCheckMethods: z.array(z.string()).optional(),
  rsResponseSigned: z.boolean().optional(),
  cnonceDuration: z.number().int().optional(),
  dpopNonceRequired: z.boolean().optional(),
  verifiableCredentialsEnabled: z.boolean().optional(),
  credentialJwksUri: z.string().optional(),
  credentialOfferDuration: z.number().int().optional(),
  dpopNonceDuration: z.number().int().optional(),
  preAuthorizedGrantAnonymousAccessSupported: z.boolean().optional(),
  credentialTransactionDuration: z.number().int().optional(),
  introspectionSignatureKeyId: z.string().optional(),
  resourceSignatureKeyId: z.string().optional(),
  userPinLength: z.number().int().optional(),
  supportedPromptValues: z.array(
    ServiceCreateApiSupportedPromptValueResponse$outboundSchema,
  ).optional(),
  idTokenReissuable: z.boolean().optional(),
  credentialJwks: z.string().optional(),
  fapiModes: z.array(ServiceCreateApiFapiModeResponse$outboundSchema)
    .optional(),
  credentialDuration: z.number().int().optional(),
  credentialIssuerMetadata: z.lazy(() =>
    ServiceCreateApiCredentialIssuerMetadataResponse$outboundSchema
  ).optional(),
  idTokenAudType: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceCreateApiResponse$ {
  /** @deprecated use `ServiceCreateApiResponse$inboundSchema` instead. */
  export const inboundSchema = ServiceCreateApiResponse$inboundSchema;
  /** @deprecated use `ServiceCreateApiResponse$outboundSchema` instead. */
  export const outboundSchema = ServiceCreateApiResponse$outboundSchema;
  /** @deprecated use `ServiceCreateApiResponse$Outbound` instead. */
  export type Outbound = ServiceCreateApiResponse$Outbound;
}

export function serviceCreateApiResponseToJSON(
  serviceCreateApiResponse: ServiceCreateApiResponse,
): string {
  return JSON.stringify(
    ServiceCreateApiResponse$outboundSchema.parse(serviceCreateApiResponse),
  );
}

export function serviceCreateApiResponseFromJSON(
  jsonString: string,
): SafeParseResult<ServiceCreateApiResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ServiceCreateApiResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceCreateApiResponse' from JSON`,
  );
}
