/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const AuthTokenApiServerList = [
  /**
   * ðŸ‡ºðŸ‡¸ US Cluster
   */
  "https://us.authlete.com",
  /**
   * ðŸ‡¯ðŸ‡µ Japan Cluster
   */
  "https://jp.authlete.com",
  /**
   * ðŸ‡ªðŸ‡º Europe Cluster
   */
  "https://eu.authlete.com",
  /**
   * ðŸ‡§ðŸ‡· Brazil Cluster
   */
  "https://br.authlete.com",
] as const;

export type AuthTokenApiRequestBody = {
  /**
   * OAuth 2.0 token request parameters which are the request parameters that the OAuth 2.0 token endpoint of the authorization server
   *
   * @remarks
   * implementation received from the client application.
   *
   * The value of parameters is the entire entity body (which is formatted in `application/x-www-form-urlencoded`) of the request from
   * the client application.
   */
  parameters: string;
  /**
   * The client ID extracted from `Authorization` header of the token request from the client application.
   *
   * @remarks
   *
   * If the token endpoint of the authorization server implementation supports basic authentication as
   * a means of client authentication, and the request from the client application contained its client ID
   * in `Authorization` header, the value should be extracted and set to this parameter.
   */
  clientId?: string | undefined;
  /**
   * The client secret extracted from `Authorization` header of the token request from the client application.
   *
   * @remarks
   *
   * If the token endpoint of the authorization server implementation supports basic authentication as a means of
   * client authentication, and the request from the client application contained its client secret in `Authorization` header,
   * the value should be extracted and set to this parameter.
   */
  clientSecret?: string | undefined;
  /**
   * The client certificate from the MTLS of the token request from the client application.
   */
  clientCertificate?: string | undefined;
  /**
   * The certificate path presented by the client during client authentication. These certificates are strings in PEM format.
   *
   * @remarks
   */
  clientCertificatePath?: string | undefined;
  /**
   * Extra properties to associate with an access token. See [Extra Properties](https://www.authlete.com/developers/definitive_guide/extra_properties/)
   *
   * @remarks
   * for details.
   */
  properties?: string | undefined;
  /**
   * `DPoP` header presented by the client during the request to the token endpoint.
   *
   * @remarks
   *
   * The header contains a signed JWT which includes the public key that is paired with the private key used to sign the JWT.
   * See [OAuth 2.0 Demonstration of Proof-of-Possession at the Application Layer (DPoP)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop)
   * for details.
   */
  dpop?: string | undefined;
  /**
   * HTTP method of the token request. This field is used to validate the `DPoP` header.
   *
   * @remarks
   *
   * In normal cases, the value is `POST`. When this parameter is omitted, `POST` is used as the default value.
   * See [OAuth 2.0 Demonstration of Proof-of-Possession at the Application Layer (DPoP)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop)
   * for details.
   */
  htm?: string | undefined;
  /**
   * URL of the token endpoint. This field is used to validate the `DPoP` header.
   *
   * @remarks
   *
   * If this parameter is omitted, the `tokenEndpoint` property of the Service is used as the default value.
   * See [OAuth 2.0 Demonstration of Proof-of-Possession at the Application Layer (DPoP)](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop)
   * for details.
   */
  htu?: string | undefined;
  /**
   * The representation of an access token that may be issued as a result of the Authlete API call.
   *
   * @remarks
   */
  accessToken?: string | undefined;
  /**
   * Additional claims that are added to the payload part of the JWT access token.
   *
   * @remarks
   */
  jwtAtClaims?: string | undefined;
};

export type AuthTokenApiRequest = {
  /**
   * A service ID.
   */
  serviceId: string;
  requestBody: AuthTokenApiRequestBody;
};

/**
 * The next action that the authorization server implementation should take.
 */
export const AuthTokenApiAction = {
  InternalServerError: "INTERNAL_SERVER_ERROR",
  InvalidClient: "INVALID_CLIENT",
  BadRequest: "BAD_REQUEST",
  Password: "PASSWORD",
  Ok: "OK",
  TokenExchange: "TOKEN_EXCHANGE",
  JwtBearer: "JWT_BEARER",
} as const;
/**
 * The next action that the authorization server implementation should take.
 */
export type AuthTokenApiAction = ClosedEnum<typeof AuthTokenApiAction>;

export type AuthTokenApiProperty = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
  /**
   * The flag to indicate whether this property hidden from or visible to client applications.
   *
   * @remarks
   * If `true`, this property is hidden from client applications. Otherwise, this property is visible to client applications.
   */
  hidden?: boolean | undefined;
};

export type AuthTokenApiElement = {
  /**
   * The type of this element.
   *
   * @remarks
   *
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"The type of authorization data as a string.
   * This field MAY define which other elements are allowed in the request. This element is REQUIRED."_
   *
   * This property is always NOT `null`.
   */
  type: string;
  /**
   * The resources and/or resource servers. This property may be `null`.
   *
   * @remarks
   *
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"An array of strings representing the location of
   * the resource or resource server. This is typically composed of URIs."_
   *
   * This property may be `null`.
   */
  locations?: Array<string> | undefined;
  /**
   * The actions.
   *
   * @remarks
   *
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"An array of strings representing the kinds of actions
   * to be taken at the resource. The values of the strings are determined by the API being protected."_
   *
   * This property may be `null`.
   */
  actions?: Array<string> | undefined;
  /**
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"An array of strings representing the kinds of data being requested
   *
   * @remarks
   * from the resource."_
   *
   * This property may be `null`.
   */
  dataTypes?: Array<string> | undefined;
  /**
   * The identifier of a specific resource.
   *
   * @remarks
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"A string identifier indicating a specific resource available at the API."_
   *
   * This property may be `null`.
   */
  identifier?: string | undefined;
  /**
   * The types or levels of privilege.
   *
   * @remarks
   * From "OAuth 2.0 Rich Authorization Requests": _"An array of strings representing the types or
   * levels of privilege being requested at the resource."_
   *
   * This property may be `null`.
   */
  privileges?: Array<string> | undefined;
  /**
   * The RAR request in the JSON format excluding the pre-defined attributes such as `type` and `locations`.
   *
   * @remarks
   * The content and semantics are specific to the deployment and the use case implemented.
   */
  otherFields?: string | undefined;
};

/**
 * The authorization details. This represents the value of the `authorization_details`
 *
 * @remarks
 * request parameter in the preceding device authorization request which is defined in
 * "OAuth 2.0 Rich Authorization Requests".
 */
export type AuthTokenApiAuthorizationDetails = {
  /**
   * Elements of this authorization details.
   *
   * @remarks
   */
  elements?: Array<AuthTokenApiElement> | undefined;
};

export type AuthTokenApiServiceAttribute = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

export type AuthTokenApiClientAttribute = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
};

/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export const AuthTokenApiRequestedTokenType = {
  UrnIetfParamsOauthTokenTypeJwt: "urn:ietf:params:oauth:token-type:jwt",
  UrnIetfParamsOauthTokenTypeAccessToken:
    "urn:ietf:params:oauth:token-type:access_token",
  UrnIetfParamsOauthTokenTypeRefreshToken:
    "urn:ietf:params:oauth:token-type:refresh_token",
  UrnIetfParamsOauthTokenTypeIdToken:
    "urn:ietf:params:oauth:token-type:id_token",
  UrnIetfParamsOauthTokenTypeSaml1: "urn:ietf:params:oauth:token-type:saml1",
  UrnIetfParamsOauthTokenTypeSaml2: "urn:ietf:params:oauth:token-type:saml2",
  DeviceCode: "DEVICE_CODE",
  TokenExchange: "TOKEN_EXCHANGE",
  JwtBearer: "JWT_BEARER",
} as const;
/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export type AuthTokenApiRequestedTokenType = ClosedEnum<
  typeof AuthTokenApiRequestedTokenType
>;

/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export const AuthTokenApiSubjectTokenType = {
  UrnIetfParamsOauthTokenTypeJwt: "urn:ietf:params:oauth:token-type:jwt",
  UrnIetfParamsOauthTokenTypeAccessToken:
    "urn:ietf:params:oauth:token-type:access_token",
  UrnIetfParamsOauthTokenTypeRefreshToken:
    "urn:ietf:params:oauth:token-type:refresh_token",
  UrnIetfParamsOauthTokenTypeIdToken:
    "urn:ietf:params:oauth:token-type:id_token",
  UrnIetfParamsOauthTokenTypeSaml1: "urn:ietf:params:oauth:token-type:saml1",
  UrnIetfParamsOauthTokenTypeSaml2: "urn:ietf:params:oauth:token-type:saml2",
  DeviceCode: "DEVICE_CODE",
  TokenExchange: "TOKEN_EXCHANGE",
  JwtBearer: "JWT_BEARER",
} as const;
/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export type AuthTokenApiSubjectTokenType = ClosedEnum<
  typeof AuthTokenApiSubjectTokenType
>;

export type AuthTokenApiSubjectTokenInfoProperty = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
  /**
   * The flag to indicate whether this property hidden from or visible to client applications.
   *
   * @remarks
   * If `true`, this property is hidden from client applications. Otherwise, this property is visible to client applications.
   */
  hidden?: boolean | undefined;
};

export type AuthTokenApiSubjectTokenInfoAuthorizationDetails = {
  /**
   * The type of this element.
   *
   * @remarks
   *
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"The type of authorization data as a string.
   * This field MAY define which other elements are allowed in the request. This element is REQUIRED."_
   *
   * This property is always NOT `null`.
   */
  type: string;
  /**
   * The resources and/or resource servers. This property may be `null`.
   *
   * @remarks
   *
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"An array of strings representing the location of
   * the resource or resource server. This is typically composed of URIs."_
   *
   * This property may be `null`.
   */
  locations?: Array<string> | undefined;
  /**
   * The actions.
   *
   * @remarks
   *
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"An array of strings representing the kinds of actions
   * to be taken at the resource. The values of the strings are determined by the API being protected."_
   *
   * This property may be `null`.
   */
  actions?: Array<string> | undefined;
  /**
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"An array of strings representing the kinds of data being requested
   *
   * @remarks
   * from the resource."_
   *
   * This property may be `null`.
   */
  dataTypes?: Array<string> | undefined;
  /**
   * The identifier of a specific resource.
   *
   * @remarks
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"A string identifier indicating a specific resource available at the API."_
   *
   * This property may be `null`.
   */
  identifier?: string | undefined;
  /**
   * The types or levels of privilege.
   *
   * @remarks
   * From "OAuth 2.0 Rich Authorization Requests": _"An array of strings representing the types or
   * levels of privilege being requested at the resource."_
   *
   * This property may be `null`.
   */
  privileges?: Array<string> | undefined;
  /**
   * The RAR request in the JSON format excluding the pre-defined attributes such as `type` and `locations`.
   *
   * @remarks
   * The content and semantics are specific to the deployment and the use case implemented.
   */
  otherFields?: string | undefined;
};

export type AuthTokenApiSubjectTokenInfo = {
  /**
   * The client id.
   */
  clientId?: number | undefined;
  /**
   * The alias of the client.
   */
  clientIdAlias?: string | undefined;
  /**
   * Flag specifying if the alias was used to identify the client
   */
  clientIdAliasUsed?: boolean | undefined;
  /**
   * the resource owner unique id
   */
  subject?: string | undefined;
  /**
   * The scopes granted on the token
   */
  scopes?: Array<string> | undefined;
  /**
   * time which the token expires.
   */
  expiresAt?: number | undefined;
  /**
   * Extra properties associated with the token
   */
  properties?: Array<AuthTokenApiSubjectTokenInfoProperty> | undefined;
  /**
   * The array of the resources of the token.
   */
  resources?: Array<string> | undefined;
  authorizationDetails?:
    | AuthTokenApiSubjectTokenInfoAuthorizationDetails
    | undefined;
  /**
   * The entity ID of the client.
   *
   * @remarks
   */
  clientEntityId?: string | undefined;
  /**
   * Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
   *
   * @remarks
   */
  clientEntityIdUsed?: boolean | undefined;
};

/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export const AuthTokenApiActorTokenType = {
  UrnIetfParamsOauthTokenTypeJwt: "urn:ietf:params:oauth:token-type:jwt",
  UrnIetfParamsOauthTokenTypeAccessToken:
    "urn:ietf:params:oauth:token-type:access_token",
  UrnIetfParamsOauthTokenTypeRefreshToken:
    "urn:ietf:params:oauth:token-type:refresh_token",
  UrnIetfParamsOauthTokenTypeIdToken:
    "urn:ietf:params:oauth:token-type:id_token",
  UrnIetfParamsOauthTokenTypeSaml1: "urn:ietf:params:oauth:token-type:saml1",
  UrnIetfParamsOauthTokenTypeSaml2: "urn:ietf:params:oauth:token-type:saml2",
  DeviceCode: "DEVICE_CODE",
  TokenExchange: "TOKEN_EXCHANGE",
  JwtBearer: "JWT_BEARER",
} as const;
/**
 * The grant type of the access token when the access token was created.
 *
 * @remarks
 */
export type AuthTokenApiActorTokenType = ClosedEnum<
  typeof AuthTokenApiActorTokenType
>;

export type AuthTokenApiActorTokenInfoProperty = {
  /**
   * The key part.
   */
  key?: string | undefined;
  /**
   * The value part.
   */
  value?: string | undefined;
  /**
   * The flag to indicate whether this property hidden from or visible to client applications.
   *
   * @remarks
   * If `true`, this property is hidden from client applications. Otherwise, this property is visible to client applications.
   */
  hidden?: boolean | undefined;
};

export type AuthTokenApiActorTokenInfoAuthorizationDetails = {
  /**
   * The type of this element.
   *
   * @remarks
   *
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"The type of authorization data as a string.
   * This field MAY define which other elements are allowed in the request. This element is REQUIRED."_
   *
   * This property is always NOT `null`.
   */
  type: string;
  /**
   * The resources and/or resource servers. This property may be `null`.
   *
   * @remarks
   *
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"An array of strings representing the location of
   * the resource or resource server. This is typically composed of URIs."_
   *
   * This property may be `null`.
   */
  locations?: Array<string> | undefined;
  /**
   * The actions.
   *
   * @remarks
   *
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"An array of strings representing the kinds of actions
   * to be taken at the resource. The values of the strings are determined by the API being protected."_
   *
   * This property may be `null`.
   */
  actions?: Array<string> | undefined;
  /**
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"An array of strings representing the kinds of data being requested
   *
   * @remarks
   * from the resource."_
   *
   * This property may be `null`.
   */
  dataTypes?: Array<string> | undefined;
  /**
   * The identifier of a specific resource.
   *
   * @remarks
   * From _"OAuth 2.0 Rich Authorization Requests"_: _"A string identifier indicating a specific resource available at the API."_
   *
   * This property may be `null`.
   */
  identifier?: string | undefined;
  /**
   * The types or levels of privilege.
   *
   * @remarks
   * From "OAuth 2.0 Rich Authorization Requests": _"An array of strings representing the types or
   * levels of privilege being requested at the resource."_
   *
   * This property may be `null`.
   */
  privileges?: Array<string> | undefined;
  /**
   * The RAR request in the JSON format excluding the pre-defined attributes such as `type` and `locations`.
   *
   * @remarks
   * The content and semantics are specific to the deployment and the use case implemented.
   */
  otherFields?: string | undefined;
};

export type AuthTokenApiActorTokenInfo = {
  /**
   * The client id.
   */
  clientId?: number | undefined;
  /**
   * The alias of the client.
   */
  clientIdAlias?: string | undefined;
  /**
   * Flag specifying if the alias was used to identify the client
   */
  clientIdAliasUsed?: boolean | undefined;
  /**
   * the resource owner unique id
   */
  subject?: string | undefined;
  /**
   * The scopes granted on the token
   */
  scopes?: Array<string> | undefined;
  /**
   * time which the token expires.
   */
  expiresAt?: number | undefined;
  /**
   * Extra properties associated with the token
   */
  properties?: Array<AuthTokenApiActorTokenInfoProperty> | undefined;
  /**
   * The array of the resources of the token.
   */
  resources?: Array<string> | undefined;
  authorizationDetails?:
    | AuthTokenApiActorTokenInfoAuthorizationDetails
    | undefined;
  /**
   * The entity ID of the client.
   *
   * @remarks
   */
  clientEntityId?: string | undefined;
  /**
   * Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
   *
   * @remarks
   */
  clientEntityIdUsed?: boolean | undefined;
};

export type AuthTokenApiResponse = {
  /**
   * The code which represents the result of the API call.
   */
  resultCode?: string | undefined;
  /**
   * A short message which explains the result of the API call.
   */
  resultMessage?: string | undefined;
  /**
   * The next action that the authorization server implementation should take.
   */
  action?: AuthTokenApiAction | undefined;
  /**
   * The content that the authorization server implementation is to return to the client application.
   *
   * @remarks
   * Its format varies depending on the value of `action` parameter.
   */
  responseContent?: string | undefined;
  /**
   * The value of `username` request parameter in the token request.
   *
   * @remarks
   * The client application must specify username when it uses [Resource Owner Password Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.3).
   * In other words, when the value of `grant_type` request parameter is `password`, `username` request parameter must come along.
   *
   * This parameter has a value only if the value of `grant_type` request parameter is `password` and the token request is valid.
   */
  username?: string | undefined;
  /**
   * The value of `password` request parameter in the token request.
   *
   * @remarks
   * The client application must specify password when it uses [Resource Owner Password Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.3).
   * In other words, when the value of `grant_type` request parameter is `password`, `password` request parameter must come along.
   *
   * This parameter has a value only if the value of `grant_type` request parameter is `password` and the token request is valid.
   */
  password?: string | undefined;
  /**
   * The ticket which is necessary to call Authlete's `/auth/token/fail` API or `/auth/token/issue` API.
   *
   * @remarks
   *
   * This parameter has a value only if the value of `grant_type` request parameter is `password` and the token request is valid.
   */
  ticket?: string | undefined;
  /**
   * The newly issued access token.
   */
  accessToken?: string | undefined;
  /**
   * The datetime at which the newly issued access token will expire.
   *
   * @remarks
   * The value is represented in milliseconds since the Unix epoch (1970-01-01).
   */
  accessTokenExpiresAt?: number | undefined;
  /**
   * The duration of the newly issued access token in seconds.
   */
  accessTokenDuration?: number | undefined;
  /**
   * The newly issued refresh token.
   */
  refreshToken?: string | undefined;
  /**
   * The datetime at which the newly issued refresh token will expire.
   *
   * @remarks
   * The value is represented in milliseconds since the Unix epoch (1970-01-01).
   */
  refreshTokenExpiresAt?: number | undefined;
  /**
   * The duration of the newly issued refresh token in seconds.
   */
  refreshTokenDuration?: number | undefined;
  /**
   * The newly issued ID token. Note that an ID token is issued from a token endpoint only when the `response_type` request parameter
   *
   * @remarks
   * of the authorization request to an authorization endpoint has contained `code` and the `scope` request parameter has contained `openid`.
   */
  idToken?: string | undefined;
  /**
   * The grant type of the token request.
   */
  grantType?: string | undefined;
  /**
   * The client ID.
   */
  clientId?: number | undefined;
  /**
   * The client ID alias when the token request was made. If the client did not have an alias, this parameter is `null`.
   *
   * @remarks
   * Also, if the token request was invalid and it failed to identify a client, this parameter is `null`.
   */
  clientIdAlias?: string | undefined;
  /**
   * The flag which indicates whether the client ID alias was used when the token request was made.
   *
   * @remarks
   * `true` if the client ID alias was used when the token request was made.
   */
  clientIdAliasUsed?: boolean | undefined;
  /**
   * The subject (= resource owner's ID) of the access token.
   *
   * @remarks
   * Even if an access token has been issued by the call of `/api/auth/token` API, this parameter is `null` if the flow of the token request was
   * [Client Credentials Flow](https://datatracker.ietf.org/doc/html/rfc6749#section-4.4) (`grant_type=client_credentials`) because it means the access token
   * is not associated with any specific end-user.
   */
  subject?: string | undefined;
  /**
   * The scopes covered by the access token.
   */
  scopes?: Array<string> | undefined;
  /**
   * The extra properties associated with the access token.
   *
   * @remarks
   * This parameter is `null` when no extra property is associated with the issued access token.
   */
  properties?: Array<AuthTokenApiProperty> | undefined;
  /**
   * The newly issued access token in JWT format. If the authorization server is configured
   *
   * @remarks
   * to issue JWT-based access tokens (= if the service's `accessTokenSignAlg` value is a
   * non-null value), a JWT-based access token is issued along with the original random-string
   * one.
   */
  jwtAccessToken?: string | undefined;
  /**
   * The resources specified by the `resource` request parameters in the token request.
   *
   * @remarks
   * See "Resource Indicators for OAuth 2.0" for details.
   */
  resources?: Array<string> | undefined;
  /**
   * The target resources of the access token being issued. See "Resource Indicators for OAuth 2.0" for details.
   *
   * @remarks
   */
  accessTokenResources?: Array<string> | undefined;
  /**
   * The authorization details. This represents the value of the `authorization_details`
   *
   * @remarks
   * request parameter in the preceding device authorization request which is defined in
   * "OAuth 2.0 Rich Authorization Requests".
   */
  authorizationDetails?: AuthTokenApiAuthorizationDetails | undefined;
  /**
   * The attributes of this service that the client application belongs to.
   *
   * @remarks
   */
  serviceAttributes?: Array<AuthTokenApiServiceAttribute> | undefined;
  /**
   * The attributes of the client.
   *
   * @remarks
   */
  clientAttributes?: Array<AuthTokenApiClientAttribute> | undefined;
  /**
   * The client authentication method that was performed at the token endpoint.
   *
   * @remarks
   */
  clientAuthMethod?: string | undefined;
  /**
   * the value of the `grant_id` request parameter of the device authorization request.
   *
   * @remarks
   *
   * The `grant_id` request parameter is defined in
   * [Grant Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html)
   * , which is supported by Authlete 2.3 and newer versions.
   */
  grantId?: string | undefined;
  /**
   * The audiences on the token exchange request
   *
   * @remarks
   */
  audiences?: Array<string> | undefined;
  /**
   * The grant type of the access token when the access token was created.
   *
   * @remarks
   */
  requestedTokenType?: AuthTokenApiRequestedTokenType | undefined;
  subjectToken?: string | undefined;
  /**
   * The grant type of the access token when the access token was created.
   *
   * @remarks
   */
  subjectTokenType?: AuthTokenApiSubjectTokenType | undefined;
  subjectTokenInfo?: AuthTokenApiSubjectTokenInfo | undefined;
  actorToken?: string | undefined;
  /**
   * The grant type of the access token when the access token was created.
   *
   * @remarks
   */
  actorTokenType?: AuthTokenApiActorTokenType | undefined;
  actorTokenInfo?: AuthTokenApiActorTokenInfo | undefined;
  /**
   * For RFC 7523 JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants
   *
   * @remarks
   */
  assertion?: string | undefined;
  /**
   * Indicate whether the previous refresh token that had been kept in the database for a short time was used
   *
   * @remarks
   */
  previousRefreshTokenUsed?: boolean | undefined;
  /**
   * The entity ID of the client.
   *
   * @remarks
   */
  clientEntityId?: string | undefined;
  /**
   * Flag which indicates whether the entity ID of the client was used when the request for the access token was made.
   *
   * @remarks
   */
  clientEntityIdUsed?: boolean | undefined;
  /**
   * Duration of the `c_nonce` in seconds.
   *
   * @remarks
   */
  cnonceDuration?: number | undefined;
  /**
   * Get the expected nonce value for DPoP proof JWT, which should be used
   *
   * @remarks
   * as the value of the `DPoP-Nonce` HTTP header.
   */
  dpopNonce?: string | undefined;
  /**
   * Get the `c_nonce`.
   *
   * @remarks
   */
  cnonce?: string | undefined;
  /**
   * Get the time at which the `c_nonce` expires in milliseconds since
   *
   * @remarks
   * the Unix epoch (1970-01-01).
   */
  cnonceExpiresAt?: number | undefined;
  /**
   * Get the names of the claims that the authorization request (which resulted
   *
   * @remarks
   * in generation of the access token) requested to be embedded in ID tokens.
   */
  requestedIdTokenClaims?: Array<string> | undefined;
  /**
   * Scopes associated with the refresh token.
   *
   * @remarks
   */
  refreshTokenScopes?: Array<string> | undefined;
};

/** @internal */
export const AuthTokenApiRequestBody$inboundSchema: z.ZodType<
  AuthTokenApiRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.string(),
  clientId: z.string().optional(),
  clientSecret: z.string().optional(),
  clientCertificate: z.string().optional(),
  clientCertificatePath: z.string().optional(),
  properties: z.string().optional(),
  dpop: z.string().optional(),
  htm: z.string().optional(),
  htu: z.string().optional(),
  accessToken: z.string().optional(),
  jwtAtClaims: z.string().optional(),
});

/** @internal */
export type AuthTokenApiRequestBody$Outbound = {
  parameters: string;
  clientId?: string | undefined;
  clientSecret?: string | undefined;
  clientCertificate?: string | undefined;
  clientCertificatePath?: string | undefined;
  properties?: string | undefined;
  dpop?: string | undefined;
  htm?: string | undefined;
  htu?: string | undefined;
  accessToken?: string | undefined;
  jwtAtClaims?: string | undefined;
};

/** @internal */
export const AuthTokenApiRequestBody$outboundSchema: z.ZodType<
  AuthTokenApiRequestBody$Outbound,
  z.ZodTypeDef,
  AuthTokenApiRequestBody
> = z.object({
  parameters: z.string(),
  clientId: z.string().optional(),
  clientSecret: z.string().optional(),
  clientCertificate: z.string().optional(),
  clientCertificatePath: z.string().optional(),
  properties: z.string().optional(),
  dpop: z.string().optional(),
  htm: z.string().optional(),
  htu: z.string().optional(),
  accessToken: z.string().optional(),
  jwtAtClaims: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiRequestBody$ {
  /** @deprecated use `AuthTokenApiRequestBody$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiRequestBody$inboundSchema;
  /** @deprecated use `AuthTokenApiRequestBody$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiRequestBody$outboundSchema;
  /** @deprecated use `AuthTokenApiRequestBody$Outbound` instead. */
  export type Outbound = AuthTokenApiRequestBody$Outbound;
}

export function authTokenApiRequestBodyToJSON(
  authTokenApiRequestBody: AuthTokenApiRequestBody,
): string {
  return JSON.stringify(
    AuthTokenApiRequestBody$outboundSchema.parse(authTokenApiRequestBody),
  );
}

export function authTokenApiRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenApiRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiRequestBody' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiRequest$inboundSchema: z.ZodType<
  AuthTokenApiRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  serviceId: z.string(),
  RequestBody: z.lazy(() => AuthTokenApiRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type AuthTokenApiRequest$Outbound = {
  serviceId: string;
  RequestBody: AuthTokenApiRequestBody$Outbound;
};

/** @internal */
export const AuthTokenApiRequest$outboundSchema: z.ZodType<
  AuthTokenApiRequest$Outbound,
  z.ZodTypeDef,
  AuthTokenApiRequest
> = z.object({
  serviceId: z.string(),
  requestBody: z.lazy(() => AuthTokenApiRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiRequest$ {
  /** @deprecated use `AuthTokenApiRequest$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiRequest$inboundSchema;
  /** @deprecated use `AuthTokenApiRequest$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiRequest$outboundSchema;
  /** @deprecated use `AuthTokenApiRequest$Outbound` instead. */
  export type Outbound = AuthTokenApiRequest$Outbound;
}

export function authTokenApiRequestToJSON(
  authTokenApiRequest: AuthTokenApiRequest,
): string {
  return JSON.stringify(
    AuthTokenApiRequest$outboundSchema.parse(authTokenApiRequest),
  );
}

export function authTokenApiRequestFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenApiRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiRequest' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiAction$inboundSchema: z.ZodNativeEnum<
  typeof AuthTokenApiAction
> = z.nativeEnum(AuthTokenApiAction);

/** @internal */
export const AuthTokenApiAction$outboundSchema: z.ZodNativeEnum<
  typeof AuthTokenApiAction
> = AuthTokenApiAction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiAction$ {
  /** @deprecated use `AuthTokenApiAction$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiAction$inboundSchema;
  /** @deprecated use `AuthTokenApiAction$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiAction$outboundSchema;
}

/** @internal */
export const AuthTokenApiProperty$inboundSchema: z.ZodType<
  AuthTokenApiProperty,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
  hidden: z.boolean().optional(),
});

/** @internal */
export type AuthTokenApiProperty$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
  hidden?: boolean | undefined;
};

/** @internal */
export const AuthTokenApiProperty$outboundSchema: z.ZodType<
  AuthTokenApiProperty$Outbound,
  z.ZodTypeDef,
  AuthTokenApiProperty
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
  hidden: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiProperty$ {
  /** @deprecated use `AuthTokenApiProperty$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiProperty$inboundSchema;
  /** @deprecated use `AuthTokenApiProperty$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiProperty$outboundSchema;
  /** @deprecated use `AuthTokenApiProperty$Outbound` instead. */
  export type Outbound = AuthTokenApiProperty$Outbound;
}

export function authTokenApiPropertyToJSON(
  authTokenApiProperty: AuthTokenApiProperty,
): string {
  return JSON.stringify(
    AuthTokenApiProperty$outboundSchema.parse(authTokenApiProperty),
  );
}

export function authTokenApiPropertyFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiProperty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenApiProperty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiProperty' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiElement$inboundSchema: z.ZodType<
  AuthTokenApiElement,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string(),
  locations: z.array(z.string()).optional(),
  actions: z.array(z.string()).optional(),
  dataTypes: z.array(z.string()).optional(),
  identifier: z.string().optional(),
  privileges: z.array(z.string()).optional(),
  otherFields: z.string().optional(),
});

/** @internal */
export type AuthTokenApiElement$Outbound = {
  type: string;
  locations?: Array<string> | undefined;
  actions?: Array<string> | undefined;
  dataTypes?: Array<string> | undefined;
  identifier?: string | undefined;
  privileges?: Array<string> | undefined;
  otherFields?: string | undefined;
};

/** @internal */
export const AuthTokenApiElement$outboundSchema: z.ZodType<
  AuthTokenApiElement$Outbound,
  z.ZodTypeDef,
  AuthTokenApiElement
> = z.object({
  type: z.string(),
  locations: z.array(z.string()).optional(),
  actions: z.array(z.string()).optional(),
  dataTypes: z.array(z.string()).optional(),
  identifier: z.string().optional(),
  privileges: z.array(z.string()).optional(),
  otherFields: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiElement$ {
  /** @deprecated use `AuthTokenApiElement$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiElement$inboundSchema;
  /** @deprecated use `AuthTokenApiElement$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiElement$outboundSchema;
  /** @deprecated use `AuthTokenApiElement$Outbound` instead. */
  export type Outbound = AuthTokenApiElement$Outbound;
}

export function authTokenApiElementToJSON(
  authTokenApiElement: AuthTokenApiElement,
): string {
  return JSON.stringify(
    AuthTokenApiElement$outboundSchema.parse(authTokenApiElement),
  );
}

export function authTokenApiElementFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiElement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenApiElement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiElement' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiAuthorizationDetails$inboundSchema: z.ZodType<
  AuthTokenApiAuthorizationDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  elements: z.array(z.lazy(() => AuthTokenApiElement$inboundSchema)).optional(),
});

/** @internal */
export type AuthTokenApiAuthorizationDetails$Outbound = {
  elements?: Array<AuthTokenApiElement$Outbound> | undefined;
};

/** @internal */
export const AuthTokenApiAuthorizationDetails$outboundSchema: z.ZodType<
  AuthTokenApiAuthorizationDetails$Outbound,
  z.ZodTypeDef,
  AuthTokenApiAuthorizationDetails
> = z.object({
  elements: z.array(z.lazy(() => AuthTokenApiElement$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiAuthorizationDetails$ {
  /** @deprecated use `AuthTokenApiAuthorizationDetails$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiAuthorizationDetails$inboundSchema;
  /** @deprecated use `AuthTokenApiAuthorizationDetails$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiAuthorizationDetails$outboundSchema;
  /** @deprecated use `AuthTokenApiAuthorizationDetails$Outbound` instead. */
  export type Outbound = AuthTokenApiAuthorizationDetails$Outbound;
}

export function authTokenApiAuthorizationDetailsToJSON(
  authTokenApiAuthorizationDetails: AuthTokenApiAuthorizationDetails,
): string {
  return JSON.stringify(
    AuthTokenApiAuthorizationDetails$outboundSchema.parse(
      authTokenApiAuthorizationDetails,
    ),
  );
}

export function authTokenApiAuthorizationDetailsFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiAuthorizationDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenApiAuthorizationDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiAuthorizationDetails' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiServiceAttribute$inboundSchema: z.ZodType<
  AuthTokenApiServiceAttribute,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type AuthTokenApiServiceAttribute$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const AuthTokenApiServiceAttribute$outboundSchema: z.ZodType<
  AuthTokenApiServiceAttribute$Outbound,
  z.ZodTypeDef,
  AuthTokenApiServiceAttribute
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiServiceAttribute$ {
  /** @deprecated use `AuthTokenApiServiceAttribute$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiServiceAttribute$inboundSchema;
  /** @deprecated use `AuthTokenApiServiceAttribute$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiServiceAttribute$outboundSchema;
  /** @deprecated use `AuthTokenApiServiceAttribute$Outbound` instead. */
  export type Outbound = AuthTokenApiServiceAttribute$Outbound;
}

export function authTokenApiServiceAttributeToJSON(
  authTokenApiServiceAttribute: AuthTokenApiServiceAttribute,
): string {
  return JSON.stringify(
    AuthTokenApiServiceAttribute$outboundSchema.parse(
      authTokenApiServiceAttribute,
    ),
  );
}

export function authTokenApiServiceAttributeFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiServiceAttribute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenApiServiceAttribute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiServiceAttribute' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiClientAttribute$inboundSchema: z.ZodType<
  AuthTokenApiClientAttribute,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/** @internal */
export type AuthTokenApiClientAttribute$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const AuthTokenApiClientAttribute$outboundSchema: z.ZodType<
  AuthTokenApiClientAttribute$Outbound,
  z.ZodTypeDef,
  AuthTokenApiClientAttribute
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiClientAttribute$ {
  /** @deprecated use `AuthTokenApiClientAttribute$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiClientAttribute$inboundSchema;
  /** @deprecated use `AuthTokenApiClientAttribute$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiClientAttribute$outboundSchema;
  /** @deprecated use `AuthTokenApiClientAttribute$Outbound` instead. */
  export type Outbound = AuthTokenApiClientAttribute$Outbound;
}

export function authTokenApiClientAttributeToJSON(
  authTokenApiClientAttribute: AuthTokenApiClientAttribute,
): string {
  return JSON.stringify(
    AuthTokenApiClientAttribute$outboundSchema.parse(
      authTokenApiClientAttribute,
    ),
  );
}

export function authTokenApiClientAttributeFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiClientAttribute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenApiClientAttribute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiClientAttribute' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiRequestedTokenType$inboundSchema: z.ZodNativeEnum<
  typeof AuthTokenApiRequestedTokenType
> = z.nativeEnum(AuthTokenApiRequestedTokenType);

/** @internal */
export const AuthTokenApiRequestedTokenType$outboundSchema: z.ZodNativeEnum<
  typeof AuthTokenApiRequestedTokenType
> = AuthTokenApiRequestedTokenType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiRequestedTokenType$ {
  /** @deprecated use `AuthTokenApiRequestedTokenType$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiRequestedTokenType$inboundSchema;
  /** @deprecated use `AuthTokenApiRequestedTokenType$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiRequestedTokenType$outboundSchema;
}

/** @internal */
export const AuthTokenApiSubjectTokenType$inboundSchema: z.ZodNativeEnum<
  typeof AuthTokenApiSubjectTokenType
> = z.nativeEnum(AuthTokenApiSubjectTokenType);

/** @internal */
export const AuthTokenApiSubjectTokenType$outboundSchema: z.ZodNativeEnum<
  typeof AuthTokenApiSubjectTokenType
> = AuthTokenApiSubjectTokenType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiSubjectTokenType$ {
  /** @deprecated use `AuthTokenApiSubjectTokenType$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiSubjectTokenType$inboundSchema;
  /** @deprecated use `AuthTokenApiSubjectTokenType$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiSubjectTokenType$outboundSchema;
}

/** @internal */
export const AuthTokenApiSubjectTokenInfoProperty$inboundSchema: z.ZodType<
  AuthTokenApiSubjectTokenInfoProperty,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
  hidden: z.boolean().optional(),
});

/** @internal */
export type AuthTokenApiSubjectTokenInfoProperty$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
  hidden?: boolean | undefined;
};

/** @internal */
export const AuthTokenApiSubjectTokenInfoProperty$outboundSchema: z.ZodType<
  AuthTokenApiSubjectTokenInfoProperty$Outbound,
  z.ZodTypeDef,
  AuthTokenApiSubjectTokenInfoProperty
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
  hidden: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiSubjectTokenInfoProperty$ {
  /** @deprecated use `AuthTokenApiSubjectTokenInfoProperty$inboundSchema` instead. */
  export const inboundSchema =
    AuthTokenApiSubjectTokenInfoProperty$inboundSchema;
  /** @deprecated use `AuthTokenApiSubjectTokenInfoProperty$outboundSchema` instead. */
  export const outboundSchema =
    AuthTokenApiSubjectTokenInfoProperty$outboundSchema;
  /** @deprecated use `AuthTokenApiSubjectTokenInfoProperty$Outbound` instead. */
  export type Outbound = AuthTokenApiSubjectTokenInfoProperty$Outbound;
}

export function authTokenApiSubjectTokenInfoPropertyToJSON(
  authTokenApiSubjectTokenInfoProperty: AuthTokenApiSubjectTokenInfoProperty,
): string {
  return JSON.stringify(
    AuthTokenApiSubjectTokenInfoProperty$outboundSchema.parse(
      authTokenApiSubjectTokenInfoProperty,
    ),
  );
}

export function authTokenApiSubjectTokenInfoPropertyFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiSubjectTokenInfoProperty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AuthTokenApiSubjectTokenInfoProperty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiSubjectTokenInfoProperty' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiSubjectTokenInfoAuthorizationDetails$inboundSchema:
  z.ZodType<
    AuthTokenApiSubjectTokenInfoAuthorizationDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.string(),
    locations: z.array(z.string()).optional(),
    actions: z.array(z.string()).optional(),
    dataTypes: z.array(z.string()).optional(),
    identifier: z.string().optional(),
    privileges: z.array(z.string()).optional(),
    otherFields: z.string().optional(),
  });

/** @internal */
export type AuthTokenApiSubjectTokenInfoAuthorizationDetails$Outbound = {
  type: string;
  locations?: Array<string> | undefined;
  actions?: Array<string> | undefined;
  dataTypes?: Array<string> | undefined;
  identifier?: string | undefined;
  privileges?: Array<string> | undefined;
  otherFields?: string | undefined;
};

/** @internal */
export const AuthTokenApiSubjectTokenInfoAuthorizationDetails$outboundSchema:
  z.ZodType<
    AuthTokenApiSubjectTokenInfoAuthorizationDetails$Outbound,
    z.ZodTypeDef,
    AuthTokenApiSubjectTokenInfoAuthorizationDetails
  > = z.object({
    type: z.string(),
    locations: z.array(z.string()).optional(),
    actions: z.array(z.string()).optional(),
    dataTypes: z.array(z.string()).optional(),
    identifier: z.string().optional(),
    privileges: z.array(z.string()).optional(),
    otherFields: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiSubjectTokenInfoAuthorizationDetails$ {
  /** @deprecated use `AuthTokenApiSubjectTokenInfoAuthorizationDetails$inboundSchema` instead. */
  export const inboundSchema =
    AuthTokenApiSubjectTokenInfoAuthorizationDetails$inboundSchema;
  /** @deprecated use `AuthTokenApiSubjectTokenInfoAuthorizationDetails$outboundSchema` instead. */
  export const outboundSchema =
    AuthTokenApiSubjectTokenInfoAuthorizationDetails$outboundSchema;
  /** @deprecated use `AuthTokenApiSubjectTokenInfoAuthorizationDetails$Outbound` instead. */
  export type Outbound =
    AuthTokenApiSubjectTokenInfoAuthorizationDetails$Outbound;
}

export function authTokenApiSubjectTokenInfoAuthorizationDetailsToJSON(
  authTokenApiSubjectTokenInfoAuthorizationDetails:
    AuthTokenApiSubjectTokenInfoAuthorizationDetails,
): string {
  return JSON.stringify(
    AuthTokenApiSubjectTokenInfoAuthorizationDetails$outboundSchema.parse(
      authTokenApiSubjectTokenInfoAuthorizationDetails,
    ),
  );
}

export function authTokenApiSubjectTokenInfoAuthorizationDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  AuthTokenApiSubjectTokenInfoAuthorizationDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AuthTokenApiSubjectTokenInfoAuthorizationDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AuthTokenApiSubjectTokenInfoAuthorizationDetails' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiSubjectTokenInfo$inboundSchema: z.ZodType<
  AuthTokenApiSubjectTokenInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  subject: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  expiresAt: z.number().int().optional(),
  properties: z.array(
    z.lazy(() => AuthTokenApiSubjectTokenInfoProperty$inboundSchema),
  ).optional(),
  resources: z.array(z.string()).optional(),
  authorizationDetails: z.lazy(() =>
    AuthTokenApiSubjectTokenInfoAuthorizationDetails$inboundSchema
  ).optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
});

/** @internal */
export type AuthTokenApiSubjectTokenInfo$Outbound = {
  clientId?: number | undefined;
  clientIdAlias?: string | undefined;
  clientIdAliasUsed?: boolean | undefined;
  subject?: string | undefined;
  scopes?: Array<string> | undefined;
  expiresAt?: number | undefined;
  properties?: Array<AuthTokenApiSubjectTokenInfoProperty$Outbound> | undefined;
  resources?: Array<string> | undefined;
  authorizationDetails?:
    | AuthTokenApiSubjectTokenInfoAuthorizationDetails$Outbound
    | undefined;
  clientEntityId?: string | undefined;
  clientEntityIdUsed?: boolean | undefined;
};

/** @internal */
export const AuthTokenApiSubjectTokenInfo$outboundSchema: z.ZodType<
  AuthTokenApiSubjectTokenInfo$Outbound,
  z.ZodTypeDef,
  AuthTokenApiSubjectTokenInfo
> = z.object({
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  subject: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  expiresAt: z.number().int().optional(),
  properties: z.array(
    z.lazy(() => AuthTokenApiSubjectTokenInfoProperty$outboundSchema),
  ).optional(),
  resources: z.array(z.string()).optional(),
  authorizationDetails: z.lazy(() =>
    AuthTokenApiSubjectTokenInfoAuthorizationDetails$outboundSchema
  ).optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiSubjectTokenInfo$ {
  /** @deprecated use `AuthTokenApiSubjectTokenInfo$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiSubjectTokenInfo$inboundSchema;
  /** @deprecated use `AuthTokenApiSubjectTokenInfo$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiSubjectTokenInfo$outboundSchema;
  /** @deprecated use `AuthTokenApiSubjectTokenInfo$Outbound` instead. */
  export type Outbound = AuthTokenApiSubjectTokenInfo$Outbound;
}

export function authTokenApiSubjectTokenInfoToJSON(
  authTokenApiSubjectTokenInfo: AuthTokenApiSubjectTokenInfo,
): string {
  return JSON.stringify(
    AuthTokenApiSubjectTokenInfo$outboundSchema.parse(
      authTokenApiSubjectTokenInfo,
    ),
  );
}

export function authTokenApiSubjectTokenInfoFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiSubjectTokenInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenApiSubjectTokenInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiSubjectTokenInfo' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiActorTokenType$inboundSchema: z.ZodNativeEnum<
  typeof AuthTokenApiActorTokenType
> = z.nativeEnum(AuthTokenApiActorTokenType);

/** @internal */
export const AuthTokenApiActorTokenType$outboundSchema: z.ZodNativeEnum<
  typeof AuthTokenApiActorTokenType
> = AuthTokenApiActorTokenType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiActorTokenType$ {
  /** @deprecated use `AuthTokenApiActorTokenType$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiActorTokenType$inboundSchema;
  /** @deprecated use `AuthTokenApiActorTokenType$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiActorTokenType$outboundSchema;
}

/** @internal */
export const AuthTokenApiActorTokenInfoProperty$inboundSchema: z.ZodType<
  AuthTokenApiActorTokenInfoProperty,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
  hidden: z.boolean().optional(),
});

/** @internal */
export type AuthTokenApiActorTokenInfoProperty$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
  hidden?: boolean | undefined;
};

/** @internal */
export const AuthTokenApiActorTokenInfoProperty$outboundSchema: z.ZodType<
  AuthTokenApiActorTokenInfoProperty$Outbound,
  z.ZodTypeDef,
  AuthTokenApiActorTokenInfoProperty
> = z.object({
  key: z.string().optional(),
  value: z.string().optional(),
  hidden: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiActorTokenInfoProperty$ {
  /** @deprecated use `AuthTokenApiActorTokenInfoProperty$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiActorTokenInfoProperty$inboundSchema;
  /** @deprecated use `AuthTokenApiActorTokenInfoProperty$outboundSchema` instead. */
  export const outboundSchema =
    AuthTokenApiActorTokenInfoProperty$outboundSchema;
  /** @deprecated use `AuthTokenApiActorTokenInfoProperty$Outbound` instead. */
  export type Outbound = AuthTokenApiActorTokenInfoProperty$Outbound;
}

export function authTokenApiActorTokenInfoPropertyToJSON(
  authTokenApiActorTokenInfoProperty: AuthTokenApiActorTokenInfoProperty,
): string {
  return JSON.stringify(
    AuthTokenApiActorTokenInfoProperty$outboundSchema.parse(
      authTokenApiActorTokenInfoProperty,
    ),
  );
}

export function authTokenApiActorTokenInfoPropertyFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiActorTokenInfoProperty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AuthTokenApiActorTokenInfoProperty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiActorTokenInfoProperty' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiActorTokenInfoAuthorizationDetails$inboundSchema:
  z.ZodType<
    AuthTokenApiActorTokenInfoAuthorizationDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.string(),
    locations: z.array(z.string()).optional(),
    actions: z.array(z.string()).optional(),
    dataTypes: z.array(z.string()).optional(),
    identifier: z.string().optional(),
    privileges: z.array(z.string()).optional(),
    otherFields: z.string().optional(),
  });

/** @internal */
export type AuthTokenApiActorTokenInfoAuthorizationDetails$Outbound = {
  type: string;
  locations?: Array<string> | undefined;
  actions?: Array<string> | undefined;
  dataTypes?: Array<string> | undefined;
  identifier?: string | undefined;
  privileges?: Array<string> | undefined;
  otherFields?: string | undefined;
};

/** @internal */
export const AuthTokenApiActorTokenInfoAuthorizationDetails$outboundSchema:
  z.ZodType<
    AuthTokenApiActorTokenInfoAuthorizationDetails$Outbound,
    z.ZodTypeDef,
    AuthTokenApiActorTokenInfoAuthorizationDetails
  > = z.object({
    type: z.string(),
    locations: z.array(z.string()).optional(),
    actions: z.array(z.string()).optional(),
    dataTypes: z.array(z.string()).optional(),
    identifier: z.string().optional(),
    privileges: z.array(z.string()).optional(),
    otherFields: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiActorTokenInfoAuthorizationDetails$ {
  /** @deprecated use `AuthTokenApiActorTokenInfoAuthorizationDetails$inboundSchema` instead. */
  export const inboundSchema =
    AuthTokenApiActorTokenInfoAuthorizationDetails$inboundSchema;
  /** @deprecated use `AuthTokenApiActorTokenInfoAuthorizationDetails$outboundSchema` instead. */
  export const outboundSchema =
    AuthTokenApiActorTokenInfoAuthorizationDetails$outboundSchema;
  /** @deprecated use `AuthTokenApiActorTokenInfoAuthorizationDetails$Outbound` instead. */
  export type Outbound =
    AuthTokenApiActorTokenInfoAuthorizationDetails$Outbound;
}

export function authTokenApiActorTokenInfoAuthorizationDetailsToJSON(
  authTokenApiActorTokenInfoAuthorizationDetails:
    AuthTokenApiActorTokenInfoAuthorizationDetails,
): string {
  return JSON.stringify(
    AuthTokenApiActorTokenInfoAuthorizationDetails$outboundSchema.parse(
      authTokenApiActorTokenInfoAuthorizationDetails,
    ),
  );
}

export function authTokenApiActorTokenInfoAuthorizationDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  AuthTokenApiActorTokenInfoAuthorizationDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AuthTokenApiActorTokenInfoAuthorizationDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AuthTokenApiActorTokenInfoAuthorizationDetails' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiActorTokenInfo$inboundSchema: z.ZodType<
  AuthTokenApiActorTokenInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  subject: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  expiresAt: z.number().int().optional(),
  properties: z.array(
    z.lazy(() => AuthTokenApiActorTokenInfoProperty$inboundSchema),
  ).optional(),
  resources: z.array(z.string()).optional(),
  authorizationDetails: z.lazy(() =>
    AuthTokenApiActorTokenInfoAuthorizationDetails$inboundSchema
  ).optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
});

/** @internal */
export type AuthTokenApiActorTokenInfo$Outbound = {
  clientId?: number | undefined;
  clientIdAlias?: string | undefined;
  clientIdAliasUsed?: boolean | undefined;
  subject?: string | undefined;
  scopes?: Array<string> | undefined;
  expiresAt?: number | undefined;
  properties?: Array<AuthTokenApiActorTokenInfoProperty$Outbound> | undefined;
  resources?: Array<string> | undefined;
  authorizationDetails?:
    | AuthTokenApiActorTokenInfoAuthorizationDetails$Outbound
    | undefined;
  clientEntityId?: string | undefined;
  clientEntityIdUsed?: boolean | undefined;
};

/** @internal */
export const AuthTokenApiActorTokenInfo$outboundSchema: z.ZodType<
  AuthTokenApiActorTokenInfo$Outbound,
  z.ZodTypeDef,
  AuthTokenApiActorTokenInfo
> = z.object({
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  subject: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  expiresAt: z.number().int().optional(),
  properties: z.array(
    z.lazy(() => AuthTokenApiActorTokenInfoProperty$outboundSchema),
  ).optional(),
  resources: z.array(z.string()).optional(),
  authorizationDetails: z.lazy(() =>
    AuthTokenApiActorTokenInfoAuthorizationDetails$outboundSchema
  ).optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiActorTokenInfo$ {
  /** @deprecated use `AuthTokenApiActorTokenInfo$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiActorTokenInfo$inboundSchema;
  /** @deprecated use `AuthTokenApiActorTokenInfo$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiActorTokenInfo$outboundSchema;
  /** @deprecated use `AuthTokenApiActorTokenInfo$Outbound` instead. */
  export type Outbound = AuthTokenApiActorTokenInfo$Outbound;
}

export function authTokenApiActorTokenInfoToJSON(
  authTokenApiActorTokenInfo: AuthTokenApiActorTokenInfo,
): string {
  return JSON.stringify(
    AuthTokenApiActorTokenInfo$outboundSchema.parse(authTokenApiActorTokenInfo),
  );
}

export function authTokenApiActorTokenInfoFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiActorTokenInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenApiActorTokenInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiActorTokenInfo' from JSON`,
  );
}

/** @internal */
export const AuthTokenApiResponse$inboundSchema: z.ZodType<
  AuthTokenApiResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: AuthTokenApiAction$inboundSchema.optional(),
  responseContent: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  ticket: z.string().optional(),
  accessToken: z.string().optional(),
  accessTokenExpiresAt: z.number().int().optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshToken: z.string().optional(),
  refreshTokenExpiresAt: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  idToken: z.string().optional(),
  grantType: z.string().optional(),
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  subject: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  properties: z.array(z.lazy(() => AuthTokenApiProperty$inboundSchema))
    .optional(),
  jwtAccessToken: z.string().optional(),
  resources: z.array(z.string()).optional(),
  accessTokenResources: z.array(z.string()).optional(),
  authorizationDetails: z.lazy(() =>
    AuthTokenApiAuthorizationDetails$inboundSchema
  ).optional(),
  serviceAttributes: z.array(
    z.lazy(() => AuthTokenApiServiceAttribute$inboundSchema),
  ).optional(),
  clientAttributes: z.array(
    z.lazy(() => AuthTokenApiClientAttribute$inboundSchema),
  ).optional(),
  clientAuthMethod: z.string().optional(),
  grantId: z.string().optional(),
  audiences: z.array(z.string()).optional(),
  requestedTokenType: AuthTokenApiRequestedTokenType$inboundSchema.optional(),
  subjectToken: z.string().optional(),
  subjectTokenType: AuthTokenApiSubjectTokenType$inboundSchema.optional(),
  subjectTokenInfo: z.lazy(() => AuthTokenApiSubjectTokenInfo$inboundSchema)
    .optional(),
  actorToken: z.string().optional(),
  actorTokenType: AuthTokenApiActorTokenType$inboundSchema.optional(),
  actorTokenInfo: z.lazy(() => AuthTokenApiActorTokenInfo$inboundSchema)
    .optional(),
  assertion: z.string().optional(),
  previousRefreshTokenUsed: z.boolean().optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
  cnonceDuration: z.number().int().optional(),
  dpopNonce: z.string().optional(),
  cnonce: z.string().optional(),
  cnonceExpiresAt: z.number().int().optional(),
  requestedIdTokenClaims: z.array(z.string()).optional(),
  refreshTokenScopes: z.array(z.string()).optional(),
});

/** @internal */
export type AuthTokenApiResponse$Outbound = {
  resultCode?: string | undefined;
  resultMessage?: string | undefined;
  action?: string | undefined;
  responseContent?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  ticket?: string | undefined;
  accessToken?: string | undefined;
  accessTokenExpiresAt?: number | undefined;
  accessTokenDuration?: number | undefined;
  refreshToken?: string | undefined;
  refreshTokenExpiresAt?: number | undefined;
  refreshTokenDuration?: number | undefined;
  idToken?: string | undefined;
  grantType?: string | undefined;
  clientId?: number | undefined;
  clientIdAlias?: string | undefined;
  clientIdAliasUsed?: boolean | undefined;
  subject?: string | undefined;
  scopes?: Array<string> | undefined;
  properties?: Array<AuthTokenApiProperty$Outbound> | undefined;
  jwtAccessToken?: string | undefined;
  resources?: Array<string> | undefined;
  accessTokenResources?: Array<string> | undefined;
  authorizationDetails?: AuthTokenApiAuthorizationDetails$Outbound | undefined;
  serviceAttributes?: Array<AuthTokenApiServiceAttribute$Outbound> | undefined;
  clientAttributes?: Array<AuthTokenApiClientAttribute$Outbound> | undefined;
  clientAuthMethod?: string | undefined;
  grantId?: string | undefined;
  audiences?: Array<string> | undefined;
  requestedTokenType?: string | undefined;
  subjectToken?: string | undefined;
  subjectTokenType?: string | undefined;
  subjectTokenInfo?: AuthTokenApiSubjectTokenInfo$Outbound | undefined;
  actorToken?: string | undefined;
  actorTokenType?: string | undefined;
  actorTokenInfo?: AuthTokenApiActorTokenInfo$Outbound | undefined;
  assertion?: string | undefined;
  previousRefreshTokenUsed?: boolean | undefined;
  clientEntityId?: string | undefined;
  clientEntityIdUsed?: boolean | undefined;
  cnonceDuration?: number | undefined;
  dpopNonce?: string | undefined;
  cnonce?: string | undefined;
  cnonceExpiresAt?: number | undefined;
  requestedIdTokenClaims?: Array<string> | undefined;
  refreshTokenScopes?: Array<string> | undefined;
};

/** @internal */
export const AuthTokenApiResponse$outboundSchema: z.ZodType<
  AuthTokenApiResponse$Outbound,
  z.ZodTypeDef,
  AuthTokenApiResponse
> = z.object({
  resultCode: z.string().optional(),
  resultMessage: z.string().optional(),
  action: AuthTokenApiAction$outboundSchema.optional(),
  responseContent: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  ticket: z.string().optional(),
  accessToken: z.string().optional(),
  accessTokenExpiresAt: z.number().int().optional(),
  accessTokenDuration: z.number().int().optional(),
  refreshToken: z.string().optional(),
  refreshTokenExpiresAt: z.number().int().optional(),
  refreshTokenDuration: z.number().int().optional(),
  idToken: z.string().optional(),
  grantType: z.string().optional(),
  clientId: z.number().int().optional(),
  clientIdAlias: z.string().optional(),
  clientIdAliasUsed: z.boolean().optional(),
  subject: z.string().optional(),
  scopes: z.array(z.string()).optional(),
  properties: z.array(z.lazy(() => AuthTokenApiProperty$outboundSchema))
    .optional(),
  jwtAccessToken: z.string().optional(),
  resources: z.array(z.string()).optional(),
  accessTokenResources: z.array(z.string()).optional(),
  authorizationDetails: z.lazy(() =>
    AuthTokenApiAuthorizationDetails$outboundSchema
  ).optional(),
  serviceAttributes: z.array(
    z.lazy(() => AuthTokenApiServiceAttribute$outboundSchema),
  ).optional(),
  clientAttributes: z.array(
    z.lazy(() => AuthTokenApiClientAttribute$outboundSchema),
  ).optional(),
  clientAuthMethod: z.string().optional(),
  grantId: z.string().optional(),
  audiences: z.array(z.string()).optional(),
  requestedTokenType: AuthTokenApiRequestedTokenType$outboundSchema.optional(),
  subjectToken: z.string().optional(),
  subjectTokenType: AuthTokenApiSubjectTokenType$outboundSchema.optional(),
  subjectTokenInfo: z.lazy(() => AuthTokenApiSubjectTokenInfo$outboundSchema)
    .optional(),
  actorToken: z.string().optional(),
  actorTokenType: AuthTokenApiActorTokenType$outboundSchema.optional(),
  actorTokenInfo: z.lazy(() => AuthTokenApiActorTokenInfo$outboundSchema)
    .optional(),
  assertion: z.string().optional(),
  previousRefreshTokenUsed: z.boolean().optional(),
  clientEntityId: z.string().optional(),
  clientEntityIdUsed: z.boolean().optional(),
  cnonceDuration: z.number().int().optional(),
  dpopNonce: z.string().optional(),
  cnonce: z.string().optional(),
  cnonceExpiresAt: z.number().int().optional(),
  requestedIdTokenClaims: z.array(z.string()).optional(),
  refreshTokenScopes: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthTokenApiResponse$ {
  /** @deprecated use `AuthTokenApiResponse$inboundSchema` instead. */
  export const inboundSchema = AuthTokenApiResponse$inboundSchema;
  /** @deprecated use `AuthTokenApiResponse$outboundSchema` instead. */
  export const outboundSchema = AuthTokenApiResponse$outboundSchema;
  /** @deprecated use `AuthTokenApiResponse$Outbound` instead. */
  export type Outbound = AuthTokenApiResponse$Outbound;
}

export function authTokenApiResponseToJSON(
  authTokenApiResponse: AuthTokenApiResponse,
): string {
  return JSON.stringify(
    AuthTokenApiResponse$outboundSchema.parse(authTokenApiResponse),
  );
}

export function authTokenApiResponseFromJSON(
  jsonString: string,
): SafeParseResult<AuthTokenApiResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthTokenApiResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthTokenApiResponse' from JSON`,
  );
}
